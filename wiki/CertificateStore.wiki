#labels Java, SSL, TrustManager

<h4>Overview</h4>

The problem with client-authenticated connections is that enrollment is tedious, either requiring a certificate signing process, or otherwise importing the client's certificate in advance, before the client can connect. Clearly a new client cannot register itself via the client-authenticated connection. Moreover certificate expiry requires this process to be repeated regularly.

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/wooden-shield200.png" />

As a consequence of the inconvenience of client certificate generation, enrollment and renewal, browser certificates are not widely used for consumer sites i.e. for client-authenticated HTTPS. Typically cookies are used to record authenticated sessions, and these might be hijacked using <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting</a>, and used to spoof authenticated clients.

A further impediment to client-authenticated HTTPS sites is that they require a non-client-authenticated HTTPS server for enrollment. Unfortunately the standard port number is the same for both, i.e. 443, which is widely allowed by firewalls. Consequently two hosts are typically required, i.e. with different IP numbers.

So let's implement a dynamic truststore which enables us to support client-authenticated SSL connections, but where new clients can register via this same connection, via a custom trust manager. We wish to achieve convenience comparable to non-client-authenticated SSL connections, but with enhanced security e.g. preventing client spoofing attacks.

For example, we might trust a new client who submits a valid registration request, provide them with a PKCS12 key and certificate e.g. to import into their browser, and automatically import their certificate into our truststore.

<h4>SQL truststore</h4>

Our truststore might be an SQL database table with a column for the client certificate name, and another for the certificate itself.
{{{
create table client_cert (
  cert_name text,
  cert text, 
  enabled boolean default false
);
}}}
where the certificate would be Base64-encoded for SQL storage.

We might pre-approve new client devices that we are expecting to connect, by inserting a record with the certificate name but a <tt>null</tt> entry for the actual certificate. The certificate column is set later when the client connects for the first time. Also, we can revoke clients by setting the <tt>enabled</tt> column to <tt>false</tt>.

<h4><tt>SSLSession</tt></h4>

When we accept the connection to the <tt>SSLServerSocket</tt>, our application validates the request message, and can then import the peer certificate. Our application can get the client certificate via the <tt>SSLSession</tt> of the client <tt>SSLSocket</tt>, as demonstrated in the following test code.
{{{
    static void accept(KeyStore keyStore, char[] keyPassword, KeyStore trustStore,
            int port) throws GeneralSecurityException, IOException {
        SSLContext sslContext = SSLContexts.create(keyStore, keyPassword, trustStore);
        SSLServerSocket serverSocket = (SSLServerSocket) sslContext.
                getServerSocketFactory().createServerSocket(port);
        try {
            serverSocket.setNeedClientAuth(true);
            SSLSocket clientSocket = (SSLSocket) serverSocket.accept();
            javax.security.cert.X509Certificate peer = 
                    clientSocket.getSession().getPeerCertificateChain()[0];
            logger.info("peer: " + peer.getSubjectDN().getName());
            ServerThread.handle(clientSocket);
        } finally {
            serverSocket.close();
        }
    }
}}}

Our application might validate the content of the message, e.g. a registration request, and import the peer certificate into our dynamic truststore e.g. by updating the record in our SQL truststore.

<h4>Trust manager</h4>

Alternatively our trust manager itself might auto-import certificates. To this end, firstly let's implement a trivial trust manager to accept certificates using a delegate.
{{{
public class DelegatingClientTrustManager implements X509TrustManager {
    TrustManagerDelegate delegate;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        if (chain.length == 0) {
            if (!delegate.accept()) {
                throw new CertificateException("No certificate");
            }
        }
        if (!delegate.accept(chain[0])) {
            throw new CertificateException("Certificate not accepted");            
        }
    }
}}}
where our delegate might accept clients without a certificate, i.e. without requiring client-authentication, where our application will authenticate the message.
{{{
public class StorageTrustManagerDelegate implements TrustManagerDelegate {
    final private boolean requireCertificate;
    final private boolean autoInsert;
    final private CertificateStorage certificateStorage;
    
    public StorageTrustManagerDelegate(
            boolean requireCertificate, 
            boolean autoInsert, 
            CertificateStorage certificateStorage) {
        this.requireCertificate = requireCertificate;
        this.autoInsert = autoInsert;
        this.certificateStorage = certificateStorage;
    }
    ...
}
}}}
For example, we might accept a client without an certificate in order to enable it to send a registration request for the server to generate a key and certificate on the client's behalf. For example, the server might respond to such a request with a <a href="http://en.wikipedia.org/wiki/PKCS_12">PKCS12</a> bundle.

In this case the server might sign the certificate, or import it into the truststore. Perhaps the certificate are initially disabled in the truststore database, pending manual approval by the appropriate administrator.

<h4>Certificate storage</h4>

We provide a mockable certificate storage implementation to our trust manager delegate.
{{{
public interface CertificateStorage {
    public void insert(String commonName, X509Certificate cert) throws CertificateStorageException;
    public boolean exists(String commonName) throws CertificateStorageException;
    public boolean isNull(String commonName) throws CertificateStorageException;
    public void set(String commonName, X509Certificate cert) throws CertificateStorageException;
    public boolean isEnabled(String commonName) throws CertificateStorageException;
    public X509Certificate load(String commonName) throws CertificateStorageException;    
    public void update(String commonName, X509Certificate cert) throws CertificateStorageException;
}
}}}
where if the record for that common name exists but has a <tt>null</tt> certificate, then <tt>isNull()</tt> returns <tt>true</tt>, and we can <tt>set()</tt> the certificate. If the certificate <tt>exists()</tt>, then we can <tt>load()</tt> it, and <tt>update()</tt> it i.e. if it has expired.
{{{
    @Override
    public boolean accept(X509Certificate peerCertificate) throws CertificateException {
        String commonName = Certificates.getCommonName(peerCertificate.getSubjectDN());
        try {
            if (certificateStorage.exists(commonName)) {
                if (certificateStorage.isNull(commonName)) {
                    certificateStorage.set(commonName, peerCertificate);
                    return true;
                } else {
                    X509Certificate trustedCertificate = certificateStorage.load(commonName);
                    if (new Date().after(trustedCertificate.getNotAfter())) {
                        certificateStorage.update(commonName, peerCertificate);
                        return true;
                    } else if (certificateStorage.isEnabled(commonName)) {                        
                        return Arrays.equals(peerCertificate.getPublicKey().getEncoded(),
                                trustedCertificate.getPublicKey().getEncoded());
                    } else {
                        return false;
                    }
                }
            } else if (autoInsert) {
                certificateStorage.insert(commonName, peerCertificate);
                return true;
            } else {
                return false;                
            }
        } catch (CertificateStorageException e) {
            throw new CertificateException(e);
        }
    }
}}}
where we check that an existing certificate is <tt>enabled</tt> i.e. has not been thereby revoked. If we auto-insert a new certificiate, then <tt>enabled</tt> might be <tt>false</tt>, where our application might enable it automatically following registration, or require an administrator to do so manually.


<h4>Conclusion</h4>

We introduce a trust manager to enable automated registration, where new clients' certificates are imported into our truststore when they connect for the first time, and thereafter we validate our clients' certificates, to protect against spoofing attacks.


<img align="right" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

<h4>Furthermore</h4>

We'll delve into the unit testing of our custom trust manager in a follow-up article.

<h4>Resources</h4>

You can browse the code for this exercise on <a href="https://code.google.com/p/vellum">code.google.com/vellum</a>.

<h4>Other reading</h4>

Also relating to Java crypto in this blog: <a href="https://weblogs.java.net/blog/evanx/archive/2013/01/24/password-salt">Password Salt</a> for secure passwords; and leveraging the <a href="https://weblogs.java.net/blog/evanx/archive/2012/11/07/google-authenticator-thus-enabled">Google Authenticator</a> mobile app for multi-factor authentication for your own sites.

