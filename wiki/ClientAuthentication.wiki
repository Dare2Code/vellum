#labels Java, SSL, TrustManager

<h4>Problem overview</h4>

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/wooden-shield200.png" />

Client-authenticated SSL connections require client certificate generation, enrollment, and renewal. Enrollment typically requires a manual process, either certificate signing, or importing into our truststore. Moreover certificate expiry requires this process to be repeated regularly (since key revision is an important best practice for security). 

Consequently browser certificates are not widely used for consumer sites i.e. for client-authenticated HTTPS. Typically cookies are used to record authenticated sessions. However, we hear that such cookies are routinely hijacked using <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting</a> attacks, in order to mount a <a href="http://en.wikipedia.org/wiki/Spoofing_attack">spoofing attack</a> as an authenticated client, and thereby breach our access security.

Alternatively, our application might support client devices connecting via SSL sockets, where we want to automate certificate management for operational reasons.

<h4>Solution overview</h4>

We consider automated using a custom trust manager that recognises new clients, and automatically imports their certificate into our truststore. Otherwise the trust manager authenticates existing clients to protect against spoofing attacks.

A new client might be pre-approved by an administrator according to its expected certificate name, where we automatically import its certificate the first time it connects. The risk is that a rogue client connects before the legitimate client. However, this requires immediate knowledge of currently pending client names. Also, our application might mitigate this risk, e.g. where the new client's access is restricted until it is somehow confirmed.

Alternatively a new client might connect without a certificate, in order to send a registration request for the server to generate a PKCS12 key and certificate bundle on its behalf. For example, our HTTPS server might send this as its response i.e. with a content type of <tt>application/x-pkcs12</tt>, to be imported by the client's browser.

 
<h4>SQL truststore</h4>

Our dynamic truststore might be an SQL database table with columns for the client certificate name, the certificate itself, and its status.
{{{
CREATE TABLE client_cert (
  cert_name VARCHAR(255) PRIMARY KEY,
  cert VARCHAR(4096), 
  enabled BOOL DEFAULT TRUE,
  expiry_date TIMESTAMP, 
  confirmed_date TIMESTAMP
);
}}}
where the certificate name is unique. Incidently, the certificate itself would be Base64-encoded for SQL storage. For convenience we might want an explicit expiry date column, even though that information is in the certificate, e.g. where this is used by a script for alerts of impending expiry dates.

<img align="left" style="margin-left: 4px" src="http://upload.wikimedia.org/wikipedia/commons/4/40/Crystal_Clear_app_database.png" />

We might import certificates for new clients where these are disabled until validated by our application, and perhaps their access is restricted pending confirmation by an administrator. In this case, we might be vulnerable to a denial of service attack whereby our server is flooded with new clients. We could counter this limiting the number of new clients that are recorded from the same source IP number, limiting the rate in general, and enforcing a cutoff where we disable any new clients for some period.

Alternatively we might pre-approve a new client by inserting a record with its expected certificate name, but with a <tt>null</tt> entry for the actual certificate. The certificate is then set when the client connects for the first time. In this case, we might use the <tt>expiry_date</tt> column to apply to enrollment. The new client is thus given a limited window to enroll, in order to reduce the risk of a rogue client, especially if the legitimate client never enrolls for some reason.

Incidently, clearly we can "revoke" a client certificate by setting its <tt>enabled</tt> column to <tt>false</tt>. However in this case the certificate name cannot be reused, because of our uniqueness constraint.


<h4><tt>SSLSession</tt></h4>

When we accept a connection to our <tt>SSLServerSocket</tt>, naturally our application reads and validates the request message. At this stage, our application itself might import the peer certificate e.g. for new clients that send a valid registration message. We can get the client certificate via the <tt>SSLSession</tt> of the client <tt>SSLSocket</tt>, as demonstrated in the following test code.
{{{
    static void accept(KeyStore keyStore, char[] keyPassword, KeyStore trustStore,
            int port) throws GeneralSecurityException, IOException {
        SSLContext sslContext = SSLContexts.create(keyStore, keyPassword, trustStore);
        SSLServerSocket serverSocket = (SSLServerSocket) sslContext.
                getServerSocketFactory().createServerSocket(port);
        try {
            serverSocket.setNeedClientAuth(true);
            SSLSocket clientSocket = (SSLSocket) serverSocket.accept();
            javax.security.cert.X509Certificate peer = 
                    clientSocket.getSession().getPeerCertificateChain()[0];
            logger.info("peer: " + peer.getSubjectDN().getName());
            ServerThread.handle(clientSocket);
        } finally {
            serverSocket.close();
        }
    }
}}}
where our application might import that peer certificate that its truststore. In this case, our trust manager should allow connections by new clients whose certificates are not yet in our truststore. Alternatively our trust manager itself might import new certificates. 

<h4>Certificate storage</h4>

We provide a mockable certificate storage implementation for our SQL truststore.
{{{
public interface CertificateStorage {
    public boolean exists(String commonName) throws CertificateStorageException;
    public void insert(String commonName, X509Certificate cert) throws CertificateStorageException;
    public boolean isNullCert(String commonName) throws CertificateStorageException;
    public void setCert(String commonName, X509Certificate cert) throws CertificateStorageException;
    public boolean isEnabled(String commonName) throws CertificateStorageException;
    public X509Certificate load(String commonName) throws CertificateStorageException;    
    public void update(String commonName, X509Certificate cert) throws CertificateStorageException;
}
}}}
where if the record for that common name exists but has a <tt>null</tt> certificate, then <tt>isNullCert()</tt> returns <tt>true</tt>, and we can invoke <tt>setCert()</tt> to set the certificate. If the certificate <tt>exists()</tt>, then we can <tt>load()</tt> it, and <tt>update()</tt> it i.e. if it has expired.


<h4>Delegating trust manager</h4>

We implement a trivial trust manager to accept certificates using a delegate.
{{{
public class DelegatingClientTrustManager implements X509TrustManager {
    TrustManagerDelegate delegate;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        if (chain.length == 0) {
            if (!delegate.accept()) {
                throw new CertificateException("No certificate");
            }
        }
        if (!delegate.accept(chain[0])) {
            throw new CertificateException("Certificate not accepted");            
        }
    }
}
}}}
where we consider only key certificates, and disregard their chain. (See the prequel article <a href="https://code.google.com/p/vellum/wiki/LocalCa">Local CA</a>.)

Since we use this trust manager on the server to validate clients, we know its <tt>checkServerTrusted()</tt> method is not needed.
{{{
    @Override
    public void checkServerTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        throw new CertificateException("Server authentication not supported");
    }    
}}}


<h4>Storage trust manager delegate</h4>

We implement a trust manager delegate which uses a dynamic truststore i.e. our SQL table.
{{{
public class StorageTrustManagerDelegate implements TrustManagerDelegate {
    final private boolean requireCertificate;
    final private boolean autoInsert;
    final private CertificateStorage certificateStorage;
    
    public StorageTrustManagerDelegate(
            boolean requireCertificate, 
            boolean autoInsert, 
            CertificateStorage certificateStorage) {
        this.requireCertificate = requireCertificate;
        this.autoInsert = autoInsert;
        this.certificateStorage = certificateStorage;
    }

    @Override
    public boolean accept() throws CertificateException {
        return !requireCertificate;
    }
    ...
}
}}}
where our delegate might accept clients without a certificate. For example, the client might request for a <a href="http://en.wikipedia.org/wiki/PKCS_12">PKCS12</a> bundle to be generated on its client's behalf, and delivered as an HTTP response, i.e. with a content type of <tt>application/x-pkcs12</tt>. Naturally the server must not store the generated key, but does import the client certificate into its truststore. (This functionality will be demonstrated in a subsequent article in this series.)

In this case, perhaps the certificate is initially disabled in the SQL truststore, e.g. pending manual confirmation by an administrator.

If the client sends a certificate, we check it against our SQL truststore as follows.
{{{
    @Override
    public boolean accept(X509Certificate peerCertificate) throws CertificateException {
        try {
            return accept(Certificates.getCommonName(peerCertificate.getSubjectDN()), 
                    peerCertificate);
        } catch (CertificateStorageException e) {
            throw new CertificateException(e);
        }
    }
}}}
where we use the common name of the peer certificate to select the matching trusted certificate in our SQL truststore.
{{{    
    private boolean accept(String commonName, X509Certificate peerCertificate)
            throws CertificateStorageException {
        if (certificateStorage.exists(commonName)) {
            if (certificateStorage.isNullCert(commonName)) {
                certificateStorage.setCert(commonName, peerCertificate);
                return true;
            }
            if (certificateStorage.isEnabled(commonName)) {
                X509Certificate trustedCertificate = certificateStorage.load(commonName);
                if (new Date().after(trustedCertificate.getNotAfter())) {
                    certificateStorage.update(commonName, peerCertificate);
                    return true;
                }
                return Arrays.equals(peerCertificate.getPublicKey().getEncoded(),
                        trustedCertificate.getPublicKey().getEncoded());
            }
        } else if (autoInsert) {
            certificateStorage.insert(commonName, peerCertificate);
            return true;
        }
        return false;
    }
}}}
where we validate the certificate against our truststore, i.e. check that it is <tt>enabled</tt> e.g. it is not pending confirmation, and has not been revoked. If the certificate on record has expired, we auto import the client's renewed certificate. Otherwise we check that the peer certificate's public key matches the trusted certificate we have on record for its common name. 

Finally, we might automatically insert that client's certificate into our SQL truststore if it does not exist. In this case, the newly inserted certificate is initially disabled, pending validation of the client's request message by our application, or alternatively requiring manual approval by an administrator.


<h4>To be continued</h4>

We'll delve into the unit testing of our custom trust manager in a follow-up article.


<h4>Conclusion</h4>

We want the enhanced security of client-authenticated SSL, with the comparable convenience of non-authenticated SSL, achieved by automated certificate enrollment.

<img align="right" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

Usually a new client cannot register itself via a client-authenticated connection, and we would require an additional non-client-authenticated HTTPS server for enrollment. Unfortunately the standard port number is the same for both, i.e. 443, which is widely allowed by firewalls. Consequently two hosts are typically required, i.e. distinguished by their different IP numbers.

We introduce a custom trust manager to enable the initial enrollment, and client-authenticated sessions, through the same server. New clients' certificates are imported into our truststore when they connect for the first time, and thereafter we validate our clients' certificates, to protect against spoofing attacks.

New clients might be pre-approved by an administrator according to their expected certificate names. Alternatively a new client might connect without a certificate in order to send a registration request for the server to generate a PKCS12 key and certificate bundle on its behalf.


<h4>Furthermore</h4>

In a follow-up article, we'll demonstrate a HTTPS server which can generate a PKCS12 key and certificate bundle for clients, in response to a valid registration request.


<h4>Resources</h4>

You can browse the code for this exercise on <a href="https://code.google.com/p/vellum">code.google.com/vellum</a>.


<h4>Other reading</h4>

Also relating to Java crypto in this blog: <a href="https://weblogs.java.net/blog/evanx/archive/2013/01/24/password-salt">Password Salt</a> for secure passwords; and leveraging the <a href="https://weblogs.java.net/blog/evanx/archive/2012/11/07/google-authenticator-thus-enabled">Google Authenticator</a> mobile app for multi-factor authentication for your own sites.

