#labels Java, SSL, TrustManager

<h4>Problem overview</h4>

Client-authenticated SSL connections require client certificate generation, enrollment, and renewal. Enrollment typically requires a manual process, either certificate signing, or importing into our truststore. Moreover certificate expiry requires this process to be repeated regularly. 

Consequently browser certificates are not widely used for consumer sites i.e. for client-authenticated HTTPS. Typically cookies are used to record authenticated sessions. Unfortunately such cookies are hijacked using <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting</a> attacks, to thereby <a href="http://en.wikipedia.org/wiki/Spoofing_attack">spoof</a> authenticated client sessions.

<img align="left" style="margin-left: 4px" src="http://jroller.com/evanx/resource/wooden-shield200.png" />

<h4>Solution overview</h4>

We consider automatic enrollment using a custom trust manager that recognises new clients, and automatically imports their certificate into our truststore. Otherwise the trust manager authenticates existing clients to protect against spoofing attacks.

A new client might be pre-approved by an administrator according to its expected certificate name, where we automatically import its certificate the first time it connects. The risk is that a rogue client connects before the legitimate client. However, this requires knowledge of currently pending client names. Nevertheless, our application might mitigate this risk, e.g. where the new client's access is restricted until it is somehow confirmed.

Alternatively a new client might connect without a certificate, in order to send a registration request for the server to generate a PKCS12 key and certificate bundle on its behalf. For example, our HTTPS server might send this as its response i.e. with a content type of <tt>application/x-pkcs12</tt> to be imported by the client's browser.

 
<h4>SQL truststore</h4>

Our dynamic truststore might be an SQL database table with columns for the client certificate name, the certificate itself, and its status.
{{{
CREATE TABLE client_cert (
  cert_name VARCHAR(255) PRIMARY KEY,
  cert VARCHAR(4096), 
  enabled BOOL DEFAULT TRUE
);
}}}
where the certificate name is unique. Incidently, the certificate itself would be Base64-encoded for SQL storage.

We might import certificates for new clients where these are disabled until validated by our application, or pending approval by an administrator. However, this would enable a denial of service attack whereby our server is flooded with new clients. We could counter this limiting the number of new clients that are recorded from the same source IP number, limiting the rate in general, and having a cutoff where we disable any new clients for some period.

Alternatively we might pre-approve a new client by inserting a record with its expected certificate name, but with a <tt>null</tt> entry for the actual certificate. The certificate is set when the client connects for the first time. 

Incidently, clearly we can "revoke" a client certificate by setting its <tt>enabled</tt> column to <tt>false</tt>. However in this case the certificate name cannot be reused, because of our uniqueness constraint.

<h4><tt>SSLSession</tt></h4>

When we accept a connection to our <tt>SSLServerSocket</tt>, naturally our application validates the request message, and might import the peer certificate for new clients. We can get the client certificate via the <tt>SSLSession</tt> of the client <tt>SSLSocket</tt>, as demonstrated in the following test code.
{{{
    static void accept(KeyStore keyStore, char[] keyPassword, KeyStore trustStore,
            int port) throws GeneralSecurityException, IOException {
        SSLContext sslContext = SSLContexts.create(keyStore, keyPassword, trustStore);
        SSLServerSocket serverSocket = (SSLServerSocket) sslContext.
                getServerSocketFactory().createServerSocket(port);
        try {
            serverSocket.setNeedClientAuth(true);
            SSLSocket clientSocket = (SSLSocket) serverSocket.accept();
            javax.security.cert.X509Certificate peer = 
                    clientSocket.getSession().getPeerCertificateChain()[0];
            logger.info("peer: " + peer.getSubjectDN().getName());
            ServerThread.handle(clientSocket);
        } finally {
            serverSocket.close();
        }
    }
}}}

In this case, our trust manager should allow connections by new clients whose certificates are not yet in our truststore, since our application will decide whether to import the new certificate into our SQL truststore, e.g. if the message is a valid registration request.


<h4>Trust manager</h4>

Alternatively our trust manager itself might import new certificates. 

Firstly let's implement a trivial trust manager to accept certificates using a delegate.
{{{
public class DelegatingClientTrustManager implements X509TrustManager {
    TrustManagerDelegate delegate;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        if (chain.length == 0) {
            if (!delegate.accept()) {
                throw new CertificateException("No certificate");
            }
        }
        if (!delegate.accept(chain[0])) {
            throw new CertificateException("Certificate not accepted");            
        }
    }
}}}
where we consider only key certificates, and disregard their chain. (See the prequel article <a href="https://code.google.com/p/vellum/wiki/LocalCa">Local CA</a>.)

We implement a trust manager delegate which uses a dynamic certificate truststore.
{{{
public class StorageTrustManagerDelegate implements TrustManagerDelegate {
    final private boolean requireCertificate;
    final private boolean autoInsert;
    final private CertificateStorage certificateStorage;
    
    public StorageTrustManagerDelegate(
            boolean requireCertificate, 
            boolean autoInsert, 
            CertificateStorage certificateStorage) {
        this.requireCertificate = requireCertificate;
        this.autoInsert = autoInsert;
        this.certificateStorage = certificateStorage;
    }

    @Override
    public boolean accept() throws CertificateException {
        return !requireCertificate;
    }
    ...
}
}}}
where our delegate might accept clients without a certificate, e.g. to enable a registration request for a <a href="http://en.wikipedia.org/wiki/PKCS_12">PKCS12</a> bundle to be generated on the client's behalf, and delivered as the response.

In this case the server might sign the certificate, or import it into its truststore. Perhaps the certificate is initially disabled in the truststore database, pending validation of message by our application, or manual approval by the appropriate administrator.

However if the client sends a certificate, we check it using our SQL truststore as follows.
{{{
    @Override
    public boolean accept(X509Certificate peerCertificate) throws CertificateException {
        String commonName = Certificates.getCommonName(peerCertificate.getSubjectDN());
        try {
            if (certificateStorage.exists(commonName)) {
                if (certificateStorage.isNull(commonName)) {
                    certificateStorage.set(commonName, peerCertificate);
                    return true;
                } else {
                    X509Certificate trustedCertificate = certificateStorage.load(commonName);
                    if (certificateStorage.isEnabled(commonName)) {                        
                        if (new Date().after(trustedCertificate.getNotAfter())) {
                            certificateStorage.update(commonName, peerCertificate);
                            return true;
                        } else {
                            return Arrays.equals(peerCertificate.getPublicKey().getEncoded(),
                                    trustedCertificate.getPublicKey().getEncoded());
                        }
                    } else {
                        return false;
                    }
                }
            } else if (autoInsert) {
                certificateStorage.insert(commonName, peerCertificate);
                return true;
            } else {
                return false;                
            }
        } catch (CertificateStorageException e) {
            throw new CertificateException(e);
        }
    }
}}}
where we validate the certificate against our truststore, i.e. check that it is <tt>enabled</tt> e.g. it is not pending confirmation, and has not been revoked. If the certificate on record has expired, we auto import the client's renewed certificate. Otherwise we check that the peer certificate's public key matches the trusted certificate we have on record for its common name. 


<h4>Certificate storage</h4>

We provide a mockable certificate storage implementation to our trust manager delegate.
{{{
public interface CertificateStorage {
    public void insert(String commonName, X509Certificate cert) throws CertificateStorageException;
    public boolean exists(String commonName) throws CertificateStorageException;
    public boolean isNull(String commonName) throws CertificateStorageException;
    public void set(String commonName, X509Certificate cert) throws CertificateStorageException;
    public boolean isEnabled(String commonName) throws CertificateStorageException;
    public X509Certificate load(String commonName) throws CertificateStorageException;    
    public void update(String commonName, X509Certificate cert) throws CertificateStorageException;
}
}}}
where if the record for that common name exists but has a <tt>null</tt> certificate, then <tt>isNull()</tt> returns <tt>true</tt>, and we can <tt>set()</tt> the certificate. If the certificate <tt>exists()</tt>, then we can <tt>load()</tt> it, and <tt>update()</tt> it i.e. if it has expired.


<h4>Conclusion</h4>

We want the enhanced security of client-authenticated SSL, with the comparable convenience of non-authenticated SSL, achieved by automated certificate enrollment.

Usually a new client cannot register itself via a client-authenticated connection, and we would require an additional non-client-authenticated HTTPS server for enrollment. Unfortunately the standard port number is the same for both, i.e. 443, which is widely allowed by firewalls. Consequently two hosts are typically required, i.e. distinguished by their different IP numbers.

We introduce a custom trust manager to enable the initial enrollment, and client-authenticated sessions, through the same server. New clients' certificates are imported into our truststore when they connect for the first time, and thereafter we validate our clients' certificates, to protect against spoofing attacks.

<img align="right" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

New clients might be pre-approved by an administrator according to their expected certificate names. Alternatively a new client might connect without a certificate in order to send a registration request for the server to generate a PKCS12 key and certificate bundle on its behalf.


<h4>Furthermore</h4>

We'll delve into the unit testing of our custom trust manager in a follow-up article.

In a further article, we'll demonstrate a HTTPS server which can generate a PKCS12 key and certificate bundle for clients, in response to a valid registration request.


<h4>Resources</h4>

You can browse the code for this exercise on <a href="https://code.google.com/p/vellum">code.google.com/vellum</a>.

<h4>Other reading</h4>

Also relating to Java crypto in this blog: <a href="https://weblogs.java.net/blog/evanx/archive/2013/01/24/password-salt">Password Salt</a> for secure passwords; and leveraging the <a href="https://weblogs.java.net/blog/evanx/archive/2012/11/07/google-authenticator-thus-enabled">Google Authenticator</a> mobile app for multi-factor authentication for your own sites.

