
<!--
The first part in a series entitled "Timestamped: a trilogy in a few parts." For starters, we introduce a "counter map" and ensure we can sort it by its integer values.
-->


I plan to blog about monitoring and what-not, and to begin this saga, I'll start with this series "Timestamped: a trilogy in a few parts,"  this being the first part,  where we introduce a "counter map" for key things and ensure we can sort it by its integer values.

<a style='text-decoration: none;' href="https://code.google.com/p/vellum/wiki/home">
<div style="border-bottom: solid 1px; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/1/12/Gnome-appointment-new.svg" border="0" align="left" hspace="0"/><span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Counter map:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A part of "Timestamped: a trilogy in a few parts."</span>
</div>
</a>

We will be analysing logs in this unwinding series. Ultimately we gonna hook up a remote Log4j appender to digest our logs to gather stats, and make some judgement calls as to the rapidly changing status of our app.  

As you can imagine we will need to count so many <i>key</i> things like the number of successes and failures of one thing or another. For this purpose, we introduce the following so-called "counter map."

<code>
public class IntegerCounterMap<K> extends TreeMap<K, Integer> {
    private int totalCount = 0;

    public int getInt(K key, int defaultValue) {
        if (!containsKey(key)) {
            return defaultValue;
        } else {
            return get(key);
        }
    }

    public int getInt(K key) {
        return getInt(key, 0);
    }
    
    public void increment(K key) {
        totalCount++;
        put(key, new Integer(getInt(key) + 1));
    }

    public int getTotalCount() {
        return totalCount;
    }

    public int calculateTotalCount() {
        int total = 0;
        for (K key : keySet()) {
            total += getInt(key);
        }
        return total;
    }
    
    public Iterable<K> descendingValueKeySet() {
        return Maps.descendingValueKeySet(this);
    }    
}
</code> 

For sure we are going to count some of these key things, so we add <tt>increment()</tt> method to use when digesting log messages.

<code>
    @Test
    public void testCounterMap() {
        IntegerCounterMap<String> counterMap = new IntegerCounterMap();
        counterMap.increment("ERROR");
        Assert.assertEquals(counterMap.getTotalCount(), counterMap.calculateTotalCount());
        ...
    }
</code>

Also we provide a <tt>descendingValueKeySet()</tt> method for when we wanna display counters is descending order, to see the biggest numbers. This is delegates to the following util class. 

<code>
public class Maps {  

    public static <K, V> Iterable<K> descendingValueKeySet(Map<K, V> map) {
        return keySet(descendingValueEntrySet(map));
    }
    
    private static <K, V> NavigableSet<Entry<K, V>> descendingValueEntrySet(Map<K, V> map) {
        TreeSet set = new TreeSet(new Comparator<Entry>() {

            @Override
            public int compare(Entry o1, Entry o2) {
                return ((Comparable) o2.getValue()).compareTo(o1.getValue());
            }
        });
        set.addAll(map.entrySet());
        return set;
    }

    private static <K, V> Iterable<K> keySet(NavigableSet<Entry<K, V>> entrySet) {
        List<K> keyList = new ArrayList();
        for (Map.Entry entry : entrySet) {
            keyList.add((K) entry.getKey());
        }
        return keyList;
    }
}
</code>

where we sort the map's entries by value, and put the keys into a <tt>List</tt> to iterate over e.g. in a <tt>for</tt> loop.

See also http://stackoverflow.com/questions/109383/how-to-sort-a-mapkey-value-on-the-values-in-java. 

Let's test this ordering. 

<code>
    @Test
    public void testDescendingCounterMap() {
        IntegerCounterMap<String> counterMap = new IntegerCounterMap();
        counterMap.put("WARNING", 0);
        counterMap.put("DEBUG", 1000000);
        counterMap.put("ERROR", 1000);
        counterMap.increment("ERROR");
        counterMap.increment("INFO");
        for (String key : counterMap.descendingValueKeySet()) {
            System.out.printf("%d %s\n", counterMap.get(key), key);
        }
        Assert.assertEquals(counterMap.descendingValueKeySet().iterator().next(), "DEBUG");
        String lastKey = null;
        int keyCount = 0;
        for (String key : counterMap.descendingValueKeySet()) {
            lastKey = key;
            keyCount++;
        }
        Assert.assertEquals(lastKey, "WARNING");
        Assert.assertEquals(keyCount, 4);
    }
</code>

After some debugging (with the help of a lot logging), we eventually get what we were expecting. 
<i>"Put that in your internet, put that in your twitter right there."</i>

<pre>
1000000 DEBUG
1001 ERROR
1 INFO
0 WARNING
</pre>

As so often seems to be case, we have a million DEBUG messages, a thousand and one ERRORs 
with absolutely no bloody warning and very little INFO to go on.

<h2>Coming soon</h2>

In part two, we'll properly  introduce the namesake of this series, a so-called <tt>Timestamped</tt> interface, not to mention <tt>TimestampedList</tt>, <tt>TimestampedSample</tt> and what-not.

<pre>
public interface Timestamped {
    public long getTimestampMillis();    
}
</pre>
 