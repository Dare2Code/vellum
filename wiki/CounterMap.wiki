
== Timestamped, the trilogy == 

We herewith begin a saga about monitoring with this series entitled "Timestamped: a trilogy in a few parts," this being the first part, where we introduce a map to count key things, and ensure we can sort it by its integer values.

We will be analysing logs in this unwinding series. Ultimately we gonna hook up a remote Log4j appender to digest our logs to gather stats, and make some judgement calls as to the rapidly changing status of our app.  

=== Counter Map ===

As you can imagine we will need to count so many <i>key</i> things like the number of successes and failures of one thing or another. For this purpose, we introduce the following so-called "counter map."

{{{
public class IntegerCounterMap<K> extends TreeMap<K, Integer> {
    private int totalCount = 0;

    public int getInt(K key, int defaultValue) {
        if (!containsKey(key)) {
            return defaultValue;
        } else {
            return get(key);
        }
    }

    public int getInt(K key) {
        return getInt(key, 0);
    }
    
    public void increment(K key) {
        totalCount++;
        put(key, new Integer(getInt(key) + 1));
    }

    public int getTotalCount() {
        return totalCount;
    }

    public int calculateTotalCount() {
        int total = 0;
        for (K key : keySet()) {
            total += getInt(key);
        }
        return total;
    }
    
    public Iterable<K> descendingValueKeySet() {
        return Maps.descendingValueKeySet(this);
    }    
}
}}}

For sure we are going to count some of these key things, so we add <tt>increment()</tt> method to use when digesting log messages.

{{{
    @Test
    public void testCounterMap() {
        IntegerCounterMap<String> counterMap = new IntegerCounterMap();
        counterMap.increment("INFO");
        counterMap.increment("ERROR");
        counterMap.increment("ERROR");
        Assert.assertEquals(counterMap.getInt("WARN"), 0);
        Assert.assertEquals(counterMap.getInt("INFO"), 1);
        Assert.assertEquals(counterMap.getInt("ERROR"), 2);
        Assert.assertEquals(counterMap.size(), 2);
        Assert.assertEquals(counterMap.getTotalCount(), 3);
        Assert.assertEquals(counterMap.getTotalCount(), counterMap.calculateTotalCount());
   }
}}}

where since WARN is not incremented like the others, it's not put into the map, and so the <tt>size</tt> of map is only the two keys, namely INFO and ERROR.

We provided a <tt>descendingValueKeySet()</tt> method for when we wanna display counters is descending order, to see the biggest numbers. This is delegates to the following util class. 

{{{
public class Maps {  

    public static <K, V> Iterable<K> descendingValueKeySet(Map<K, V> map) {
        return keySet(descendingValueEntrySet(map));
    }
    
    private static <K, V> NavigableSet<Entry<K, V>> descendingValueEntrySet(Map<K, V> map) {
        TreeSet set = new TreeSet(new Comparator<Entry>() {

            @Override
            public int compare(Entry o1, Entry o2) {
                return ((Comparable) o2.getValue()).compareTo(o1.getValue());
            }
        });
        set.addAll(map.entrySet());
        return set;
    }

    private static <K, V> Iterable<K> keySet(NavigableSet<Entry<K, V>> entrySet) {
        List<K> keyList = new ArrayList();
        for (Map.Entry entry : entrySet) {
            keyList.add((K) entry.getKey());
        }
        return keyList;
    }
}
}}}

where courtesy of a <tt>TreeMap</tt>, we sort the map's entries by value, and put the thus ordered keys into a <tt>List</tt> to iterate over e.g. in a <tt>for</tt> each loop.

See also [http://stackoverflow.com/questions/109383/how-to-sort-a-mapkey-value-on-the-values-in-java stackoverflow.com]. 

Let's test this ordering. 

{{{
    @Test
    public void testDescendingCounterMap() {
        IntegerCounterMap<String> counterMap = new IntegerCounterMap();
        counterMap.put("BWARN", 0);
        counterMap.put("DEBUG", 1000000);
        counterMap.put("ERROR", 1000);
        counterMap.increment("ERROR");
        counterMap.increment("INFO");
        for (String key : counterMap.descendingValueKeySet()) {
            System.out.printf("%d %s\n", counterMap.get(key), key);
        }
        Assert.assertEquals(counterMap.descendingValueKeySet().iterator().next(), "DEBUG");
        String lastKey = null;
        int keyCount = 0;
        for (String key : counterMap.descendingValueKeySet()) {
            lastKey = key;
            keyCount++;
        }
        Assert.assertEquals(lastKey, "BWARN");
        Assert.assertEquals(keyCount, 4);
    }
}}}

where we use "BWARN" instead of "WARN" to be sure we aren't picking up the natural ordering. (Yes that was happening and hiding a bug quite effectively.)

After some DEBUG'ing (with the help of a lot logging), we eventually get what we were expecting. <i>"Put that in your internet, put that in your twitter right there."</i>

{{{
1000000 DEBUG
1001 ERROR
1 INFO
0 BWARN
}}}

As so often seems to be case, we have a million DEBUG messages, a thousand and one ERRORs with very little INFO to go on, and no bloody warnings.

==== Coming soon ==== 

In part two, we'll properly  introduce the namesake of this series, a so-called <tt>Timestamped</tt> interface, for our "time series" or what-have-you.

{{{
public interface Timestamped {
    public long getTimestampMillis();    
}
}}}
