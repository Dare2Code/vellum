#labels Dual Control, Split Knowledge, Key Management, Encryption, PAN, PCI

= Dual Control Key Management =

== Introduction ==

Encryption is great for information security and all that. But the problem with encryption is... key management. An analogy often bandied about is that we lock our doors but leave the key in the lock. <i>Or under the mat, but that's my personal favourite so ssh-ssh.</i>

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

The Payment Card industry (PCI) has their "Data Security Standard" called "PCI DSS," which outlines best practices, that actually every industry should follow because it's the only and best thing we got :)

The PCI DSS mandates that PAN's aka <i>Primary Account Numbers</i> aka credit card numbers, must be "rendered unreadable" e.g. encrypted. It goes without saying that other industries also have sensitive data that people might want to steal, governments even ;)

PCI DSS suggests encrypting the key used to encrypt our data. Darn, we try to secure the data-encrypting-key (DEK), but now we're lumbered with another key, namely a "key-encrypting-key" (KEK).

PCI requires that "dual control" and "split knowledge" be used to protect PAN's, i.e. the key used to cipher this data. The intent is that no single person can steal the data. 

The glaring problem is that sysadmins are a single person, with God-like access to all our data, and custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>

Naturally, `keytool` is tailored for a single omnipotent admin, not for "dual control" by two half-cocked ones. So we present a `DualControlGenSecKey` utility for generating secret keys that are really secret, i.e. they are not "accessible" to anyone, not even <i>root</i> ;)

But then our application can't access those keys either. <i>D'oh!</i> Actually, we must support dual-control of our application in order to load these keys, which it uses to protect our crown jewels. <i>Woohoo!</i> But then starting our application requires two coordinated people. <i>D'oh!</i> So we'll present a companion crypto server in a follow-up article.

== `DualControlGenSecKey` ==

Step 1 for any data security endeavour is to generate an encryption key, which ideally no single rogue root user can access. For this purpose, there shall be `DualControlGenSecKey`, as follows.

{{{
public class DualControlGenSecKey { 
    int submissionCount = Integer.getInteger("dualcontrol.submissions", 3);
    String keyAlias = System.getProperty("alias"); 
    String keyStorePath = System.getProperty("keystore"); 
    String keyStoreType = System.getProperty("storetype");
    String keyAlg = System.getProperty("keyalg");
    int keySize = Integer.getInteger("keysize");
    
    public static void main(String[] args) throws Exception {        
        new DualControlGenSecKey().start(args);
    }

    void start() throws Exception {
        dualMap = new DualControlReader().readDualMap(keyAlias, submissionCount);
        keyStorePassword = getKeyStorePassword();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(keyAlg);
        keyGenerator.init(keySize);
        secretKey = keyGenerator.generateKey();
        keyStore = loadKeyStore(keyStorePath, keyStorePassword);
        KeyStore.Entry entry = new KeyStore.SecretKeyEntry(secretKey);
        for (String dualAlias : dualMap.keySet()) {
            char[] dualPassword = dualMap.get(dualAlias);
            String alias = keyAlias + "-" + dualAlias;
            KeyStore.ProtectionParameter prot = 
                    new KeyStore.PasswordProtection(dualPassword);
            keyStore.setEntry(alias, entry, prot);
        }
        keyStore.store(new FileOutputStream(keyStorePath), keyStorePassword);
    }
    ...
}
}}}
where `DualControlReader` provides a map of "dual key" aliases and their secret passwords, and we create a entry for each. 

=== Demo ===

Let's test `DualControlGenSecKey`.

{{{
  java -Ddualcontrol.submissions=3 \
     -Dkeystore=$keystore -Dstoretype=JCEKS -Dstorepass=$storepass \
     -Dalias=dek2013 -Dkeyalg=AES -Dkeysize=256 \
     dualcontrol.DualControlGenSecKey
}}}

where we use a `JCEKS`-type keystore for our symmetric secret key, which is specified as 256bit AES, and "dek2013" is our desired alias to reference this key.  

When three admins have submitted their passwords via SSL TCP/IP socket e.g. where their client cert's `CN` identifies them as `evanx`, `henty` and `brand`, we see that `DualControlGenSecKey` saves the secret key under the following "dual-aliases."

{{{
dek2013-brand-evanx
dek2013-brand-henty
dek2013-evanx-henty
}}}

We check that the keys are created in the <tt>KeyStore</tt>.

{{{
$ keytool -keystore $keystore -storetype JCEKS -storepass $storepass -list | grep Entry
dek2013-brand-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-brand-evanx, 18 Aug 2013, SecretKeyEntry,
}}}

Actually these three keys are one and the same. However each copy is password-protected using a different "dual-password" combination, known to no single person.

== `DualControlConsole` == 

In order for admins to submit their secrets e.g. from a ssh session on the `localhost`, we provide a minimal SSL client as follows.

{{{
public class DualControlConsole {
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                createSocket(HOST, PORT);
        DataInputStream dis = new DataInputStream(socket.getInputStream());
        String prompt = dis.readUTF();
        char[] passwd = System.console().readPassword(prompt);
        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
        dos.writeUTF(new String(passwd));
        socket.close();
    }    
}
}}}
where we submit our password via SSL socket to our supposed dual-controlled app listening on port 4444 on the `localhost`, and are identified by our SSL client cert.

<img align="right" src="http://jroller.com/evanx/resource/Gnome-preferences-desktop-personal-250-crop.png"/>

A known "bug" is that more Godly sysadmins can socially-engineer other less Godly admins to submit their passwords whilst a malicious socket server has been implanted by the most Godly one onto that frikking port! Other naughty tricks that come to mind is the creation of phantom admins, or the impersonation of other admins e.g. during a key generation procedure. 

A follow-up article might propose some measures to improve admins' level of confidence that they are not having the wool pulled over their eyes.

The workaround for above "bugs" in plain management-speak, is that our "controls" as documented in in our "policies and procedures," prevent or at least detect such attacks and have words.

== `DualControlKeyStores` ==

Similarly to the standard `-Dnet.javax.ssl.*` command-line options that can be used to specify the default "keyStore" and "trustStore" for SSL sockets, we use `-Ddualcontrol.ssl.keyStore` et al, as below. 

Note that the "keyStore" parameter is our "private keystore" which contains the <i>private</i> key and its certificate, used for SSL e.g. for DSA assymmetric encryption. This should not be confused with our "secret key store" e.g. which contains a AES <i>secret</i> key for symmetric encryption of our secret data. 
 
{{{
public class DualControlKeyStores {    
    static String keyStorePath = System.getProperty("dualcontrol.ssl.keyStore");
    static char[] keyStorePassword = getPassword("dualcontrol.ssl.keyStorePassword");
    static char[] keyPassword = getPassword("dualcontrol.ssl.keyPassword");
    static String trustStorePath = System.getProperty("dualcontrol.ssl.trustStore");
    static char[] trustStorePassword = getPassword("dualcontrol.ssl.trustStorePassword");    
    
    public static char[] getPassword(String propertyName) {
        return System.getProperty(propertyName).toCharArray();
    }
    
    public static SSLContext createSSLContext() throws Exception {
        return createSSLContext(keyStorePath, keyStorePassword, keyPassword,
                trustStorePath, trustStorePassword);
    }
    ...
}
}}}

where we create an `SSLContext` using these settings.

== `DualControlReader` ==

Our `DualControlReader` utility class handles reading split knowledge submissions.

{{{
public class DualControlReader {
    ...
    public Map<String, char[]> readDualMap(String prompt, int submissionCount) throws Exception {
        this.prompt = prompt;
        this.submissionCount = submissionCount;
        Map<String, char[]> map = new TreeMap();
        Map<String, char[]> submissions = readMap();
        for (String name : submissions.keySet()) {
            for (String otherName : submissions.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    String dualAlias = String.format("%s-%s", name, otherName);
                    char[] dualPassword = combineDualPassword(
                            submissions.get(name), submissions.get(otherName));
                    map.put(dualAlias, dualPassword);
                }
            }
        }
        return map;
    }
}}}

If we have three admins e.g. `evanx`, `henty` and `brand`, then naturally we have three combinations of pairs of admins, namely `brand-evanx`, `brand-henty` and `evanx-henty`. The <tt>compareTo()</tt> in the nested loop ensures we exclude the likes of `evanx-evanx` and `evanx-brand`, since we already have `brand-evanx`, and `evanx-evanx` is just silly.

We invoke `readMap()` to read split knowledge submissions from multiple admins.

{{{
    private final static int PORT = 4444;
    private final static String LOCAL_ADDRESS = "127.0.0.1";
    private final static String REMOTE_ADDRESS = "127.0.0.1";
    ...
    Map<String, char[]> readMap() throws Exception {
        logger.info("Waiting for submissions on SSL port " + PORT);
        Map<String, char[]> map = new TreeMap();
        SSLServerSocket serverSocket = 
                (SSLServerSocket) DualControlKeyStores.createSSLContext().
                getServerSocketFactory().createServerSocket(PORT, submissionCount, 
                InetAddress.getByName(LOCAL_ADDRESS));
        serverSocket.setNeedClientAuth(true);
        for (int i = 0; i < submissionCount; i++) {
            SSLSocket socket = (SSLSocket) serverSocket.accept();
            if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                throw new RuntimeException("Remote host address excluded");
            }
            String username = new X500Name(socket.getSession().getPeerPrincipal().
                    getName()).getCommonName();
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF(prompt);
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            char[] chars = dis.readUTF().toCharArray();
            map.put(username, chars);
            socket.close();
        }
        serverSocket.close();
        return map;
    }
}}}

where we listen on a SSL port i.e. an `SSLServerSocket` which we have hard-wired this to `localhost` i.e. via the loopback interface, where `DualControlConsole` is invariably invoked in a local `ssh` sessions.

Note that the admin's username is determined from their SSL cert, namely the `CN` field, where we get the `peer` certificate from the `SSLSession`.

Incidently, a known bug in the above code, and similarly in `DualControlConsole`, is that we sometimes create strings containing passwords. These will be cleared by the garbage collector at some stage, whereas a better practice is to exclusively use arrays, and clear these soonest.

== `DualControlSessions` == 

We re-engineer our application to similarly get a dual-password, in order to load the key.

{{{
public class DualControlDemoApp {
    private SecretKey dek;     
    ...
    private void loadKey(String keyStorePath, char[] storePass, String alias) 
            throws Exception {
        dek = DualControlSessions.loadKey(keyStorePath, storePass, alias);
    }
}
}}}

where the application loads keys as if it's too easy, but the caveat is that execution is blocked whilst we are waiting for two admins to submit their passwords using `DualControlConsole`.

{{{
public class DualControlSessions {

    public static SecretKey loadKey(String keyStorePath, char[] storePass, String alias) 
            throws Exception {
        char[] dualPass = null;
        try {
            KeyStore dualKeyStore = DualControlKeyStores.loadKeyStore(keyStorePath, storePass);
            Map.Entry<String, char[]> entry = DualControlReader.readDualEntry(alias);
            String dualAlias = entry.getKey();
            dualPass = entry.getValue();
            return (SecretKey) dualKeyStore.getKey(alias + "-" + dualAlias, dualPass);
        } finally {
            if (dualPass != null) {
                Arrays.fill(dualPass, (char) 0);            
            }
        }        
    }
}
}}}

where we read the dual info using the afore-mentioned `DualControlReader,` which creates an `SSLServerSocket` on a well-known port e.g. 4444.

== Cryto server == 

One might wish to create a central crypto server which is dualled-controlled, rather than burden your app. In that case, you can restart your application without dual-control, and indeed have any number of apps using this server. Furthermore it simplifies key management. 

We'll implement the crypto server in part 2. <i>Then we can say, "Dual control? We have an app for that." ;)</i>

== Conclusion ==

The problem with encryption is secure key management. <i>Aint got no time for that</i>.

We probably shouldn't leave the key under the mat, where tresspassers and rogues can just pick it up and thereby steal our sensitive data. 

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

PCI requires that "dual control" and "split knowledge" be used to protect our sensitive data so that no single person can extract it, not even your most trustworthy employee today, rogue tomorrow.

However your run-of-the-mill `keytool` is tailored for a single admin rather than dual-control. 

If we have three admins e.g. A, B and C, then naturally we have three combinations of pairs of admins, namely A-B, B-C and A-C. 

In order to generate a dual-controlled key, we propose keeping three copies of the same key, but where each copy is password-protected with a different "dual-password" to be provided by a given pair of admins. 

We introduce `DualControlGenSecKey` to generate a secret key in a JCEKS key store. This collates passwords from multiple admins using `DualControlReader`, which combines those into paired "dual passwords" known to no single person. 

To complete the picture, we provide a trivial `DualControlConsole` utility for admins to submit their password from their `ssh` console via a client-authenticated SSL socket.

Finally, we demonstrate how our app can be dual-controlled to load a key from the store at startup, for ciphering our sensitive data for the duration of its natural life.

In a follow-up article, we'll implement a dual-controlled crypto server, to unburden our apps, improve convenience, but more importantly, to isolate our keys on the crypto server, to simplify key management, to enhance security. 

== See also ==

You can browse the code for this exercise at <a href="http://code.google.com/p/vellum">code.google.com/vellum</a> in the <a href="https://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fdualcontrol"> <tt>dualcontrol</tt></a> package.