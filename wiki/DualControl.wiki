
= Dual Control =

Revision 0.1, 2013-08-18

Keywords: Dual Control, Split Knowledge, Key Management, Encryption, PAN, PCI

== Introduction ==

Encryption is great for information security and all that. But the problem with encryption is... secure key management. An analogy often bandied about is that we lock our doors but leave the key in the lock. <i>Or in the pot plant under a stone, but that's my personal favourite so ssh-ssh.</i>

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

So the Payment Card industry (PCI) has their "Data Storage Standard" called "PCI DSS," which has general best practices that every industry should follow, actually. It's the only and best thing we got :)

The PCI DSS mandates that "PAN's" aka credit card numbers, must be "rendered unreadable" e.g. encrypted. But it goes without saying that other industries store their own sensitive data; governments too ;)

The PCI DSS standard suggests encrypting the key used to encrypt our data. Darn, we secure the data-encrypting-key (DEK), but now we're lumbered with another key, i.e. a "key-encrypting-key" (KEK). <i>Woohoo, the keys to the kindgom!</i>

PCI requires that "dual control" and "split knowledge" be used to protect the PAN, i.e. our most secret data, i.e. the key used to cipher this data. The intent is that no single person can decrypt the data. The disconnect problem here is that sysadmins are a single person, with God-like access to secret data, and custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>

Naturally, `keytool` is tailored for a single omnipotent admin, not for "dual control" by two half-cocked ones. So we present a `keytool` invoker for generating keys that are not "accessible" to anyone, not even "root" ;)

But then our application can't access them either. <i>D'oh!</i> Actually, we can use the same tricks for dual-control of our application to load any keys it requires. <i>Woohoo!</i> But then starting our application requires two coordinated people. <i>D'oh!</i> So we'll present a companion crypto server with the dual-control, in a follow-up article.

== `DualControlKeyTool` ==

Step 1 for any data security procedure is to generate an encryption key, which ideally no single rogue root user can access. For this purpose, there shall be `DualControlKeyTool`, as follows.

{{{
public class DualControlKeyTool { 
    String aliasPrefix = System.getProperty("dualcontrol.alias");
    int submissionCount = Integer.getInteger("dualcontrol.submissions", 3);
    String[] args; 
    
    public static void main(String[] args) throws Exception {        
        new DualControlKeyTool().start(args);
    }
    
    void start(String[] args) throws Exception {
        this.args = args;
        Map<String, char[]> dualMap = new DualControlReader().readDualMap(submissionCount);
        for (String alias : dualMap.keySet()) {
            keyTool(String.format("%s-%s", aliasPrefix, alias), dualMap.get(alias));
        }
    }
    ...
}}}

where `DualControlReader` provides a map of multiple key aliases and their secret passwords, and we invoke Java's `KeyTool` for each. 

{{{
    public void keyTool(String alias, char[] keypass) throws Exception {
        logger.debug("keyTool alias " + alias);
        List<String> argList = new ArrayList(Arrays.asList(args));
        argList.add("-alias");
        argList.add(alias);
        argList.add("-keypass");
        argList.add(new String(keypass));
        KeyTool.main(argList.toArray(new String[argList.size()]));
    }            
}}}

where we add `alias` and `keypass` arguments, and otherwise pass through the command-line arguments as-is to `KeyTool`

For each combination of two admins, we combine their two usernames into a "dual-alias," and also their secrets into a "dual-password."

=== Demo ===

Let's test `DualControlKeyTool` from the command-line, using `keytool` arguments and what-not. 

{{{
  javaks -Ddualcontrol.alias=powerstate2013 -Ddualcontrol.submissions=3 \
     dualcontrol.DualControlKeyTool \
     -storetype JCEKS -storepass $pass -genseckey -keyalg DESede
}}}

where we use a `JCEKS`-type keystore for a secret key e.g. for triple-DES or AES symmetric encryption, and "powerstate2013" is our desired alias to reference this key.  

"When three admins e.g. claiming to be "evanx," "henty" and "brand," have submitted their passwords via SSL TCP/IP socket, we see that `DualControlKeyTool` invokes `KeyTool` thrice with the following "dual-aliases."

{{{
DEBUG keyTool alias powerstate2013-brand-evanx
DEBUG keyTool alias powerstate2013-brand-henty
DEBUG keyTool alias powerstate2013-evanx-henty
}}}

Low and behalved, these keys do seem to be have been created.

{{{
$ keytool -keystore $secstore -storetype JCEKS -storepass $pass -list | grep Entry
powerstate2013-brand-henty, 18 Aug 2013, SecretKeyEntry, 
powerstate2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
powerstate2013-brand-evanx, 18 Aug 2013, SecretKeyEntry,
}}}

Actually these three keys are one and the same. However for each dual-alias that copy is password-protected using a different "dual-password" combination, known to no one.

== `DualControlClient` == 

In order for admins to submit their secrets to our `DualControlReader` e.g. from a ssh session on the `localhost`, we provide a minimal SSL client as follows.

{{{
public abstract class DualControlClient {
    final static Logger logger = Logger.getLogger(DualControlClient.class);
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        String username = System.console().readLine("DualControl username: ");
        char[] passwd = System.console().readPassword("DualControl password: ");
        write(username + ':'+ new String(passwd));
    }

    public static void write(String data) throws Exception {
        Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                createSocket(HOST, PORT);
        socket.getOutputStream().write(data.getBytes());
        socket.close();
    }
}
}}}
where we format the username and their plain-text password into a string, and send those bytes out the SSL socket to our supposed dual-controlled app listening on port 4444 on the `localhost`. 

<img align="right" src="http://jroller.com/evanx/resource/Gnome-preferences-desktop-personal-250-crop.png"/>

A known bug is that more Godly sysadmins can socially-engineer other less Godly admins to submit their passwords whilst a malicious server has been implanted by the most Godly one onto that frikking port! Another bug is the creation of ghost admins, and yet another is the impersonation of other admins e.g. during a key generation procedure. 

The workaround for said bugs, in plain management-speak, is that our controls should prevent or at least detect such attacks, and we should take measures to mitigate risk, etc.

Disclaimer: a known bug in the above code is that we create <tt>String</tt>'s containing a clear-text password, rather than adamantly sticking to `char` arrays, because arrays can cleared deterministically, without consideration of the garbage collector, whereas strings are immutable and so hang around until garbage-collected.

== `DualControlReader` ==

Our `DualControlReader` utility class handles reading split knowledge submissions.

{{{
public class DualControlReader {
    ...
    public Map<String, char[]> readDualMap(int submissionCount) throws Exception {
        this.submissionCount = submissionCount;
        Map<String, char[]> map = new TreeMap();
        Map<String, char[]> submissions = readMap();
        for (String name : submissions.keySet()) {
            for (String otherName : submissions.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    map.put(String.format("%s-%s", name, otherName),
                            String.format("%s-%s", submissions.get(name), 
                            submissions.get(otherName)).toCharArray());
                }
            }
        }
        return map;
    }
}}}

where we invoke `readMap()` to read split knowledge from multiple admins.

A known bug here is that we create <tt>String</tt>'s containing clear-text passwords, rather than adamantly sticking to `char` arrays.

{{{
    Map<String, char[]> readMap() throws Exception {
        Map<String, char[]> map = new TreeMap();
        for (byte[] bytes : readList()) {
            String string = new String(bytes).trim();
            String[] array = string.split(":");
            map.put(array[0], array[1].toCharArray());
        }
        return map;
    }
}}}

which reads a `List` of submissions from admins as below, and then extracts the username and password from each, and puts them into a `Map`.

{{{
    private final static int PORT = 4444;
    private final static String LOCAL_ADDRESS = "127.0.0.1";
    private final static String REMOTE_ADDRESS = "127.0.0.1";

    List<byte[]> readList() throws Exception {
        ServerSocket serverSocket = DualControlKeyStores.createSSLContext().
                getServerSocketFactory().createServerSocket(PORT, submissionCount, 
                InetAddress.getByName(LOCAL_ADDRESS));
        List<byte[]> list = new ArrayList();
        for (int i = 0; i < submissionCount; i++) {
            Socket socket = serverSocket.accept();
            if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                throw new RuntimeException();
            }
            list.add(readBytes(socket.getInputStream()));
            socket.close();
        }
        serverSocket.close();
        return list;
    }
}}}

where we listen on a SSL port i.e. a `ServerSocket` and collate the multiple submissions into a `List`. Note that we have hard-wired this to `localhost` i.e. via the loopback interface, e.g. `DualControlClient` invoked in local `ssh` sessions.

== `DualControlSessions` == 

We re-engineer our application to similarly get a dual-password, in order to load the key.

{{{
public class AppDemo {
    private SecretKey dek;     
    ...
    private void loadKey(String keyStorePath, char[] storePass, String alias) throws Exception {
        dek = DualControlSessions.loadKey(keyStorePath, storePass, alias);
    }
}
}}}

where the application loads keys as if it's too easy to be right, but the caveat is that execution is blocked whilst we are waiting for two admins to submit info via their `DualControlClient`.

{{{
public class DualControlSessions {

    public static SecretKey loadKey(String keyStorePath, char[] storePass, String alias) 
            throws Exception {
        char[] dualPass = null;
        try {
            KeyStore dualKeyStore = DualControlKeyStores.loadKeyStore(keyStorePath, storePass);
            Map.Entry<String, char[]> entry = DualControlReader.readDualEntry();
            String dualAlias = entry.getKey();
            dualPass = entry.getValue();
            return (SecretKey) dualKeyStore.getKey(alias + "-" + dualAlias, dualPass);
        } finally {
            if (dualPass != null) {
                Arrays.fill(dualPass, (char) 0);            
            }
        }        
    }
}
}}}

where we read the dual info using the afore-mentioned `DualControlReader,` which creates an `SSLServerSocket` on a well-known port, listens for connections and reads their submission e.g. using our `DualControlClient` utility.

== Cryto server == 

One might wish to create a central crypto server which is dualled-controlled, rather than burden your app. In that case, you can restart your application without dual-control, and indeed have any number of apps using this server. Furthermore it simplifies key management. 

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

We'll implement the crypto server in part 2. So we can say, "Dual control? We have an app for that." ;)

== Conclusion ==

The problem with encryption is secure key management. It's like we lock the door but leave the key under the mat.

PCI requires that "dual control" and "split knowledge" be used to protect our sensitive data so that no single person can extract it, not even your most trustworthy employee. 

Naturally, `keytool` is tailored for a single root admin, rather than "dual-control." 

If we have three admins, then naturally we have three combinations of pairs of admins. In order to generate a dual-controlled key, we propose keeping three copies of the same key, but where each copy is password-protected with a "dual-password," i.e. a combination of two passwords.

We introduce a utility to generate keys, by first collating passwords from multiple admins via SSL, then combining those into new "dual-passwords" known to no one, and finally invoking the JRE's `KeyTool` with the appropriate parameters.

We presented sample code to read password submissions from multiple admins via SSL TCP/IP socket, each providing their secret. This is used to invoke the JRE's `KeyTool` e.g. to generate "really secret" keys, and also in our app to load those key. 

== See also ==

You can browse the code for this exercise at [http://code.google.com/p/vellum/source/browse/#svn/trunk/src/vellum/dualcontrol code.google.com].

We'll implement the crypto server in part 2. 
