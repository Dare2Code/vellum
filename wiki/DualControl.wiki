#labels Dual Control, Split Knowledge, Key Management, Encryption, PAN, PCI

<h1>Dual Control Key Management</h1>

We hereby start the new 2013 "Dual Control" quadrilogy, part of the <a href="http://code.google.com/p/vellum">Enigma Posts</a>.

<h4>Problem overview</h4>

Encryption is great for information security and all that. But the problem with encryption is... key management. An analogy often bandied about is that we lock the door but leave the key in the lock. <i>Or under the mat, but that's my personal favourite so ssh-ssh.</i>

The "Payment Card Industry Data Security Standard" (<a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard">PCI DSS</a>) advocates common sense policies for building a secure network and protecting your data. Actually every enterprise should adopt PCI DSS because it's the only and best such thing we got. Although it focusses on credit card numbers (aka <i>Primary Account Numbers</i>, or PANs), it goes without saying that companies in other industries also have sensitive data that people might want to steal, governments even ;)

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

PCI DSS suggests encrypting our data-encryption key (DEK) in order to protect it. Great, we now have a "key-encryption key" (KEK) that requires even more protection ;)

PCI DSS mandates that manual key management requires "split knowledge and dual control" e.g. for key generation and loading. The intent is that no single person can extract the clear-text data. 

The glaring problem is that sysadmins are a single person, with god-like access to all our data, and de facto custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>

<h4>Solution overview</h4>

We'll split the knowledge of the key password between two admins, so it's known to no single person. Clearly dual control by those two admins is then required to load the key.

We propose keeping at least three copies of the same key in our keystore, where each copy is password-protected by a different "split password" pairing. Then if one admin is on vacation or otherwise indisposed, that's OK because we only require two admins to load the key when we restart our app.

<h4><tt>!DualControlGenSecKey</tt></h4>

Step 1 for any data security endeavour is to generate an encryption key, which preferrably not even root can pwn. Whereas <tt>keytool</tt> prompts for a password entered by a single admin, we introduce <tt>!DualControlGenSecKey</tt> to handle multiple password submissions via SSL.

{{{
public class DualControlGenSecKey {
    private int submissionCount;
    private String keyAlias;
    private String keyStoreLocation;
    private String keyStoreType;
    private String keyAlg;
    private int keySize;
    private char[] keyStorePassword;
    private Map<String, char[]> dualPasswordMap;
    private SSLContext sslContext;

    public static void main(String[] args) throws Exception {
        DualControlGenSecKey instance = new DualControlGenSecKey();
        try {
            instance.call(new VellumProperties(System.getProperties()), 
                    new ConsoleAdapter(System.console()));
        } catch (DualControlException e) {
            instance.console.writer().println(e.getMessage());
        } finally {
            instance.clear();
        }
    }
    ...
}
}}}
where our <tt>main()</tt> method passes <tt>System</tt> properties i.e. <tt>-D</tt> options, and the <tt>System</tt> console for entering the SSL keystore password.

{{{
    public void call(VellumProperties properties, MockableConsole console) 
            throws Exception {
        this.console = console;
        submissionCount = properties.getInt("dualcontrol.submissions", 3);
        keyStoreLocation = properties.getString("keystore");
        keyStorePassword = properties.getPassword("storepass", null);
        keyAlias = properties.getString("alias");
        if (keyStorePassword == null) {
            keyStorePassword = console.readPassword(
                    "Enter passphrase for keystore (%s): ", keyStoreLocation);
            if (keyStorePassword == null) {
                throw new Exception("No keystore passphrase from console");
            }
        }
        if (new File(keyStoreLocation).exists()) {
            throw new Exception(
                    "Keystore file already exists: " + keyStoreLocation);
        }
        sslContext = DualControlSSLContextFactory.createSSLContext(properties);
        String purpose = "new key " + keyAlias;
        KeyStore keyStore = createKeyStore(properties, new DualControlReader().
                readDualMap(purpose, submissionCount, sslContext));
        keyStore.store(new FileOutputStream(keyStoreLocation), keyStorePassword);
    }
}}}

where <tt>!DualControlReader</tt> provides a map of aliases and passwords, composed from submissions via SSL.

We create a <tt>!KeyStore</tt> using the following method, which is exposed for unit testing.
{{{      
    public KeyStore createKeyStore(VellumProperties properties,
            Map<String, char[]> dualPasswordMap) throws Exception {
        keyAlias = properties.getString("alias");
        keyStoreType = properties.getString("storetype");
        keyAlg = properties.getString("keyalg");
        keySize = properties.getInt("keysize");
        KeyGenerator keyGenerator = KeyGenerator.getInstance(keyAlg);
        keyGenerator.init(keySize);
        SecretKey secretKey = keyGenerator.generateKey();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);        
        setEntry(keyStore, secretKey, keyAlias, dualPasswordMap);
        return keyStore;
    }

    private static void setEntry(KeyStore keyStore, SecretKey secretKey,
            String keyAlias, Map<String, char[]> dualPasswordMap) throws Exception {
        KeyStore.Entry entry = new KeyStore.SecretKeyEntry(secretKey);
        for (String dualAlias : dualPasswordMap.keySet()) {
            char[] dualPassword = dualPasswordMap.get(dualAlias);
            String alias = keyAlias + "-" + dualAlias;
            KeyStore.ProtectionParameter prot =
                    new KeyStore.PasswordProtection(dualPassword);
            keyStore.setEntry(alias, entry, prot);
        }
    }
}}}

where for each duo we programmatically create a <tt>!KeyStore</tt> entry containing the same key, but protected by a different password, known to no single person.

One might argue that we should not write code per se, but rather we should write tests with accompanying code, hand in glove. 

We subscribed to that, and so let's test.
{{{
    @Test
    public void genKeyTest() throws Exception {
        dualPasswordMap.put("brent-evanx", "bbbb+eeee".toCharArray());
        dualPasswordMap.put("brent-henty", "bbbb+hhhh".toCharArray());
        dualPasswordMap.put("evanx-henty", "eeee+hhhh".toCharArray());
        properties.put("alias", "dek2013");
        properties.put("storetype", "JCEKS");
        properties.put("keyalg", "AES");
        properties.put("keysize", "256");
        DualControlGenSecKey instance = new DualControlGenSecKey();
        KeyStore keyStore = instance.createKeyStore(properties, dualPasswordMap);
        assertEquals(3, Collections.list(keyStore.aliases()).size());
        assertEquals("dek2013-brent-evanx", Lists.asSortedSet(keyStore.aliases()).first());
        SecretKey key = getSecretKey(keyStore, "dek2013-brent-evanx", "bbbb+eeee".toCharArray());
        assertEquals("AES", key.getAlgorithm());
        assertTrue(Arrays.equals(key.getEncoded(), getSecretKey(keyStore, 
                "dek2013-brent-henty", "bbbb+hhhh".toCharArray()).getEncoded()));
    }
}}}

where we inspect the <tt>!KeyStore</tt> returned by the <tt>public</tt> <tt>createKeyStore()</tt> method, which is exposed especially for this unit test.

<h4>Usage demo</h4>

Let's run <tt>!DualControlGenSecKey</tt> from the command-line.

<code language="xml">
  java -Ddualcontrol.submissions=3 -Ddualcontrol.minPasswordLength=8 \
     -Dkeystore=$keystore -Dstoretype=JCEKS -Dstorepass=$storepass \
     -Dalias=dek2013 -Dkeyalg=AES -Dkeysize=256 \
     dualcontrol.DualControlGenSecKey
</code>

where we use a <tt>JCEKS</tt>-type keystore for our symmetric secret key, generated as 256bit AES, and aliased as "dek2013."

For example, three admins submit their passwords via SSL sockets where their client cert's <tt>CN</tt> identifies them as <tt>evanx</tt>, <tt>henty</tt> and <tt>brent</tt>. 

<code language="xml">
INFO [DualControlReader] readDualMap submissionCount: 3
INFO [DualControlReader] readDualMap purpose: new key dek2013
INFO [DualControlReader] readSubmissions SSL port 4444
INFO [DualControlReader] Received evanx KGV3SY3APDPPX6EI3BCXU7DW7BOI6EKM
INFO [DualControlReader] Received henty 6QLBNC26WGS34AILXPBSP2V65B3N5CYF
INFO [DualControlReader] Received brent SLZP3GMHTMGCIZVLQZEK7NR4JEBSG6OB
INFO [DualControlReader] readDualMap dualAlias: brent-evanx
INFO [DualControlReader] readDualMap dualAlias: brent-henty
INFO [DualControlReader] readDualMap dualAlias: evanx-henty
INFO [DualControlGenSecKey] alias dek2013-brent-evanx
INFO [DualControlGenSecKey] alias dek2013-brent-henty
INFO [DualControlGenSecKey] alias dek2013-evanx-henty
</code>

We see that <tt>!DualControlGenSecKey</tt> creates secret key entries under the following "dual aliases."

<code language="xml">
$ keytool -keystore $keystore -storetype JCEKS -storepass $storepass -list | grep Entry
dek2013-brent-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-brent-evanx, 18 Aug 2013, SecretKeyEntry,
</code>

Actually these three keys are one and the same! However each copy has a different key password, which is actually a combination of a pair of personal passwords, which we call a "split password."

<h4><tt>!DualControlConsole</tt></h4>

Let's write an app for admins to submit their passwords via SSL.

{{{
public class DualControlConsole {
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        call(System.getProperties(), new ConsoleAdapter(System.console()));

    }    

    public static void call(Properties properties, MockableConsole console) 
            throws Exception {
        call(properties, console, 
                DualControlSSLContextFactory.createSSLContext(properties));
    }    
    ...
}
}}}

We provide <tt>public</tt> methods suitable for our unit test e.g. to provide a <tt>!MockConsole</tt> whereas the <tt>main()</tt> method above passes a <tt>System.console()</tt> adapter.

We see above that <tt>DualControlSSLContextFactory</tt> creates an <tt>SSLContext</tt> from <tt>System</tt> properties, which specify the requisite keystore and truststore. We'll see later that our unit test provides an <tt>SSLContext</tt> from <tt>!KeyStore</tt>'s which it creates programmatically. 

{{{
    public static void call(Properties properties, MockableConsole console,
            SSLContext sslContext) throws Exception {
        Socket socket = sslContext.getSocketFactory().createSocket(HOST, PORT);
        DataInputStream dis = new DataInputStream(socket.getInputStream());
        String purpose = dis.readUTF();
        char[] password = console.readPassword(
                "Enter password for " + purpose + ": ");
        String invalidMessage = new DualControlPasswordVerifier(
                properties).getInvalidMessage(password);
        if (invalidMessage != null) {
            console.writer().println(invalidMessage);
        } else {
            String hash = Digests.sha1String(Chars.getBytes(password));
            Arrays.fill(password, (char) 0);
            password = console.readPassword(
                    "Re-enter password for " + purpose + ": ");
            if (!Digests.sha1String(Chars.getBytes(password)).equals(hash)) {
                console.writer().println("Passwords don't match.");
            } else {
                DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                writeChars(dos, password);
                String message = dis.readUTF();
                console.writer().println(message);
            }
            Arrays.fill(password, (char) 0);
        }
        socket.close();
    }
}}}
where we open an SSL socket to our supposed dual-controlled app listening on port 4444 on <tt>localhost</tt> e.g. port forwarded using <tt>ssh</tt>, and are authenticated and identified via our SSL cert.

{{{
evanx@beethoven:~$ java -Ddualcontrol.ssl.keyStore=evanx.jks dualcontrol.DualControlConsole
Enter password for dual control SSL connection:
Enter password for new key dek2013: 
Re-enter password: 
OK evanx
}}}
where <tt>DualControlSSLContextFactory</tt> will prompt for the SSL keystore password first.

<img align="right" src="http://jroller.com/evanx/resource/Gnome-preferences-desktop-personal-250-crop.png"/>

A known "bug" is that more godly sysadmins can socially-engineer other less godly admins to submit their passwords whilst a malicious socket server has been installed by the most godly one onto that frikking port! Other naughty tricks that come to mind is the creation of phantom admins, or the impersonation of other admins e.g. during a key generation procedure, by exploiting <i>root</i> access to SSL keystores. Perhaps you can propose some measures to improve admins' level of confidence that they are not having the wool pulled over their eyes? 

Otherwise the workaround for such "bugs" in plain management-speak is that our "controls" as documented in our "policies and procedures" detect such attacks and dictate the immediate inauguration of appropriate remediation measures. <i>Sounds great!</i>

On a positive note, we can setup "<i>double</i>-two-factor" authentication whereby the client requires a password-protected <tt>ssh</tt> key for port forwarding, and a password-protected <tt>!KeyStore</tt> for the client-authenticated SSL connection. For both the underlying <tt>ssh</tt> access, and the <tt>SSL</tt> connection over that, the admin needs to <i>have</i> the private key, and <i>know</i> the password that is protecting it, and so both require <a href="http://en.wikipedia.org/wiki/Multi-factor_authentication">multi-factor authentication</a>. <i>The only problem is that root can also "have" the keys - D'oh!</i>

<h4>Password complexity vs length</h4>

We ensure that the complexity and/or length of the password is sufficient to counter brute-force attacks.

{{{
public class DualControlPasswordVerifier {
    final boolean verifyPasswordComplexity;
    final int minPasswordLength;
    final int minWordCount;

    public DualControlPasswordVerifier(Properties properties) {
        VellumProperties props = new VellumProperties(properties);
        verifyPassword = props.getBoolean(
                "dualcontrol.verifyPassword", true);
        verifyPasswordComplexity = props.getBoolean(
                "dualcontrol.verifyPasswordComplexity", true);
        minPasswordLength = props.getInt(
                "dualcontrol.minPasswordLength", 12);
        minWordCount = props.getInt(
                "dualcontrol.minWordCount", 4);
    }
    ...
}}}

We note that PCI DSS mandates alphanumeric passwords, whereas <a href="http://en.wikipedia.org/wiki/Sarbanes%E2%80%93Oxley_Act">SOX</a> says uppercase and lowercase, and we should cover all bases.

{{{    
    public String getInvalidMessage(char[] password) throws Exception {
        if (password.length < minPasswordLength) {
            return "Password too short";
        }
        if (countWords(password) < minWordCount) {
            return "Too few words in passphrase";
        }
        if (verifyPasswordComplexity) {
            if (!containsLetter(password) || !containsUpperCase(password) || 
                    !containsLowerCase(password) || !containsDigit(password) || 
                    !containsPunctuation(password)) {
                return "Insufficient password complexity";
            }
        }
        return null;
    }
}}}

Clearly passphrases are easier to remember than complex passwords, and so perhaps we should enforce passphrases with a minimum word count, rather than complexity per se. Then we don't have to write down our complex password and stick it on our monitor.

Having said that, we can easily capitalise the first letter of our passphrase, add a punctuation mark at the end at least, and somewhere replace an 'o' with a zero or an 'e' with 3. <i>Y3ah b4by!</i>

<h4>Brutish Key Protector</h4>

Our keystore is unfortunately forever vulnerable to theft and/or brute-force attacks. Even when we have deleted it, someone else might have ill-gotten it earlier. On the upside, we might assume that the data is no longer of any value to anyone after say 30 years.

We observe that an Intel i5 can manage about 30 guesses per millisecond on a JCE keystore, using 4 threads to utilise its quad-cores.

<code language="xml">
evanx@beethoven:~$ java dualcontrol.JCEKSBruteForceTimer 4 1000000 \
  $seckeystore $pass dek2013-evanx-henty eeeehhhh

threads 4, count 1000000, time 128s, avg 0.032ms
31 guesses per millisecond
</code>

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-shield-250.png" />

If we fear that in the future someone can try an average of 1000 guesses per millisecond on a botnet of a 50M machines, then by my backroom calculations, 41 years are required to try a quarter of all possible passwords up to 18 characters in length using a lazy subset of only 20 characters. 

<code language="xml">
$ bc
guess=1000
mach=50
20^18/(365*24*3600*1000*guess*mach*1000*1000)/4
41
</code>

However, if we assume some combination of the 2000 most common words is used for a passphrase, then 18 characters is not enough. <i>D'oh!</i>

We note that our desired minimum length applies to each admin's passphrase, so as to protect against a rogue admin perpetrating the brute-force attack on the other half of the split password.

A follow-up article will discuss this further, and conclude that we might want an even stronger <tt>!KeyStore</tt> implementation than JCEKS, in particular with a stronger <tt>!KeyProtector</tt> using <tt>PBKDF2</tt> or even <tt>scrypt</tt>. We want a huge large number of iterations e.g. 500k, so that it takes a few seconds to load the key. That is clearly a tolerable startup delay in our production environment, and will disable brute-force attacks.

<h4><tt>DualControlSSLContextFactory</tt></h4>

Similarly to the standard <tt>-Dnet.javax.ssl.keyStore</tt> <i>et al</i> command-line options to override the default "keyStore" and "trustStore" for SSL sockets, we use <tt>-Ddualcontrol.ssl.keyStore</tt> and so on.

These are used to create an <tt>SSLContext</tt>, in particular for opening an <tt>SSLSocket</tt> in <tt>!DualControlConsole</tt>, and for creating an <tt>SSLServerSocket</tt> in <tt>!DualControlReader</tt>.

{{{
public class DualControlSSLContextFactory {    
    ...
    public static SSLContext createSSLContext(Properties properties, MockableConsole console)
            throws Exception {
        VellumProperties props = new VellumProperties(properties);
        String keyStoreLocation = props.getString("dualcontrol.ssl.keyStore");
        if (keyStoreLocation == null) {
            throw new Exception("Missing -D property: dualcontrol.ssl.keyStore");
        }
        char[] keyStorePassword = props.getPassword("dualcontrol.ssl.keyStorePassword", 
                null);
        if (keyStorePassword == null) {
            keyStorePassword = console.readPassword(
                    "Enter passphrase for dual control SSL connection: ");
        }
        char[] keyPassword = props.getPassword("dualcontrol.ssl.keyPassword", 
                keyStorePassword);
        String trustStoreLocation =
                props.getString("dualcontrol.ssl.trustStore", keyStoreLocation);
        char[] trustStorePassword =
                props.getPassword("dualcontrol.ssl.trustStorePassword", keyStorePassword);
        SSLContext sslContext = createSSLContext(keyStoreLocation, keyStorePassword,
                keyPassword, trustStoreLocation, trustStorePassword);
        Arrays.fill(keyStorePassword, (char) 0);
        Arrays.fill(keyPassword, (char) 0);
        Arrays.fill(trustStorePassword, (char) 0);
        return sslContext;
    }
}
}}}

where passwords can specified on the command-line e.g. for test scripts, but otherwise we prompt for the SSL keystore password to be entered on the console.

<img align=right style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

Note that the <tt>-Ddualcontrol.ssl.keyStore</tt> property is the location of our "private keystore" which contains the <i>private</i> key and its certificate, used for SSL e.g. for RSA or DSA assymmetric encryption. This should not be confused with our "secret keystore" which contains an AES or DESede <i>secret</i> key for symmetric encryption of our data.

As illustrated above, we invariably use <tt>char</tt> arrays for passwords, and clear these as soon as possible. <tt>String</tt>'s are immutable and will be garbage-collected and overwritten in memory at some stage, but that is too indeterminate to alleviate our paranoia. Having said that, <tt>!SecretKeySpec</tt> and friends clone byte arrays like there's no tomorrow, d'oh! So we gotta somehow ensure no one can "debug" our memory!?

<h4><tt>!DualControlReader</tt></h4>

We observe the following logs when testing <tt>!DualControlGenSecKey</tt>.
<code language="xml">
INFO [DualControlReader] readDualMap submissionCount: 3
INFO [DualControlReader] readDualMap purpose: new key dek2013
INFO [DualControlReader] readSubmissions SSL port 4444
INFO [DualControlReader] Received evanx
INFO [DualControlReader] Received henty
INFO [DualControlReader] Received brent
INFO [DualControlReader] readDualMap dualAlias: brent-evanx
INFO [DualControlReader] readDualMap dualAlias: brent-henty
INFO [DualControlReader] readDualMap dualAlias: evanx-henty
</code>

So our <tt>!DualControlReader</tt> utility class handles reading split knowledge submissions.

{{{
public class DualControlReader {
    private String purpose;
    private int submissionCount;
    private SSLContext sslContext;
    private Map<String, char[]> map = new TreeMap();
    
    public Map<String, char[]> readDualMap(String purpose, int submissionCount,
            SSLContext sslContext) throws Exception {
        this.purpose = purpose;
        this.submissionCount = submissionCount;
        this.sslContext = sslContext;
        logger.info("readDualMap submissionCount: " + submissionCount);
        logger.info("readDualMap purpose: " + purpose);
        readSubmissions();
        for (String name : submissions.keySet()) {
            for (String otherName : submissions.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    String dualAlias = String.format("%s-%s", name, otherName);
                    char[] dualPassword = combineSplitPassword(
                            submissions.get(name), submissions.get(otherName));
                    map.put(dualAlias, dualPassword);
                    logger.info("readDualMap dualAlias: " + dualAlias);
                }
            }
        }
        return map;
    }
    ...
}}}

The <tt>compareTo()</tt> in the nested loop above ensures that we exclude the alphabetically-challenged <tt>evanx-brent</tt> in favour of <tt>brent-evanx</tt>, and the likes of <tt>evanx-evanx</tt>, which is just silly.

We invoke <tt>readSubmissions()</tt> to listen for submissions via an <tt>SSLServerSocket</tt>.

{{{
    private final static int PORT = 4444;
    private final static String HOST = "127.0.0.1";
    private final static String REMOTE_ADDRESS = "127.0.0.1";
    ...
    private void readSubmissions() throws Exception {
        logger.info("readSubmissions SSL port " + PORT);
        SSLServerSocket serverSocket = (SSLServerSocket) sslContext.
                getServerSocketFactory().createServerSocket(PORT, submissionCount,
                InetAddress.getByName(HOST));
        try {
            serverSocket.setNeedClientAuth(true);
            read(serverSocket);
        } finally {
            serverSocket.close();
        }
    }
}}}

where we have hard-wired the <tt>SSLServerSocket</tt> to <tt>localhost</tt> i.e. via the loopback interface. Therefore <tt>!DualControlConsole</tt> must be invoked either in a local <tt>ssh</tt> session, or a remote session using <tt>ssh</tt> port forwarding.

{{{    
    private void read(SSLServerSocket serverSocket) throws Exception {
        while (map.size() < submissionCount) {
            SSLSocket socket = (SSLSocket) serverSocket.accept();
            try {
                if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                    throw new Exception("Invalid remote address "
                            + socket.getInetAddress().getHostAddress());
                }
                read(socket);
            } finally {
                socket.close();
            }
        }
    }
}}}

where we accumulate the required number of submissions in a loop.

{{{    
    private void read(SSLSocket socket) throws Exception {
        String name = new X500Name(socket.getSession().getPeerPrincipal().
                getName()).getCommonName();
        if (names.contains(name)) {
            throw new Exception("Duplicate submission from " + name);
        }
        names.add(name);
        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
        dos.writeUTF(purpose);
        DataInputStream dis = new DataInputStream(socket.getInputStream());
        char[] password = readChars(dis);
        String responseMessage = "Received " + name;
        String invalidMessage = new DualControlPasswordVerifier(
                properties).getInvalidMessage(password);
        if (invalidMessage != null) {
            throw new Exception(responseMessage + ": " + invalidMessage);
        }
        map.put(name, password);
        dos.writeUTF(responseMessage);
    }
}}}

where the admin's username is determined from their SSL cert, in particular the <tt>CN</tt> field.

<h4><tt>!DualControlDemoApp</tt></h4>

On the downside, we have to re-engineer our application to be dual-controlled, in order to load the key it so desperately needs to cipher our data.

{{{
public class DualControlDemoApp {
    private SecretKey dek;     
    ...
    public void loadKey(String keyStoreLocation, char[] keyStorePass, String alias) 
            throws Exception {
        dek = DualControlSessions.loadKey(keyStoreLocation, keyStorePass, alias,
                "DualControlDemoApp");
        logger.info("Loaded key " + alias + " alg " + dek.getAlgorithm());
    }
}
}}}

The application loads keys as if it's too easy. But the caveat is that execution is blocked whilst we are waiting on the <tt>SSLServerSocket</tt> for two admins to submit their passwords using <tt>!DualControlConsole</tt>'s.

<code language="xml">
$ java dualcontrol.DualControlDemoApp seckeystore.jceks test1234 dek2013
INFO [DualControlDemoApp] main invoked with args: [seckeystore.jceks, test1234, dek2013]
INFO [DualControlReader] readDualMap submissionCount: 2
INFO [DualControlReader] readDualMap purpose: key dek2013 for DualControlDemoApp
INFO [DualControlReader] readSubmissions SSL port 4444
INFO [DualControlReader] Received evanx
INFO [DualControlReader] Received henty
INFO [DualControlReader] readDualMap dualAlias: evanx-henty
INFO [DualControlSessions] dek2013-evanx-henty
INFO [DualControlDemoApp] Loaded key dek2013 alg AES
</code>

where the two <tt>!DualControlConsole</tt> sessions are as follows. 

<code language="xml">
$ java -Ddualcontrol.ssl.keyStore=evanx.jks dualcontrol.DualControlConsole
Enter passphrase for dual control SSL connection: 
Enter password for key dek2013 for DualControlDemoApp: 
Re-enter password for key dek2013 for DualControlDemoApp: 
OK evanx WLCO4XPIFBTNWOHXTRWUVENGEZEGW4HJ
</code>

<code language="xml">
$ java -Ddualcontrol.ssl.keyStore=henty.jks dualcontrol.DualControlConsole
Enter passphrase for dual control SSL connection: 
Enter password for key dek2013 for DualControlDemoApp: 
Re-enter password for key dek2013 for DualControlDemoApp: 
OK henty 6QLBNC26WGS34AILXPBSP2V65B3N5CYF
</code>

where the response message includes a hash of the submitted password so we might recognise its correctness or correctability.

<h4><tt>!DualControlSessions</tt></h4>

Our app above invokes the <tt>loadKey()</tt> method below to do the legwork. 

{{{
public class DualControlSessions {

    public static SecretKey loadKey(String keyStoreLocation, char[] keyStorePass,
            String alias, String purpose) throws Exception {
        KeyStore dualKeyStore =
                DualControlKeyStores.loadKeyStore(keyStoreLocation, keyStorePass);
        purpose = "key " + alias + " for " + purpose;
        Map.Entry<String, char[]> entry = DualControlReader.readDualEntry(purpose);
        String dualAlias = entry.getKey();
        char[] dualPass = entry.getValue();
        alias = alias + "-" + dualAlias;
        SecretKey key = (SecretKey) dualKeyStore.getKey(alias, dualPass);
        Arrays.fill(dualPass, (char) 0);
        return key;
    }
}
}}}

where we read the dual info using the aforementioned <tt>!DualControlReader</tt> which creates an <tt>SSLServerSocket</tt> on a well-known port e.g. 4444.

<h4>Unit test</h4>

In <a href="https://code.google.com/p/vellum/source/browse/trunk/test/dualcontrol/DualControlTest.java"><tt>!DualControlTest</tt></a>, we test <tt>!DualControlReader</tt> and two <tt>!DualControlConsole</tt>'s in concert, using threads and <i>crumbled-up cookie things</i> like mock consoles and SSL context maps. This will be presented in a follow-on article, as this article is already too long.

<h4>Crypto server</h4>

We might wish to create a central crypto server which is dual-controlled, rather than burden our app. In this case, we can restart our application without dual control, and indeed have any number of apps using this server. This simplifies key management, and enables us to isolate our keys to improve security.

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

We'll implement the crypto server in a subsequent article. <i>Then we can say, "Dual control? We have an app for that." ;)</i>

<h4>Conclusion</h4>

The problem with encryption is secure key management. We shouldn't leave the key under the mat.

PCI requires that "split knowledge and dual control" be used to protect our data-encryption key so that no single person can extract the data in clear-text, not even our most trustworthy employee today, rogue tomorrow.

We present a <tt>!DualControlGenSecKey</tt> utility for generating secret keys that are really secret. We protect the data-encryption keys using password-based encryption, courtesy of <tt>JCEKeyStore</tt>. We enable split knowledge of the key password, so that dual control is required to load the key.

We propose keeping at least three copies of the same key, but where each copy is password-protected by a different pair of admins. Then if one admin is on vacation or otherwise indisposed, that's OK because we only require two admins to load the key when we restart our app.

<h4>See also</h4>

In "Dual Control Mock Console" we will present a unit test for <tt>!DualControlReader</tt> and <tt>!DualControlConsole</tt> in concert - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/test/dualcontrol/DualControlTest.java"><tt>!DualControlTest.java</tt></a>

In "Dual Control Revoke and Enroll" we will present other tools similar to <tt>!DualControlGenSec</tt>, namely <tt>!DualControlRevoke</tt> and <tt>!DualControlEnroll</tt> to manage admin staff reshuffles - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/DualControlEnroll.java"><tt>!DualControlEnroll.java</tt></a> and <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/DualControlRevoke.java"><tt>!DualControlRevoke.java</tt></a>

In "Dual Control Crypto Server" we implement a dual-controlled crypto server to unburden our apps, simplify key management and enhance security - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/CryptoServer.java"><tt>!CryptoServer.java</tt></a> and its <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/CryptoHandler.java"><tt>!CryptoHandler.java</tt></a>

In "Dual Control Key Protection" we address increased protection against brute-force password attacks e.g. via PBE of the keystore using <tt>PBKDF2</tt> with a high number of iterations, so that the key takes a second or two to recover, rather than half a millisecond - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/JCEKSBruteForceTimer.java"><tt>JCEKSBruteForceTimer.java</tt></a> and <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/RecryptedKeyStores.java"><tt>!RecryptedKeyStores.java</tt></a>.

In "Dual Control Key Rotation" we'll address periodic key revision e.g. migrating from a old "dek2013" key a to revised "dek2014" key.

You can browse the code for this exercise at <a href="http://code.google.com/p/vellum">code.google.com/vellum</a> in the <a href="https://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fdualcontrol"> <tt>dualcontrol</tt></a> package.

<tt><a href="https://twitter.com/evanxsummers" class="twitter-follow-button" data-show-count="false">@evanxsummers</a></tt>
