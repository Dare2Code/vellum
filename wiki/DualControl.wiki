
= Dual Control =

Keywords: Dual Control, Split Knowledge, Key Management, Encryption, PAN, PCI

== Introduction ==

Encryption is great for information security and all that, but the problem with encryption is... secure key management. The analogy often espoused, is that we lock our doors but leave the key in the door, or under the mat, or in the pot plant under a stone, but that's my personal favourite so ssh-ssh. 

<img align=left src="http://jroller.com/evanx/resource/gnome-keys-250.png">

So the Payment Card industry (PCI) has their "Data Storage Standard" called "PCI DSS," which has general best practices that every industry should follow, actually. It's the only and best thing we got :)

The PCI DSS mandates that "PAN's" aka credit card numbers, must be "rendered unreadable" e.g. encrypted. But it goes without saying that other industries store their own sensitive data, governments too ;)

The PCI DSS standard suggests encrypting the key used to encrypt our data. So in our effort to secure the key, we end up with another key. <i>D'oh!</i> But now this is a "key-encrypting-key" (KEK). Woohoo, the keys to the kindgom! Erm, d'oh!

PCI requires that "dual control" and "split knowledge" be used to protect the PAN, i.e. our most secret data. The intent is that no single person can extract the secret data. The disconnect problem here is that sysadmins are a single person, with God-like access to secret data, and custodian of the proverbial keys to the kindgom. Consequently sysadmins have root access ;)

Naturally, <tt>keytool</tt> is tailored for a single root admin, not for "dual control" by two half-baked admins. No problem, we present some tricks for implementing "dual control" for generating keys so that no one can access them, not even "root." <i>Woohoo!</i>

But then our application can't access them either. No problem, we'll use the same tricks for dual-control of our application. <i>Woohoo!</i> But then starting our application needs two people. <i>D'oh!</i> No problem, we'll implement a companion crypto server then. 

Actually, we'll implement the crypto server next monthly only, in part 2. 

== `DualControlKeyTool` ==

Step 1 for any organisation's data security operation is to generate some master key such that no single root can access. For this purpose, their shall be <tt>!DualControlKeyTool</tt>, as follows.

{{{
public class DualControlKeyTool {
    private final static Logger logger = Logger.getLogger(DualControlKeyTool.class);
    private static String aliasPrefix = System.getProperty("dualcontrol.alias");
    private static int inputCount = Integer.getInteger("dualcontrol.inputs", 3);
    String[] args; 
    
    public static void main(String[] args) throws Exception {        
        new DualControlKeyTool().start(args);
    }
    
    void start(String[] args) throws Exception {
        this.args = args;
        Map<String, String> dualMap = DualControlReader.readDualMap(inputCount);
        for (String alias : dualMap.keySet()) {
            keyTool(String.format("%s-%s", aliasPrefix, alias), dualMap.get(alias));
        }
    }
}}}

where this class will invoke <tt>keyTool()</tt> in a loop of some nature. 

{{{
    public void keyTool(String alias, String keypass) throws Exception {
        logger.debug("keyTool alias " + alias);
        List<String> argList = new ArrayList(Arrays.asList(args));
        argList.add("-alias");
        argList.add(alias);
        argList.add("-keypass");
        argList.add(keypass);
        KeyTool.main(argList.toArray(new String[argList.size()]));
    }            
}
}}}

We specify the same arguments as we would to <tt>keytool</tt>, but `DualControlReader` will provide a map of multiple key aliases and their secret passwords, for invoking <tt>keytool</tt> for each.

{{{
public class DualControlReader {
    ...
    public static Map<String, String> readDualMap(int inputCount) throws Exception {
        Map<String, String> map = new TreeMap();
        Map<String, String> inputs = readInputMap(inputCount);
        for (String name : inputs.keySet()) {
            for (String otherName : inputs.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    map.put(String.format("%s-%s", name, otherName),
                            String.format("%s-%s", inputs.get(name), inputs.get(otherName)));
                }
            }
        }
        return map;
    }
}}}

where we read input via SSL presumably from multiple admins, each providing a secret, as below. In the above method, for each combination of two admins, we combine their two usernames into a "dual-alias," and similary, the secrets into a "dual-key-password."

{{{
    private final static int PORT = 4444;

    static List<byte[]> readInputs(int inputCount) throws Exception {
        logger.info("waiting for info on SSL port " + PORT);
        return readInputs(DualControlKeyStores.createSSLContext().getServerSocketFactory().
                createServerSocket(PORT), inputCount);
    }
}}}

where we listen on a SSL port i.e. a `ServerSocket` and collate the multiple submissions into a `List`.

{{{
    static List<byte[]> readInputs(ServerSocket serverSocket, int inputCount) throws Exception {
        List<byte[]> list = new ArrayList();
        for (int i = 0; i < inputCount; i++) {
            Socket socket = serverSocket.accept();
            if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                throw new RuntimeException();
            }
            list.add(readBytes(socket.getInputStream()));
            socket.close();
        }
        serverSocket.close();
        return list;
    }
}}}

=== Demo ===

{{{
  javaks -Ddualcontrol.inputs=3 dualcontrol.DualControlKeyTool \
     -alias powerstate2013 -storetype JCEKS -storepass $pass -genseckey -keyalg DESede
}}}

where we use a `JCEKS`-type keystore for a secret key e.g. triple-DES in this case, and "powerstate2013" is our desired alias.  

{{{
  keyTool alias powerstate-2013-brand-evanx
  keyTool alias powerstate-2013-brand-henty
  keyTool alias powerstate-2013-evanx-henty
}}}

Low and behalfed, these keys do seem to be have been created.

{{{
  keytool -keystore $secstore -storetype JCEKS -storepass $pass -list | grep Entry
}}}

{{{
powerstate2013-brand-henty, 18 Aug 2013, SecretKeyEntry, 
powerstate2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
powerstate2013-brand-evanx, 18 Aug 2013, SecretKeyEntry,
}}}

Actually these keys, are one and the same. However, for each so-called dual-alias, that copy is password-protected using a so-called dual-password i.e. an combination of two passwords, known to no one.

== `DualControlClient` == 

In order for admins to submit their secrets to our `DualControlReader` e.g. from a ssh session on the `localhost`, we provide a minimal SSL client as follows.

{{{
public abstract class DualControlClient {
    final static Logger logger = Logger.getLogger(DualControlClient.class);
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        String username = System.console().readLine("DualControl username: ");
        char[] passwd = System.console().readPassword("DualControl password: ");
        write(username + ':'+ new String(passwd));
    }

    public static void write(String data) throws Exception {
        Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                createSocket(HOST, PORT);
        socket.getOutputStream().write(data.getBytes());
        socket.close();
    }
}
}}}
where we concatenate the username and password into a string and send those bytes out the SSL socket to our supposed dual-controlled app listening on port 4444. 

A known bug is that more Godly sysadmins can socially-engineer other less Godly admins to submit their passwords whilst a malicious server has been implanted by the most Godly one onto that frikking port!

== `DualControlSession` == 

We re-engineer our application to similarly get a dual-password, in order to load the key.

{{{
public class AppDemo {
    private SecretKey dek;     
...
    private void loadKey(String keyStorePath, char[] storePass, String alias) throws Exception {
        dek = new DualControlSession().loadKey(keyStorePath, storePass, alias);
    }
}
}}}

where the application loads keys as if it's too easy, but the caveat is that execution is blocked whilst we are waiting for two admins to submit info via their `DualControlClient`.

{{{
public class DualControlSession {
    private KeyStore dualKeyStore;
    private char[] dualPass;
    private String dualAlias;

    public SecretKey loadKey(String keyStorePath, char[] storePass, String alias) throws Exception {
        try {
            this.dualKeyStore = DualControlKeyStores.loadKeyStore(keyStorePath, storePass);
            Map.Entry<String, String> entry = DualControlReader.readDualEntry();
            this.dualAlias = entry.getKey();
            this.dualPass = entry.getValue().toCharArray();
            return (SecretKey) dualKeyStore.getKey(alias + "-" + dualAlias, dualPass);
        } finally {
            Arrays.fill(dualPass, (char) 0);            
        }        
    }
}}}

where we read the dual info using the afore-mentioned `DualControlReader,` which creates an `SSLServerSocket` on a well-known port, listens for connections and reads their submission e.g. using our `DualControlClient` utility.

== Cryto server == 

One might wish to create a central crypto server which is dualled-controlled, rather than have dual-control on your app, in order the load the secret key. In this case, you can restart your application without dual-control, and indeed have any number of apps using this server. Furthermore it simplifies key management. So now we can say, "We have an app for that." ;)

We'll implement the crypto server in part 2. 

== Conclusion ==

The problem with encryption is secure key management. It's like we lock the door but leave the key under the mat.

PCI requires that "dual control" and "split knowledge" be used to protect the secret data so no single person can extract it, not even your most trustworthy employee. 

Naturally, <tt>keytool</tt>, is tailored for a single root admin, rather than "dual control." 

If we have three admins, then naturally we have three combinations of pairs of admins. In order to generate a dual-controlled key, we propose keeping three copies of the same key, but where each copy is password-protected with two bits of "split knowledge" between a specific pair of admins.

We introduce a utility to generate keys, by first collating "half-passwords" from multiple admins via SSL, combining those into a new "dual-password" known to no one, and invoking <tt>KeyTool</tt> with the appropriate parameters.

We presented sample code to read input from multiple admins over an SSL connection, each providing their secret. This is used to invoke <tt>KeyTool</tt>, and also in our app to load the key. 

== See also ==

We'll implement the crypto server in part 2. 

== Resources ==

You can browse the code for this exercise at [http://code.google.com/p/vellum/source/browse/#svn/trunk/src/vellumdemo/cryptonomicaldemo here].
