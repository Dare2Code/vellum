
= Dual Control Key Tool =

rev 0.1, 2013-08-18

Keywords: Dual Control, Split Knowledge, Key Management, Encryption, PAN, PCI

== Introduction ==

Encryption is great for information security and all that. But the problem with encryption is... key management. An analogy often bandied about is that we lock our doors but leave the key in the lock. <i>Or in the pot plant under a stone, but that's my personal favourite so ssh-ssh.</i>

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

So the Payment Card industry (PCI) has their "Data Security Standard" called "PCI DSS," which has general best practices that every industry should follow, actually. It's the only and best thing we got :)

The PCI DSS mandates that "PAN's" aka credit card numbers, must be "rendered unreadable" e.g. encrypted. But it goes without saying that other industries store their own sensitive data; governments too ;)

The PCI DSS standard suggests encrypting the key used to encrypt our data. Darn, we secure the data-encrypting-key (DEK), but now we're lumbered with another key, i.e. a "key-encrypting-key" (KEK). <i>The keys to the kindgom, woohoo!</i>

PCI requires that "dual control" and "split knowledge" be used to protect the PAN, i.e. our most secret data, i.e. the key used to cipher this data. The intent is that no single person can decrypt the data. 

The glaring problem is that sysadmins are a single person, with God-like access to secret data, and custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>

Naturally, `keytool` is tailored for a single omnipotent admin, not for "dual control" by two half-cocked ones. So we present a `keytool` invoker for generating keys that are not "accessible" to anyone, not even "root" ;)

But then our application can't access them either. <i>D'oh!</i> Actually, we can use the same tricks for dual-control of our application to load any keys it requires. <i>Woohoo!</i> But then starting our application requires two coordinated people. <i>D'oh!</i> So we'll present a companion crypto server with the dual-control, in a follow-up article.

== `DualControlKeyTool` ==

Step 1 for any data security procedure is to generate an encryption key, which ideally no single rogue root user can access. For this purpose, there shall be `DualControlKeyTool`, as follows.

{{{
public class DualControlKeyTool { 
    String aliasPrefix = System.getProperty("dualcontrol.alias");
    int submissionCount = Integer.getInteger("dualcontrol.submissions", 3);
    String[] args; 
    
    public static void main(String[] args) throws Exception {        
        new DualControlKeyTool().start(args);
    }
    
    void start(String[] args) throws Exception {
        this.args = args;
        Map<String, char[]> dualMap = new DualControlReader().readDualMap(submissionCount);
        for (String alias : dualMap.keySet()) {
            keyTool(String.format("%s-%s", aliasPrefix, alias), dualMap.get(alias));
        }
    }
    ...
}}}

where `DualControlReader` provides a map of multiple key aliases and their secret passwords, and we invoke Java's `KeyTool` for each. 

{{{
    public void keyTool(String alias, char[] keypass) throws Exception {
        List<String> argList = new ArrayList(Arrays.asList(args));
        argList.add("-alias");
        argList.add(alias);
        argList.add("-keypass");
        argList.add(new String(keypass));
        KeyTool.main(argList.toArray(new String[argList.size()]));
    }            
}}}

where we add computed `-alias` and `-keypass` arguments, and otherwise pass through the command-line arguments as-is to `KeyTool`

For each combination of two admins, we combine their two usernames into a "dual-alias," and also their secrets into a "dual-password."

=== Demo ===

Let's test `DualControlKeyTool` from the command-line, using `keytool` arguments and what-not. 

{{{
  javaks -Ddualcontrol.alias=powerstate2013 -Ddualcontrol.submissions=3 \
     dualcontrol.DualControlKeyTool \
     -keystore $keystore -storetype JCEKS -storepass $storepass -genseckey -keyalg AES -keysize 256
}}}

where we use a `JCEKS`-type keystore for our symmetric secret key, which is specified as 256bit AES, and "powerstate2013" is our desired alias to reference this key.  

"When three admins e.g. claiming to be `evanx`, `henty` and `brand`, have submitted their passwords via SSL TCP/IP socket, we see that `DualControlKeyTool` invokes `KeyTool` thrice with the following "dual-aliases."

{{{
DEBUG keyTool alias powerstate2013-brand-evanx
DEBUG keyTool alias powerstate2013-brand-henty
DEBUG keyTool alias powerstate2013-evanx-henty
}}}

Lo and behold, these keys do seem to be have been created.

{{{
$ keytool -keystore $keystore -storetype JCEKS -storepass $storepass -list | grep Entry
powerstate2013-brand-henty, 18 Aug 2013, SecretKeyEntry, 
powerstate2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
powerstate2013-brand-evanx, 18 Aug 2013, SecretKeyEntry,
}}}

Actually these three keys are one and the same. However for each dual-alias that copy is password-protected using a different "dual-password" combination, known to no one.

== `DualControlClient` == 

In order for admins to submit their secrets to our `DualControlReader` e.g. from a ssh session on the `localhost`, we provide a minimal SSL client as follows.

{{{
public abstract class DualControlClient {
    final static Logger logger = Logger.getLogger(DualControlClient.class);
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        char[] passwd = System.console().readPassword("DualControl password: ");
        Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                createSocket(HOST, PORT);
        byte[] bytes = getBytes(passwd);
        Arrays.fill(passwd, (char) 0);
        socket.getOutputStream().write(bytes);
        socket.close();
        Arrays.fill(bytes, (byte) 0);
    }
        
    public static byte[] getBytes(char[] chars) {
        byte[] array = new byte[chars.length];
        for (int i = 0; i < chars.length; i++) {
            array[i] = (byte) chars[i];    
        }
        return array;
    }               
}
}}}
where we submit our password via SSL socket to our supposed dual-controlled app listening on port 4444 on the `localhost`. The server socket will take our username from the `CN` field of our client cert. 

<img align="right" src="http://jroller.com/evanx/resource/Gnome-preferences-desktop-personal-250-crop.png"/>

A known "bug" is that more Godly sysadmins can socially-engineer other less Godly admins to submit their passwords whilst a malicious server has been implanted by the most Godly one onto that frikking port! Another bug is the creation of phantom admins, and yet another is the impersonation of other admins e.g. during a key generation procedure. 

The workaround for above "bugs," in plain management-speak, is that our "controls" as per our "policies and procedures" should prevent or at least detect such attacks, and we take all necessary measures to mitigate associated risks, <i>blah blah</i>.

== `DualControlKeyStores` ==

Similarly to the standard `-Dnet.javax.ssl.*` command-line options that can be used to specify the default "keyStore" and "trustStore" for SSL sockets, we use `-Ddualcontrol.ssl.keyStore` et al, as below. 

Note that the "keyStore" parameter is our "private keystore" which contains the private key used for SSL e.g. for DSA assymmetric encryption. This should not be confused with our "secret key store" e.g. which contains an AES key for symmetric encryption of our secret data. 
 
{{{
public class DualControlKeyStores {    
    static final String keyStorePath = 
            System.getProperty("dualcontrol.ssl.keyStore");
    static final char[] keyStorePassword = 
            System.getProperty("dualcontrol.ssl.keyStorePassword").toCharArray();
    static final char[] keyPassword = 
            System.getProperty("dualcontrol.ssl.keyPassword").toCharArray();
    static final String trustStorePath = 
            System.getProperty("dualcontrol.ssl.trustStore");
    static final char[] trustStorePassword = 
            System.getProperty("dualcontrol.ssl.trustStorePassword").toCharArray();    
    
    public static SSLContext createSSLContext() throws Exception {
        return createSSLContext(keyStorePath, keyStorePassword, keyPassword,
                trustStorePath, trustStorePassword);
    }
    ...
}}}

where we create an `SSLContext` using these settings, as follows.

{{{
    public static SSLContext createSSLContext(String keyStorePath, 
            char[] keyStorePassword, char[] keyPassword,
            String trustStorePath, char[] trustStorePassword) throws Exception {
        KeyStore keyStore = KeyStore.getInstance("JKS");
        keyStore.load(new FileInputStream(keyStorePath), keyStorePassword);
        KeyStore trustStore = KeyStore.getInstance("JKS");
        trustStore.load(new FileInputStream(trustStorePath), trustStorePassword);
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPassword);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("SunX509");
        trustManagerFactory.init(trustStore);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(keyManagerFactory.getKeyManagers(), 
                trustManagerFactory.getTrustManagers(), new SecureRandom());
        return sslContext;
    }
}}}

In order to load a key store either off the local file system, or alternatively from a remote server, we provide the following method.

{{{    
    public static KeyStore loadKeyStore(String keyStorePath, char[] storePass) throws Exception {
        KeyStore keyStore = KeyStore.getInstance("JCEKS");
        if (keyStorePath.contains(":")) {
            String[] array = keyStorePath.split(":");
            Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                createSocket(array[0], Integer.parseInt(array[1]));
            keyStore.load(socket.getInputStream(), storePass);
            socket.close();
        } else {
            keyStore.load(new FileInputStream(keyStorePath), storePass);
        }
        return keyStore;
    }
}}}

where if the key store "path" is delimited with a colon e.g. "192.168.10.181:4446," then we will interpret this a remote host address and port, rather than a local file path. 

This trick might satisfy the PCI requirement to store such keys on our secure internal network i.e. not in our DMZ, and not on the same server where data is stored that these keys have encrypted i.e. so the door key is not left under the mat, so to speak.

We implement a trival key store file server as follows.

{{{
public class FileServer {
    
    public static void main(String[] args) throws Exception {
        if (args.length != 6) {
            System.err.println("usage: localAddress port backlog count remoteAddress file");
        } else {
            new FileServer().run(InetAddress.getByName(args[0]), Integer.parseInt(args[1]), 
                    Integer.parseInt(args[2]), Integer.parseInt(args[3]), args[4], args[5]);
        }        
    }        

    private void run(InetAddress localAddress, int port, int backlog, int count, 
            String remoteHostAddress, String fileName) throws Exception {
        SSLServerSocket serverSocket = (SSLServerSocket) DualControlKeyStores.createSSLContext().
                getServerSocketFactory().createServerSocket(port, backlog, localAddress);
        serverSocket.setNeedClientAuth(true);
        FileInputStream stream = new FileInputStream(fileName);
        int length = (int) new File(fileName).length();
        byte[] bytes = new byte[length];
        stream.read(bytes);
        while (true) {
            Socket socket = serverSocket.accept();
            logger.info("hostAddress " + socket.getInetAddress().getHostAddress());
            if (socket.getInetAddress().getHostAddress().equals(remoteHostAddress)) {
                socket.getOutputStream().write(bytes);
            }
            socket.close();
            if (count > 0 && --count == 0) break;
        }        
    }    
}
}}}

where we create an `SSLServerSocket` to which we write the specified file's contents in response to any connection, which is client-authenticated i.e. we trust its cert i.e. that cert is imported into its truststore. 

== `DualControlReader` ==

Our `DualControlReader` utility class handles reading split knowledge submissions.

{{{
public class DualControlReader {
    ...
    public Map<String, char[]> readDualMap(int submissionCount) throws Exception {
        logger.info("Waiting for submissions on SSL port " + PORT);
        this.submissionCount = submissionCount;
        Map<String, char[]> map = new TreeMap();
        Map<String, char[]> submissions = readMap();
        for (String name : submissions.keySet()) {
            for (String otherName : submissions.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    map.put(String.format("%s-%s", name, otherName),
                            String.format("%s-%s", submissions.get(name), 
                            submissions.get(otherName)).toCharArray());
                }
            }
        }
        return map;
    }
}}}

where we invoke `readMap()` to read split knowledge from multiple admins.

Disclaimer: a known bug in the above code is that we create <tt>String</tt>'s containing clear-text passwords, rather than adamantly sticking to `char` arrays, because arrays can cleared, whereas `String`'s are immutable and so hang around until garbage-collected.


which read and map password submissions from multiple admins, where their username is taken from their SSL cert. 

{{{
    private final static int PORT = 4444;
    private final static String LOCAL_ADDRESS = "127.0.0.1";
    private final static String REMOTE_ADDRESS = "127.0.0.1";

    Map<String, char[]> readMap() throws Exception {
        Map<String, char[]> map = new TreeMap();
        SSLServerSocket serverSocket = (SSLServerSocket) DualControlKeyStores.createSSLContext().
                getServerSocketFactory().createServerSocket(PORT, submissionCount, 
                InetAddress.getByName(LOCAL_ADDRESS));
        serverSocket.setNeedClientAuth(true);
        for (int i = 0; i < submissionCount; i++) {
            SSLSocket socket = (SSLSocket) serverSocket.accept();
            if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                throw new RuntimeException();
            }
            String username = new X500Name(socket.getSession().getPeerPrincipal().
                    getName()).getCommonName();
            map.put(username, readChars(socket.getInputStream(), 64));
            socket.close();
        }
        serverSocket.close();
        return map;
    }
}}}

where we listen on a SSL port i.e. an `SSLServerSocket` which we have hard-wired this to `localhost` i.e. via the loopback interface, where `DualControlClient` invoked in local `ssh` sessions.

{{{
    public static char[] readChars(InputStream inputStream, int capacity) throws IOException {
        CharBuffer buffer = CharBuffer.allocate(capacity);
        while (true) {
            int b = inputStream.read();
            if (b < 0) {
                return buffer.array();
            }
            buffer.append((char) b);
        }
    }   
}}}

== `DualControlSessions` == 

We re-engineer our application to similarly get a dual-password, in order to load the key.

{{{
public class AppDemo {
    private SecretKey dek;     
    ...
    private void loadKey(String keyStorePath, char[] storePass, String alias) throws Exception {
        dek = DualControlSessions.loadKey(keyStorePath, storePass, alias);
    }
}
}}}

where the application loads keys as if it's too easy to be right, but the caveat is that execution is blocked whilst we are waiting for two admins to submit info via their `DualControlClient`.

{{{
public class DualControlSessions {

    public static SecretKey loadKey(String keyStorePath, char[] storePass, String alias) 
            throws Exception {
        char[] dualPass = null;
        try {
            KeyStore dualKeyStore = DualControlKeyStores.loadKeyStore(keyStorePath, storePass);
            Map.Entry<String, char[]> entry = DualControlReader.readDualEntry();
            String dualAlias = entry.getKey();
            dualPass = entry.getValue();
            return (SecretKey) dualKeyStore.getKey(alias + "-" + dualAlias, dualPass);
        } finally {
            if (dualPass != null) {
                Arrays.fill(dualPass, (char) 0);            
            }
        }        
    }
}
}}}

where we read the dual info using the afore-mentioned `DualControlReader,` which creates an `SSLServerSocket` on a well-known port, listens for connections and reads their submission e.g. using our `DualControlClient` utility.

== Cryto server == 

One might wish to create a central crypto server which is dualled-controlled, rather than burden your app. In that case, you can restart your application without dual-control, and indeed have any number of apps using this server. Furthermore it simplifies key management. 

We'll implement the crypto server in part 2. So we can say, "Dual control? We have an app for that." ;)

== Conclusion ==

The problem with encryption is secure key management. It's like we lock the door but leave the key under the mat.

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

PCI requires that "dual control" and "split knowledge" be used to protect our sensitive data so that no single person can extract it, not even your most trustworthy employee. 

Naturally, `keytool` is tailored for a single root admin, rather than "dual-control." 

If we have three admins, then naturally we have three combinations of pairs of admins. In order to generate a dual-controlled key, we propose keeping three copies of the same key, but where each copy is password-protected with a "dual-password," i.e. a combination of two passwords.

We present sample code to read password submissions from multiple admins via SSL TCP/IP socket, and provide a `DualControlClient` utility for admins to use to submit passwords

We introduce a utility to generate keys, by first collating passwords from multiple admins via SSL, then combining those into new "dual-passwords" known to no one, and finally invoking the JRE's `KeyTool` with the appropriate parameters.

Finally, we demonstrate how our app can be dual-controlled, to load a key from the store i.e. for ciphering data. 

In a follow-up article, we'll implement a dual-controlled crypto server, so we avoid the burden of dual-control in our apps, isolate our keys on the crypto server, and thereby improve security and simplify key management. 

== See also ==

You can browse the code for this exercise at <a href="http://code.google.com/p/vellum">code.google.com/vellum</a> in the <a href="https://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fdualcontrol"> <tt>dualcontrol</tt></a> package.

