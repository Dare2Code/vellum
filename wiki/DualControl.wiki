#labels Dual Control, Split Knowledge, Key Management, Encryption, PAN, PCI

= Dual Control Key Management =

<h4>Introduction</h4>

Encryption is great for information security and all that. But the problem with encryption is... key management. An analogy often bandied about is that we lock our doors but leave the key in the lock. <i>Or under the mat, but that's my personal favourite so ssh-ssh.</i>

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

The Payment Card industry (PCI) has their "Data Security Standard" called "PCI DSS," which advocates common-sense policies for building a secure network and protecting your data. Actually every industry should adopt PCI DSS because it's the only and best thing we got :)


The PCI DSS mandates that PAN's aka <i>Primary Account Numbers</i> aka credit card numbers, must be "rendered unreadable" e.g. encrypted. It goes without saying that other industries also have sensitive data that people might want to steal, governments even ;)

PCI DSS suggests encrypting the key used to encrypt our data. Darn, we try to secure the data-encrypting-key (DEK), but now we're lumbered with another key, namely a "key-encrypting-key" (KEK).

PCI requires that "dual control" and "split knowledge" be used to protect PAN's, i.e. the key used to cipher this data. The intent is that no single person can steal the data. 

The glaring problem is that sysadmins are a single person, with God-like access to all our data, and custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>

Naturally, <tt>keytool</tt> is tailored for a single omnipotent admin, not for "dual control" by two half-cocked ones. So we present a <tt>!DualControlGenSecKey</tt> utility for generating secret keys that are really secret, i.e. they are not "accessible" to anyone, not even <i>root</i> ;)

But then our application can't access those keys either. <i>D'oh!</i> Actually, we must support dual-control of our application in order to load these keys, which it uses to protect our crown jewels. <i>Woohoo!</i> But then starting our application requires two coordinated people. <i>D'oh!</i> So we'll present a companion crypto server in a follow-up article.

<h4><tt>!DualControlGenSecKey</tt></h4>

Step 1 for any data security endeavour is to generate an encryption key, which ideally no single rogue root user can access. For this purpose, there shall be <tt>!DualControlGenSecKey</tt>, as follows.

{{{
public class DualControlGenSecKey { 
    int submissionCount = Integer.getInteger("dualcontrol.submissions", 3);
    String keyAlias = System.getProperty("alias"); 
    String keyStorePath = System.getProperty("keystore"); 
    String keyStoreType = System.getProperty("storetype");
    String keyAlg = System.getProperty("keyalg");
    int keySize = Integer.getInteger("keysize");
    
    public static void main(String[] args) throws Exception {        
        new DualControlGenSecKey().start(args);
    }

    void start() throws Exception {
        dualMap = new DualControlReader().readDualMap(keyAlias, submissionCount);
        keyStorePassword = getKeyStorePassword();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(keyAlg);
        keyGenerator.init(keySize);
        secretKey = keyGenerator.generateKey();
        keyStore = loadKeyStore(keyStorePath, keyStorePassword);
        KeyStore.Entry entry = new KeyStore.SecretKeyEntry(secretKey);
        for (String dualAlias : dualMap.keySet()) {
            char[] dualPassword = dualMap.get(dualAlias);
            String alias = keyAlias + "-" + dualAlias;
            KeyStore.ProtectionParameter prot = 
                    new KeyStore.PasswordProtection(dualPassword);
            keyStore.setEntry(alias, entry, prot);
        }
        keyStore.store(new FileOutputStream(keyStorePath), keyStorePassword);
    }
    ...
}
}}}
where <tt>!DualControlReader</tt> provides a map of "dual key" aliases and their secret passwords, and we create a entry for each. 

<h4>Demo</h4>

Let's test <tt>!DualControlGenSecKey</tt>.

{{{
  java -Ddualcontrol.submissions=3 -Ddualcontrol.minLength=9 \
     -Dkeystore=$keystore -Dstoretype=JCEKS -Dstorepass=$storepass \
     -Dalias=dek2013 -Dkeyalg=AES -Dkeysize=256 \
     dualcontrol.DualControlGenSecKey
}}}

where we use a <tt>JCEKS</tt>-type keystore for our symmetric secret key, which is specified as 256bit AES, and "dek2013" is our desired alias to reference this key.  

When three admins have submitted their passwords via SSL TCP/IP socket e.g. where their client cert's <tt>CN</tt> identifies them as <tt>evanx</tt>, <tt>henty</tt> and <tt>brent</tt>, we see that <tt>DualControlGenSecKey</tt> saves the secret key under the following "dual-aliases."

{{{
dek2013-brent-evanx
dek2013-brent-henty
dek2013-evanx-henty
}}}

We check that the keys are created in the <tt>!KeyStore</tt>.

{{{
$ keytool -keystore $keystore -storetype JCEKS -storepass $storepass -list | grep Entry
dek2013-brent-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-brent-evanx, 18 Aug 2013, SecretKeyEntry,
}}}

Actually these three keys are one and the same. However each copy is password-protected using a different "dual-password" combination, known to no single person.

<h4><tt>!DualControlConsole</tt></h4>

In order for admins to submit their secrets e.g. from a ssh session on the <tt>localhost</tt>, we provide a minimal SSL client as follows.

{{{
public class DualControlConsole {
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                    createSocket(HOST, PORT);
        try {
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            String prompt = dis.readUTF();
            char[] password = readPassword(prompt);
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF(new String(password));
            String message = dis.readUTF();
            System.console().writer().println(message);
        } finally {
            socket.close();
        }
    }    

    static char[] readPassword(String prompt) throws Exception {
        char[] password = System.console().readPassword(prompt + ": ");
        DualControlPasswords.assertValid(password);
        return password;
    }
}
}}}
where we submit our password via SSL socket to our supposed dual-controlled app listening on port 4444 on the <tt>localhost</tt>, and are identified by our SSL client cert.

<img align="right" src="http://jroller.com/evanx/resource/Gnome-preferences-desktop-personal-250-crop.png"/>

A known "bug" is that more Godly sysadmins can socially-engineer other less Godly admins to submit their passwords whilst a malicious socket server has been implanted by the most Godly one onto that frikking port! Other naughty tricks that come to mind is the creation of phantom admins, or the impersonation of other admins e.g. during a key generation procedure. 

A follow-up article might propose some measures to improve admins' level of confidence that they are not having the wool pulled over their eyes.

The workaround for above "bugs" in plain management-speak, is that our "controls" as documented in in our "policies and procedures," prevent or at least detect such attacks and have words.

<h4><tt>!DualControlKeyStores</tt></h4>

Similarly to the standard `-Dnet.javax.ssl.*` command-line options that can be used to specify the default "keyStore" and "trustStore" for SSL sockets, we use <tt>-Ddualcontrol.ssl.keyStore</tt> et al, as below. 

Note that the "keyStore" parameter is our "private keystore" which contains the <i>private</i> key and its certificate, used for SSL e.g. for DSA assymmetric encryption. This should not be confused with our "secret key store" e.g. which contains a AES <i>secret</i> key for symmetric encryption of our secret data. 
 
{{{
public class DualControlKeyStores {    
    static String keyStorePath = System.getProperty("dualcontrol.ssl.keyStore");
    static char[] keyStorePassword = getPassword("dualcontrol.ssl.keyStorePassword");
    static char[] keyPassword = getPassword("dualcontrol.ssl.keyPassword");
    static String trustStorePath = System.getProperty("dualcontrol.ssl.trustStore");
    static char[] trustStorePassword = getPassword("dualcontrol.ssl.trustStorePassword");    
    
    public static char[] getPassword(String propertyName) {
        return System.getProperty(propertyName).toCharArray();
    }
    
    public static SSLContext createSSLContext() throws Exception {
        return createSSLContext(keyStorePath, keyStorePassword, keyPassword,
                trustStorePath, trustStorePassword);
    }
    ...
}
}}}

where we create an <tt>SSLContext</tt> using these settings.

<h4><tt>!DualControlReader</tt></h4>

Our <tt>!DualControlReader</tt> utility class handles reading split knowledge submissions.

{{{
public class DualControlReader {
    ...
    public Map<String, char[]> readDualMap(String prompt, int submissionCount) throws Exception {
        this.prompt = prompt;
        this.submissionCount = submissionCount;
        Map<String, char[]> map = new TreeMap();
        Map<String, char[]> submissions = readMap();
        for (String name : submissions.keySet()) {
            for (String otherName : submissions.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    String dualAlias = String.format("%s-%s", name, otherName);
                    char[] dualPassword = combineDualPassword(
                            submissions.get(name), submissions.get(otherName));
                    map.put(dualAlias, dualPassword);
                }
            }
        }
        return map;
    }
}}}

If we have three admins e.g. Brent, Evan, and Henty, then we have three combinations of pairs of admins, namely Brent-Evan, Brent-Henty and Evan-Henty (ordered alphabetically). The <tt>compareTo()</tt> in the nested loop ensures we exclude the likes of <tt>Evan-Evan</tt> and <tt>Evan-Brent</tt>, since we already have <tt>Brent-Evan</tt>, and <tt>Evan-Evan</tt> is just silly.

We invoke <tt>readMap()</tt> to read split knowledge submissions from multiple admins.

{{{
    private final static int PORT = 4444;
    private final static String LOCAL_ADDRESS = "127.0.0.1";
    private final static String REMOTE_ADDRESS = "127.0.0.1";
    ...
    Map<String, char[]> readMap() throws Exception {
        logger.info("Waiting for submissions on SSL port " + PORT);
        Map<String, char[]> map = new TreeMap();
        SSLServerSocket serverSocket = 
                (SSLServerSocket) DualControlKeyStores.createSSLContext().
                getServerSocketFactory().createServerSocket(PORT, submissionCount, 
                InetAddress.getByName(LOCAL_ADDRESS));
        serverSocket.setNeedClientAuth(true);
        for (int i = 0; i < submissionCount; i++) {
            SSLSocket socket = (SSLSocket) serverSocket.accept();
            if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                throw new RuntimeException("Remote host address excluded");
            }
            String username = new X500Name(socket.getSession().getPeerPrincipal().
                    getName()).getCommonName();
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF(prompt);
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            char[] chars = dis.readUTF().toCharArray();
            String errorMessage = DualControlPasswords.getErrorMessage(password);
            if (errorMessage == null) {
                map.put(username, password);
                dos.writeUTF("OK");
            } else {
                dos.writeUTF(errorMessage);
            }
            socket.close();
        }
        serverSocket.close();
        return map;
    }
}}}

where we listen on a SSL port i.e. an <tt>SSLServerSocket</tt> which we have hard-wired this to <tt>localhost</tt> i.e. via the loopback interface, where <tt>!DualControlConsole</tt> is invariably invoked in a local <tt>ssh</tt> sessions.

Note that the admin's username is determined from their SSL cert, namely the <tt>CN</tt> field, where we get the <tt>peer</tt> certificate from the <tt>SSLSession</tt>.

Incidently, a known bug in the above code, and similarly in <tt>!DualControlConsole</tt>, is that we sometimes create strings containing passwords. These will be cleared by the garbage collector at some stage, whereas a better practice is to exclusively use arrays, and clear these soonest.

<h4>Complexity and length</h4>

We ensure that the default required complexity and/or length of the password is sufficient to counter brute-force attacks.

{{{
public class DualControlPasswords {
    final static boolean verifyPassword = 
            getBoolean("dualcontrol.verifyPassword", true);
    final static boolean verifyPasswordComplexity = 
            getBoolean("dualcontrol.verifyPasswordComplexity", false);
    final static int minPasswordLength = 
            Integer.getInteger("dualcontrol.minPasswordLength", 12);

    public static void assertValid(char[] password) throws Exception {
        String errorMessage = getErrorMessage(password);
        if (errorMessage != null) {
            throw new Exception(errorMessage);
        }
    }
    ...
}}}

There is an argument that password length is more important that complexity, e.g. a passphrase of 10 lower-case characters, is better than an 8 character password that includes with uppercase, lowercase, digits and punctuation. Furthermore, passphrases are easier to remember, so we don't have to write them down and stick them on our monitor.

In practice most password characters are going to be from a subset of lowercase characters anyway, and so we might choose not to enforce password complexity, but rather require longish passphrases.

<h4>Brute-force</h4>

Our keystore is always vulnerable to theft and/or brute-force attacks. The <a href="http://www.docjar.com/html/api/com/sun/crypto/provider/KeyProtector.java.html"><tt>KeyProtector</tt></a> used by <tt>JCEKeyStore</tt> at least uses a PBE cipher for the key protection, namely <tt>PBEWithMD5AndTripleDES</tt>. 

But surely <tt>PBKDF2</tt>, with high number of iterations, would be way better at combating brute-force attacks on stolen keystores? We want a computationally-expensive algorithm where the key recovery might take seconds rather than microseconds? Or even <a href="http://en.wikipedia.org/wiki/Scrypt"><tt>scrypt</tt></a> which is also memory-intensive.

So we might an even stronger <tt>KeyStore</tt> implementation that that offered by the Sun JCE Provider. 

<h4><tt>!DualControlSessions</tt></h4>

We re-engineer our application to similarly get a dual-password, in order to load the key.

{{{
public class DualControlDemoApp {
    private SecretKey dek;     
    ...
    private void loadKey(String keyStorePath, char[] storePass, String alias) 
            throws Exception {
        dek = DualControlSessions.loadKey(keyStorePath, storePass, alias);
    }
}
}}}

where the application loads keys as if it's too easy, but the caveat is that execution is blocked whilst we are waiting for two admins to submit their passwords using <tt>!DualControlConsole</tt>.

{{{
public class DualControlSessions {

    public static SecretKey loadKey(String keyStorePath, char[] storePass, String alias) 
            throws Exception {
        char[] dualPass = null;
        try {
            KeyStore dualKeyStore = DualControlKeyStores.loadKeyStore(keyStorePath, storePass);
            Map.Entry<String, char[]> entry = DualControlReader.readDualEntry(alias);
            String dualAlias = entry.getKey();
            dualPass = entry.getValue();
            return (SecretKey) dualKeyStore.getKey(alias + "-" + dualAlias, dualPass);
        } finally {
            if (dualPass != null) {
                Arrays.fill(dualPass, (char) 0);            
            }
        }        
    }
}
}}}

where we read the dual info using the afore-mentioned <tt>!DualControlReader,</tt> which creates an <tt>SSLServerSocket</tt> on a well-known port e.g. 4444.

<h4>Crypto server</h4>

One might wish to create a central crypto server which is dualled-controlled, rather than burden your app. In that case, you can restart your application without dual-control, and indeed have any number of apps using this server. Furthermore it simplifies key management. 

We'll implement the crypto server in a follow-up article. <i>Then we can say, "Dual control? We have an app for that." ;)</i>

<h4>Conclusion</h4>

The problem with encryption is secure key management. <i>Aint got no time for that</i>.

We probably shouldn't leave the key under the mat, where tresspassers and rogues can just pick it up and thereby steal our sensitive data. 

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

PCI requires that "dual control" and "split knowledge" be used to protect our sensitive data so that no single person can extract it, not even your most trustworthy employee today, rogue tomorrow.

However your run-of-the-mill <tt>keytool</tt> is tailored for a single admin rather than dual-control. 

If we have three admins e.g. Tom, Dick and Harry, then naturally we have three combinations of pairs of admins, namely Dick-Harry, Dick-Tom and Harry-Tom. 

In order to generate a dual-controlled key, we propose keeping at least three copies of the same key, but where each copy is password-protected with a different "dual-password" to be provided by a given pair of admins. 

We require at least three admins, since one admin might be on leave or otherwise indisposed. Hopefully we can always find two admins to come to the party when we need to restart our app. 

We introduce <tt>!DualControlGenSecKey</tt> to generate a secret key in a JCEKS key store. This collates passwords from multiple admins using <tt>!DualControlReader</tt>, which combines those into paired "dual passwords" known to no single person. 

To complete the picture, we provide a trivial <tt>!DualControlConsole</tt> utility for admins to submit their password from their <tt>ssh</tt> console via a client-authenticated SSL socket.

Finally, we demonstrate how our app can be dual-controlled to load a key from the store at startup, for ciphering our sensitive data for the duration of its execution.

<h4>See also</h4>

In a follow-up article, we'll implement a dual-controlled crypto server, to unburden our apps, improve convenience, but more importantly, to isolate our keys on the crypto server, to simplify key management, to enhance security. 

You can browse the code for this exercise at <a href="http://code.google.com/p/vellum">code.google.com/vellum</a> in the <a href="https://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fdualcontrol"> <tt>dualcontrol</tt></a> package.