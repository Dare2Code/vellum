#labels Dual Control, Split Knowledge, Key Management, Encryption, PAN, PCI

= Dual Control Key Management =

See the source article at <a href="https://code.google.com/p/vellum/wiki/DualControl">code.google.com/p/vellum/wiki/DualControl</a>, which has probably been updated since this posting.

<h4>Introduction</h4>

Encryption is great for information security and all that. But the problem with encryption is... key management. An analogy often bandied about is that we lock our doors but leave the key in the lock. <i>Or under the mat, but that's my personal favourite so ssh-ssh.</i>

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

The Payment Card Industry (PCI) has their "Data Security Standard" called <a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard">PCI DSS</a>, which advocates common-sense policies for building a secure network and protecting your data. Actually every industry should adopt PCI DSS because it's the only and best thing we got :)

The PCI DSS mandates that PAN's aka <i>Primary Account Numbers</i> aka credit card numbers, must be "rendered unreadable" e.g. encrypted. It goes without saying that other industries also have sensitive data that people might want to steal, governments even ;)

PCI DSS suggests encrypting the key used to encrypt our data. Darn, we try to secure the data-encryption key (DEK), but now we're lumbered with another key, namely a "key-encryption key" (KEK).

PCI requires that manual key management requires "split knowledge and dual control" of keys. The intent is that no single person can extract the clear-text data. 

The glaring problem is that sysadmins are a single person, with God-like access to all our data, and de facto custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>

Naturally, <tt>keytool</tt> is tailored for a single omnipotent admin, not for "dual control" by two half-cocked ones. So we present a <tt>!DualControlGenSecKey</tt> utility for generating secret keys that are really secret, i.e. they are unattainable, even to <i>root</i> ;)

But then our application can't access those keys either. <i>D'oh!</i> So we must implement dual-control of our application in order to load these keys. <i>Woohoo!</i> But then starting our application requires two coordinated people. <i>D'oh!</i> So we'll present a companion crypto server in a follow-up article.

<h4><tt>!DualControlGenSecKey</tt></h4>

Step 1 for any data security endeavour is to generate an encryption key, which preferrably not even root can grok. For this purpose, there shall be <tt>!DualControlGenSecKey</tt>, as follows.

{{{
public class DualControlGenSecKey { 
    int submissionCount = Integer.getInteger("dualcontrol.submissions", 3);
    String keyAlias = System.getProperty("alias"); 
    String keyStoreLocation = System.getProperty("keystore"); 
    String keyStoreType = System.getProperty("storetype");
    String keyAlg = System.getProperty("keyalg");
    int keySize = Integer.getInteger("keysize");
    
    public static void main(String[] args) throws Exception {        
        new DualControlGenSecKey().start(args);
    }

    void start() throws Exception {
        dualMap = new DualControlReader().readDualMap(keyAlias, submissionCount);
        keyStorePassword = getKeyStorePassword();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(keyAlg);
        keyGenerator.init(keySize);
        secretKey = keyGenerator.generateKey();
        keyStore = loadKeyStore(keyStoreLocation, keyStorePassword);
        KeyStore.Entry entry = new KeyStore.SecretKeyEntry(secretKey);
        for (String dualAlias : dualMap.keySet()) {
            char[] dualPassword = dualMap.get(dualAlias);
            String alias = keyAlias + "-" + dualAlias;
            KeyStore.ProtectionParameter prot = 
                    new KeyStore.PasswordProtection(dualPassword);
            keyStore.setEntry(alias, entry, prot);
        }
        keyStore.store(new FileOutputStream(keyStoreLocation), keyStorePassword);
    }
    ...
}
}}}
where <tt>!DualControlReader</tt> provides a map of "dual aliases" and their secret "dual passwords," and we create a <tt>!KeyStore</tt> entry for each. 

<h4>Demo</h4>

Let's test <tt>!DualControlGenSecKey</tt>.

{{{
  java -Ddualcontrol.submissions=3 -Ddualcontrol.minPasswordLength=8 \
     -Dkeystore=$keystore -Dstoretype=JCEKS -Dstorepass=$storepass \
     -Dalias=dek2013 -Dkeyalg=AES -Dkeysize=256 \
     dualcontrol.DualControlGenSecKey
}}}

where we use a <tt>JCEKS</tt>-type keystore for our symmetric secret key, which is specified as 256bit AES, and "dek2013" is our desired alias to reference this key.  

When three admins have submitted their passwords via SSL TCP/IP socket e.g. where their client cert's <tt>CN</tt> identifies them as <tt>evanx</tt>, <tt>henty</tt> and <tt>brent</tt>, we see that <tt>!DualControlGenSecKey</tt> creates secret key entries under the following "dual-aliases."

{{{
$ keytool -keystore $keystore -storetype JCEKS -storepass $storepass -list | grep Entry
dek2013-brent-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-brent-evanx, 18 Aug 2013, SecretKeyEntry,
}}}

Actually these three keys are one and the same. However each copy is password-protected using a different "dual-password" combination, known to no single person.

<h4><tt>!DualControlConsole</tt></h4>

In order for admins to submit their password via TCP/IP port, there shall be <tt>!DualControlConsole</tt> as follows.

{{{
public class DualControlConsole {
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                    createSocket(HOST, PORT);
        try {
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            String prompt = dis.readUTF();
            char[] password = System.console().readPassword(prompt + ": ");
            DualControlPasswords.assertValid(password);
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF(new String(password));
            String message = dis.readUTF();
            System.console().writer().println(message);
        } catch (Exception e) {
            System.err.println(e.getMessage());
        } finally {
            socket.close();
        }
    }    
}
}}}
where we submit our password via SSL socket to our supposed dual-controlled app listening on port 4444 on <tt>localhost</tt> e.g. port forwarded using <tt>ssh</tt>, and are identified by our SSL client cert.

<img align="right" src="http://jroller.com/evanx/resource/Gnome-preferences-desktop-personal-250-crop.png"/>

A known "bug" is that more Godly sysadmins can socially-engineer other less Godly admins to submit their passwords whilst a malicious socket server has been inducted by the most Godly one onto that frikking port! Other naughty tricks that come to mind is the creation of phantom admins, or the impersonation of other admins e.g. during a key generation procedure. A follow-up article might propose some measures to improve admins' level of confidence that they are not having the wool pulled over their eyes.

The workaround for above "bugs" in plain management-speak, is that our "controls" as documented in in our "policies and procedures," prevent or detect such attacks, and dictate the immediate inauguration of appropriate remediation measures. 

On a positive note, we can setup "<i>double</i>-two-factor" authentication whereby the client requires a password-protected <tt>ssh</tt> key for port forwarding, and a password-protected <tt>!KeyStore</tt> for the client-authenticated SSL connection. For both the underlying <tt>ssh</tt> access, and the <tt>SSL</tt> connection over that, the admin needs to <i>have</i> the private key, and <i>know</i> the password that is protecting it, i.e. requires <a href="http://en.wikipedia.org/wiki/Multi-factor_authentication">multi-factor authentication</a>. 

<h4><tt>!DualControlKeyStores</tt></h4>

Similarly to the standard <tt>-Dnet.javax.ssl.keyStore</tt> <i>et al</i> command-line options for the default "keyStore" and "trustStore" for SSL sockets, we use <tt>-Ddualcontrol.ssl.keyStore</tt> as below. 

Note that the <tt>-Ddualcontrol.ssl.keyStore</tt> option is our "private keystore" which contains the <i>private</i> key and its certificate, used for SSL e.g. for DSA assymmetric encryption. This should not be confused with our "secret keystore" e.g. which contains a AES <i>secret</i> key for symmetric encryption of our data. 
 
{{{
public class DualControlKeyStores {    
    static String keyStoreLocation = System.getProperty("dualcontrol.ssl.keyStore");
    static char[] keyStorePassword = getPassword("dualcontrol.ssl.keyStorePassword");
    static char[] keyPassword = getPassword("dualcontrol.ssl.keyPassword");
    static String trustStoreLocation = System.getProperty("dualcontrol.ssl.trustStore");
    static char[] trustStorePassword = getPassword("dualcontrol.ssl.trustStorePassword");    
    
    public static char[] getPassword(String propertyName) {
        return System.getProperty(propertyName).toCharArray();
    }
    
    public static SSLContext createSSLContext() throws Exception {
        return createSSLContext(keyStoreLocation, keyStorePassword, keyPassword,
                trustStoreLocation, trustStorePassword);
    }
    ...
}
}}}

where we create an <tt>SSLContext</tt> using these settings e.g. for opening an <tt>SSLSocket</tt>.

<h4><tt>!DualControlReader</tt></h4>

Our <tt>!DualControlReader</tt> utility class handles reading split knowledge submissions.

{{{
public class DualControlReader {
    ...
    public Map<String, char[]> readDualMap(String prompt, int submissionCount) throws Exception {
        this.prompt = prompt;
        this.submissionCount = submissionCount;
        Map<String, char[]> map = new TreeMap();
        Map<String, char[]> submissions = readMap();
        for (String name : submissions.keySet()) {
            for (String otherName : submissions.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    String dualAlias = String.format("%s-%s", name, otherName);
                    char[] dualPassword = combineDualPassword(
                            submissions.get(name), submissions.get(otherName));
                    map.put(dualAlias, dualPassword);
                }
            }
        }
        return map;
    }
}}}

If we have three admins e.g. Brent, Evan, and Henty, then we have three combinations of pairs of admins, namely Brent-Evan, Brent-Henty and Evan-Henty, ordered alphabetically. The <tt>compareTo()</tt> in the nested loop above ensures we exclude the likes of <tt>Evan-Brent</tt> in favour of <tt>Brent-Evan</tt>, and <tt>Evan-Evan</tt>, which is just silly.

We invoke <tt>readMap()</tt> to listen for submissions via an <tt>SSLServerSocket</tt>.

{{{
    private final static int PORT = 4444;
    private final static String LOCAL_ADDRESS = "127.0.0.1";
    private final static String REMOTE_ADDRESS = "127.0.0.1";
    ...
    Map<String, char[]> readMap() throws Exception {
        logger.info("Waiting for submissions on SSL port " + PORT);
        SSLServerSocket serverSocket = (SSLServerSocket) 
                DualControlKeyStores.createSSLContext().
                getServerSocketFactory().createServerSocket(PORT, submissionCount, 
                InetAddress.getByName(LOCAL_ADDRESS));
        serverSocket.setNeedClientAuth(true);
        return readMap(serverSocket);
    }
}}}

where we have hard-wired the <tt>SSLServerSocket</tt> to <tt>localhost</tt> i.e. via the loopback interface e.g. <tt>!DualControlConsole</tt> is invoked in a local <tt>ssh</tt> session, or a remote session using <tt>ssh</tt> port forwarding.

We accumulate the required number of submissions as follows.

{{{    
    Map<String, char[]> readMap(SSLServerSocket serverSocket) throws Exception {        
        Map<String, char[]> map = new TreeMap();
        while (map.size() < submissionCount) {
            SSLSocket socket = (SSLSocket) serverSocket.accept();
            if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                throw new RuntimeException("Remote host address excluded");
            }
            String username = new X500Name(socket.getSession().getPeerPrincipal().
                    getName()).getCommonName();
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF(prompt);
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            char[] password = dis.readUTF().toCharArray();
            String errorMessage = DualControlPasswords.getErrorMessage(password);
            if (errorMessage == null) {
                map.put(username, password);
                dos.writeUTF("OK");
            } else {
                dos.writeUTF(errorMessage);
            }
            socket.close();
        }
        serverSocket.close();
        return map;
    }
}}}

where the admin's username is determined from their SSL cert, namely the <tt>CN</tt> field, where we get the <tt>peer</tt> certificate from the <tt>SSLSession</tt>.

Incidently, a known bug in the above code, and similarly in <tt>!DualControlConsole</tt>, is that we sometimes create strings containing passwords e.g. by <tt>readUTF()</tt> above. These will be cleared by the garbage collector at some stage, whereas a better practice is to use <tt>char</tt>arrays exclusively, and clear these soonest i.e. in a more deterministic fashion.

<h4>Complexity and length</h4>

We ensure that the default required complexity and/or length of the password is sufficient to counter brute-force attacks.

{{{
public class DualControlPasswords {
    final static boolean verifyPassword = 
            getBoolean("dualcontrol.verifyPassword", true);
    final static boolean verifyPasswordComplexity = 
            getBoolean("dualcontrol.verifyPasswordComplexity", false);
    final static int minPasswordLength = 
            Integer.getInteger("dualcontrol.minPasswordLength", 12);

    public static void assertValid(char[] password) throws Exception {
        String errorMessage = getErrorMessage(password);
        if (errorMessage != null) {
            throw new Exception(errorMessage);
        }
    }
    ...
}}}

We argue that password length is more practical than complexity, e.g. that a passphrase of 10 lowercase letters and spaces, is preferrable to an 8 character password that includes with uppercase, lowercase and digits. In practice most password characters are a subset of lowercase characters anyway, so brute-force attacks can favour lowercase to crack passwords sooner. 

Importantly, passphrases are easier to remember, so we don't have to write them down and stick them on our monitor. Consequently, we might choose not to enforce password complexity, but rather require longish passphrases.

<h4>Brutish Key Protector</h4>

Our keystore is unfortunately forever vulnerable to theft and/or brute-force attacks. Even when we have deleted it, someone else might have ill-gotten it earlier. We see that the JCE Provider's <a href="http://www.docjar.com/html/api/com/sun/crypto/provider/KeyProtector.java.html"><tt>!KeyProtector</tt></a> as used by <a href="http://www.docjar.com/docs/api/com/sun/crypto/provider/JceKeyStore.html"><tt>JCEKeyStore</tt></a> (for JCEKS-type keystores) uses a PBE cipher for the key password protection, namely <tt>PBEWithMD5AndTripleDES</tt>. The default <a href="http://www.docjar.com/html/api/sun/security/provider/KeyProtector.java.html"><tt>!KeyProtector</tt></a> used by <a href="http://www.docjar.com/html/api/sun/security/provider/JavaKeyStore.java.html"><tt>!JavaKeyStore</tt></a> i.e. for JKS-type keystores, hashes the password with <tt>SHA</tt>.

But surely <tt>PBKDF2</tt> with high number of iterations, would be way better at combating brute-force attacks on keystores? One wants a computationally-expensive algorithm so that key recovery takes a second rather than a millisecond. We note that <a href="http://en.wikipedia.org/wiki/Scrypt"><tt>scrypt</tt></a> is also memory-expensive.

So we might want an even stronger <tt>!KeyStore</tt> implementation than offered by the Oracle JCE Provider, e.g. with a stronger <tt>!KeyProtector</tt> using <tt>PBKDF2</tt> or <tt>scrypt</tt> with a huge number of iterations. 

<h4><tt>!DualControlSessions</tt></h4>

On the downside, we have to re-engineer our application to be dual-controlled, to load the key it so desperately needs to cipher our data, as follows.

{{{
public class DualControlDemoApp {
    private SecretKey dek;     
    ...
    private void loadKey(String keyStoreLocation, char[] storePass, String alias) 
            throws Exception {
        dek = DualControlSessions.loadKey(keyStoreLocation, storePass, alias);
    }
}
}}}

where the application loads keys as if it's too easy. But the caveat is that execution is blocked whilst we are waiting for two admins to submit their passwords using <tt>!DualControlConsole</tt>'s.

{{{
public class DualControlSessions {

    public static SecretKey loadKey(String keyStoreLocation, char[] storePass, String alias) 
            throws Exception {
        char[] dualPass = null;
        try {
            KeyStore dualKeyStore = DualControlKeyStores.loadKeyStore(keyStoreLocation, storePass);
            Map.Entry<String, char[]> entry = DualControlReader.readDualEntry(alias);
            String dualAlias = entry.getKey();
            dualPass = entry.getValue();
            return (SecretKey) dualKeyStore.getKey(alias + "-" + dualAlias, dualPass);
        } finally {
            if (dualPass != null) {
                Arrays.fill(dualPass, (char) 0);            
            }
        }        
    }
}
}}}

where we read the dual info using the afore-mentioned <tt>!DualControlReader,</tt> which creates an <tt>SSLServerSocket</tt> on a well-known port e.g. 4444.

<h4>Crypto server</h4>

One might wish to create a central crypto server which is dualled-controlled, rather than burden your app. In that case, you can restart your application without dual-control, and indeed have any number of apps using this server. Furthermore it simplifies key management. 

We'll implement the crypto server in a follow-up article. <i>Then we can say, "Dual control? We have an app for that." ;)</i>

<h4>Conclusion</h4>

The problem with encryption is secure key management. <i>Aint got no time for that</i>.

We probably shouldn't leave the key down the garden path, where tresspassers and rogues can just pick it up and thereby enter our house. 

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

PCI requires that "split knowledge and dual control" be used to protect our encryption keys so that no single person can acquire them, not even the most trustworthy employee today, rogue tomorrow.

We take the approach of protecting the data-encryption keys using password-based encryption, by using <tt>JCEKeyStore</tt>. We enforce split knowledge of the password, which is effectively a key-encryption key.

In order to generate a dual-controlled key, we propose keeping at least three copies of the same key, but where each copy is password-protected with a different "dual-password" to be provided by a given pair of admins. Thereafter, if one admin is on vacation or otherwise indisposed, we won't mind because we only require two admins to load a copy of the key when we restart our app :)

Our omnipresent <tt>keytool</tt> is tailored for a single admin, so we introduce <tt>!DualControlGenSecKey</tt> to generate a secret key e.g. in a JCEKS-type keystore. This protects copies of the same key using "dual passwords" known to no single person. 

We demonstrate how our app can be dual-controlled to load a key from the store at startup.

To complete the picture, we provide a trivial <tt>!DualControlConsole</tt> utility for admins to submit their password from their <tt>ssh</tt> console via a client-authenticated SSL socket. We can setup "double-two-factor" authentication whereby the client requires a password-protected <tt>ssh</tt> key for port forwarding, and a password-protected <tt>!KeyStore</tt> for the client-authenticated SSL connection.

We note that we want an even stronger <tt>!KeyStore</tt> implementation than offered by the Oracle JCE Provider, e.g. with a stronger <tt>!KeyProtector</tt> using <tt>PBKDF2</tt> or <tt>scrypt</tt> with a huge number of iterations. 

<h4>See also</h4>

In a follow-up article, we'll implement a dual-controlled crypto server, to unburden our apps, improve convenience, but more importantly, to isolate our keys on the crypto server, to simplify key management, to enhance security. 

We will also need other tools similar to <tt>!DualControlGenSec</tt>, to enroll and revoke admins i.e. to handle staff turnover.  We'll present <tt>!DualControlEnroll</tt> and <tt>!DualControlRevoke</tt> in a yet another sequel. 

Finally we will work through "key rotation" e.g. migrating from a "dek2013" to fresh new "dek2014."

You can browse the code for this exercise at <a href="http://code.google.com/p/vellum">code.google.com/vellum</a> in the <a href="https://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fdualcontrol"> <tt>dualcontrol</tt></a> package.