
= DualControl =

== Introduction ==

The problem with encryption is... secure key management. The analogy often espoused, is that we lock our doors but leave the key in the door, or under the mat, or in the pot plant under a stone, but that's my personal favourite so ssh-ssh. 

So the Payment Card industry (PCI) has their "Data Storage Standard" called "PCI DSS," which has general best practices that every industry should follow, actually. It's the best thing we got. It's only one we got, too :)

The PCI DSS mandates that "PAN's" aka credit card numbers, must be "rendered unreadable" e.g. encrypted. But it goes without saying that other industries store their own sensitive data, governments even ;)

The PCI DSS standard suggests encrypting the key. In our effort to secure the key, we end up with another key, d'oh! But now this is a "key-encrypting-key" (KEK). Woohoo, the keys to the kindgom! D'oh!

PCI requires that "dual control" and "split knowledge" be used to protect the secret data. The intent is that no single person can extract the secret data. The disconnect problem here is that sysadmins are a single person, with God-like access to secret data, and custodian of the keys to the kindgom. Consequently sysadmins have root access. 

Naturally, <tt>keytool</tt>, is tailored for a single root admin, not for "dual control" by two half-baked admins. No problem, we present some tricks for implementing "dual control" for generating keys so that no one can access them, not even "root," woohoo! 

But then our application can't access them either, d'oh! No problem, we'll use the same tricks for dual-control of our application, woohoo! But then starting our application needs two people, d'oh! No problem, we'll implement a companion crypto server that is dual-controlled.


== DualControlKeyTool ==

Step 1 for any data security operation is to generate some master key such that no single root can access. For this purpose, their shall be <tt>!DualControlKeyTool</tt>, as follows.

{{{
public class DualControlKeyTool {    
    private final static Logger logger = Logger.getLogger(DualControlKeyTool.class);
    private static String aliasPrefix = System.getProperty("dualcontrol.alias");
    private static int inputCount = Integer.getInteger("dualcontrol.inputs", 3);
    String[] args; 
    
    public static void main(String[] args) throws Exception {        
        new DualControlKeyTool().start(args);
    }
    
    void start(String[] args) throws Exception {
        this.args = args;
        Map<String, String> dualMap = DualControlReader.readDualMap(inputCount);
        for (String alias : dualMap.keySet()) {
            keyTool(String.format("%s-%s", aliasPrefix, alias), dualMap.get(alias));
        }
    }
}}}

where this class will invoke <tt>keyTool()</tt> in a loop of some nature. 

{{{
    public void keyTool(String alias, String keypass) throws Exception {
        logger.debug("keyTool alias " + alias);
        List<String> argList = new ArrayList(Arrays.asList(args));
        argList.add("-alias");
        argList.add(alias);
        argList.add("-keypass");
        argList.add(keypass);
        KeyTool.main(argList.toArray(new String[argList.size()]));
    }            
}
}}}

We specify the same arguments as we would to <tt>keytool</tt>, but `DualControlReader` will provide a map of multiple key aliases and their secret passwords, for invoking <tt>keytool</tt> for each.

{{{
public class DualControlReader {
    ...
    public static Map<String, String> readDualMap(int inputCount) throws Exception {
        Map<String, String> map = new TreeMap();
        Map<String, String> inputs = readInputMap(inputCount);
        for (String name : inputs.keySet()) {
            for (String otherName : inputs.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    map.put(String.format("%s-%s", name, otherName),
                            String.format("%s-%s", inputs.get(name), inputs.get(otherName)));
                }
            }
        }
        return map;
    }
}}}

where we read input via SSL presumably from multiple admins, each providing a secret, as below. In the above method, for each combination of two admins, we combine their two usernames into a "dual-alias," and similary, the secrets into a "dual-key-password."

{{{
    private final static int PORT = 4444;

    static List<byte[]> readInputs(int inputCount) throws Exception {
        logger.info("waiting for info on SSL port " + PORT);
        return readInputs(DualControlKeyStores.createSSLContext().getServerSocketFactory().
                createServerSocket(PORT), inputCount);
    }
}}}

where we listen on a SSL port i.e. a `ServerSocket` and collate the multiple submissions into a `List`.

{{{
    static List<byte[]> readInputs(ServerSocket serverSocket, int inputCount) throws Exception {
        List<byte[]> list = new ArrayList();
        for (int i = 0; i < inputCount; i++) {
            Socket socket = serverSocket.accept();
            if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                throw new RuntimeException();
            }
            list.add(readBytes(socket.getInputStream()));
            socket.close();
        }
        serverSocket.close();
        return list;
    }
}}}

=== Demo ===

{{{
  javaks -Ddualcontrol.inputs=3 dualcontrol.DualControlKeyTool \
     -alias powerstate2013 -storetype JCEKS -storepass $pass -genseckey -keyalg DESede
}}}

where we use a `JCEKS`-type keystore for a secret key e.g. triple-DES in this case, and "powerstate2013" is our desired alias.  

{{{
  keyTool alias powerstate-2013-brand-evanx
  keyTool alias powerstate-2013-brand-henty
  keyTool alias powerstate-2013-evanx-henty
}}}

Low and behold, these keys do seem to be have been created.

{{{
  keytool -keystore $secstore -storetype JCEKS -storepass $pass -list | grep Entry
}}}

{{{
powerstate2013-brand-henty, 18 Aug 2013, SecretKeyEntry, 
powerstate2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
powerstate2013-brand-evanx, 18 Aug 2013, SecretKeyEntry,
}}}

Actually these keys, are one and the same. However, for each dual-alias, that copy is password-protected using a so-called dual-password i.e. an combination of two passwords, known to no one. 

== DualControlClient == 

In order for admins to submit their secrets to our `DualControlReader` e.g. from a ssh session on the `localhost`, we provide a minimal SSL client as follows.

{{{
public abstract class DualControlClient {
    final static Logger logger = Logger.getLogger(DualControlClient.class);
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        String username = System.console().readLine("DualControl username: ");
        char[] passwd = System.console().readPassword("DualControl password: ");
        write(username + ':'+ new String(passwd));
    }

    public static void write(String data) throws Exception {
        Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                createSocket(HOST, PORT);
        socket.getOutputStream().write(data.getBytes());
        socket.close();
    }
}
}}}
where we concatenate the username and password into a string and send those bytes out the SSL socket to our supposed listening dual-controlled app on port 4444. 

A known-bug is that more Godly sysadmins can socially-engineer other less Godly admins to submit their passwords whilst a malicious server has been implanted by the most Godly one onto that frikking port!

== Conclusion ==

We consider both symmetric and asymmetric ciphers by way of implementing a trivial client and server that mimic how SSL might work. The client uses the server's public key to asymmetrically encrypt and transfer a secret key, which is then used by both sides to encrypt messages using a symmetric cipher. 

== Resources ==

You can browse the code for this exercise at [http://code.google.com/p/vellum/source/browse/#svn/trunk/src/vellumdemo/cryptonomicaldemo here].
