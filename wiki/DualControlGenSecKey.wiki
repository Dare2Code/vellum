#labels Dual Control, Split Knowledge, Key Management, Encryption, PAN, PCI

<h1>Dual Control Key Generation</h1>

We hereby start the new 2013 "Dual Control" quadrilogy, part of the <a href="http://code.google.com/p/vellum">Enigma Posts</a>.

<h4>Problem overview</h4>

Encryption is great for information security and all that. But the problem with encryption is... key management. An analogy often bandied about is that we lock the door but leave the key in the lock. <i>Or under the mat, but that's my personal favourite so ssh-ssh.</i>

The "Payment Card Industry Data Security Standard" (<a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard">PCI DSS</a>) advocates common sense policies for building a secure network and protecting our data. Actually every enterprise should adopt PCI DSS because it's the only and best such thing we got. Although it focusses on credit card numbers (aka <i>Primary Account Numbers</i>, or PANs), it goes without saying that companies in other industries also have sensitive data that people might want to steal, governments even ;)

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

PCI DSS suggests encrypting our data-encryption key (DEK) in order to protect it. Great, we now have a "key-encryption key" (KEK) that requires even more protection ;)

PCI DSS mandates that manual key management requires "split knowledge and dual control" e.g. for key generation and loading. The intent is that no single person can extract the clear-text data. 

The glaring problem is that sysadmins are a single person, with god-like access to all our data, and de facto custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>

<h4>Solution overview</h4>

We'll split the knowledge of the key password between two admins, so it's known to no single person. Clearly dual control by those two admins is then required to load the key.

We propose keeping at least three copies of the same key in our keystore, where each copy is password-protected by a different "split password" pairing. Then if one admin is on vacation or otherwise indisposed, that's OK because we only require two admins to load the key when we restart our app.

<h4><tt>!DualControlGenSecKey</tt></h4>

Step 1 for any data security endeavour is to generate an encryption key, which preferrably no one can pwn, not even root. Whereas <tt>keytool</tt> prompts for a password entered by a single admin, we introduce <tt>!DualControlGenSecKey</tt> to handle multiple password submissions via SSL.

{{{
public class DualControlGenSecKey {
    private int submissionCount;
    private String keyAlias;
    private String keyStoreLocation;
    private String keyStoreType;
    private String keyAlg;
    private int keySize;
    private char[] keyStorePassword;
    private Map<String, char[]> dualPasswordMap;
    private SSLContext sslContext;

    public DualControlGenSecKey(VellumProperties properties, MockableConsole console) {
        this.properties = properties;
        this.console = console;
        submissionCount = properties.getInt("dualcontrol.submissions", 3);
        keyStorePassword = properties.getPassword("storepass", null);
        keyAlias = properties.getString("alias");
    }

    public void init() throws Exception {
        sslContext = DualControlSSLContextFactory.createSSLContext(properties, console);
    }
    ...
}
}}}

where we choose property names similar to <tt>keytool</tt>.

{{{
    public static void main(String[] args) throws Exception {
        DualControlGenSecKey instance = new DualControlGenSecKey(
                new VellumProperties(System.getProperties()), 
                new ConsoleAdapter(System.console()));
        try {
            instance.init();
            instance.call();
        } catch (DualControlException e) {
            instance.console.println(e.getMessage());
        } finally {
            instance.clear();
        }
    }
    ...
}
}}}
where our <tt>main()</tt> method passes <tt>System</tt> properties i.e. <tt>-D</tt> options, and the <tt>System</tt> console for entering the SSL keystore password.

{{{
    public void call() throws Exception {
        keyStoreLocation = properties.getString("keystore");
        if (new File(keyStoreLocation).exists()) {
            throw new Exception("Keystore file already exists: " + keyStoreLocation);
        }
        if (keyStorePassword == null) {
            keyStorePassword = console.readPassword(
                    "Enter passphrase for keystore (%s): ", keyStoreLocation);
            if (keyStorePassword == null) {
                throw new Exception("No keystore passphrase from console");
            }
        }
        KeyStore keyStore = createKeyStore();
        keyStore.store(new FileOutputStream(keyStoreLocation), keyStorePassword);
    }

    public KeyStore createKeyStore() throws Exception {
        String purpose = "new key " + keyAlias;
        return buildKeyStore(
                new DaulControlManager(properties, submissionCount, purpose).
                readDualMap(sslContext));
    }
}}}

where <tt>!DaulControlManager</tt> provides a map of aliases and passwords, composed from submissions via SSL. We pass this <tt>dualPasswordMap</tt> to the <tt>buildKeyStore()</tt> method below.
{{{      
    public KeyStore buildKeyStore(Map<String, char[]> dualPasswordMap) throws Exception {
        keyAlias = properties.getString("alias");
        keyStoreType = properties.getString("storetype");
        keyAlg = properties.getString("keyalg");
        keySize = properties.getInt("keysize");
        KeyGenerator keyGenerator = KeyGenerator.getInstance(keyAlg);
        keyGenerator.init(keySize);
        SecretKey secretKey = keyGenerator.generateKey();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        setEntry(keyStore, secretKey, keyAlias, dualPasswordMap);
        return keyStore;
    }

    private static void setEntry(KeyStore keyStore, SecretKey secretKey,
            String keyAlias, Map<String, char[]> dualPasswordMap) throws Exception {
        KeyStore.Entry entry = new KeyStore.SecretKeyEntry(secretKey);
        for (String dualAlias : dualPasswordMap.keySet()) {
            char[] dualPassword = dualPasswordMap.get(dualAlias);
            String alias = keyAlias + "-" + dualAlias;
            KeyStore.ProtectionParameter prot =
                    new KeyStore.PasswordProtection(dualPassword);
            keyStore.setEntry(alias, entry, prot);
        }
    }
}}}

where for each duo we programmatically create a <tt>!KeyStore</tt> entry containing the same key, but protected by a different split password, i.e. known to no single person :)

In general one might argue that we should not write code per se, but rather tests with accompanying code, hand in glove. Well, we've done that in this case, for a change ;)
{{{
    @Test
    public void testGenKeyStore() throws Exception {
        dualPasswordMap.put("brent-evanx", "bbbb+eeee".toCharArray());
        dualPasswordMap.put("brent-henty", "bbbb+hhhh".toCharArray());
        dualPasswordMap.put("evanx-henty", "eeee+hhhh".toCharArray());
        properties.put("alias", "dek2013");
        properties.put("storetype", "JCEKS");
        properties.put("keyalg", "AES");
        properties.put("keysize", "192");
        DualControlGenSecKey instance = new DualControlGenSecKey();
        KeyStore keyStore = instance.buildKeyStore(properties, dualPasswordMap);
        assertEquals(3, Collections.list(keyStore.aliases()).size());
        assertEquals("dek2013-brent-evanx", Lists.asSortedSet(keyStore.aliases()).first());
        SecretKey key = getSecretKey(keyStore, "dek2013-brent-evanx", "bbbb+eeee".toCharArray());
        assertEquals("AES", key.getAlgorithm());
        assertTrue(Arrays.equals(key.getEncoded(), getSecretKey(keyStore, 
                "dek2013-brent-henty", "bbbb+hhhh".toCharArray()).getEncoded()));
    }
}}}

where we inspect the <tt>!KeyStore</tt> returned by the <tt>buildKeyStore()</tt> method, which is exposed especially for this unit test.

<h4>Usage demo</h4>

Let's run <tt>!DualControlGenSecKey</tt> from the command-line.

{{{
  java -Ddualcontrol.submissions=3 -Ddualcontrol.minPasswordLength=8 \
     -Dkeystore=$keystore -Dstoretype=JCEKS -Dstorepass=$storepass \
     -Dalias=dek2013 -Dkeyalg=AES -Dkeysize=256 \
     dualcontrol.DualControlGenSecKey
}}}

where we use a <tt>JCEKS</tt>-type keystore for our symmetric secret key, generated as 256bit AES, and aliased as "dek2013."

For this example, three admins submit their passwords via SSL sockets where their client cert's <tt>CN</tt> identifies them as <tt>evanx</tt>, <tt>henty</tt> and <tt>brent</tt>. 

{{{
INFO [DaulControlManager] readDualMap submissionCount: 3
INFO [DaulControlManager] readDualMap purpose: new key dek2013
INFO [DaulControlManager] readSubmissions SSL port 4444
INFO [DaulControlManager] Received evanx
INFO [DaulControlManager] Received henty
INFO [DaulControlManager] Received brent
INFO [DaulControlManager] readDualMap dualAlias: brent-evanx
INFO [DaulControlManager] readDualMap dualAlias: brent-henty
INFO [DaulControlManager] readDualMap dualAlias: evanx-henty
INFO [DualControlGenSecKey] alias dek2013-brent-evanx
INFO [DualControlGenSecKey] alias dek2013-brent-henty
INFO [DualControlGenSecKey] alias dek2013-evanx-henty
}}}

We see that <tt>!DualControlGenSecKey</tt> creates secret key entries under the following "dual aliases."

{{{
$ keytool -keystore $keystore -storetype JCEKS -storepass $storepass -list | grep Entry
dek2013-brent-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-brent-evanx, 18 Aug 2013, SecretKeyEntry,
}}}

Actually these three keys are one and the same! However each copy has a different "split password," which is a combination of a pair of personal passwords. Consequently the key password is "known to no single person" as per PCI DSS requirements :)

<h4>Conclusion</h4>

The problem with encryption is secure key management. We shouldn't leave the key under the mat.

PCI requires that "split knowledge and dual control" be used to protect our data-encryption key so that no single person can extract the data in clear-text, not even our most trustworthy employee today, rogue tomorrow.

We present a <tt>!DualControlGenSecKey</tt> utility for generating secret keys that are really secret. We protect the data-encryption keys using password-based encryption, courtesy of <tt>JCEKeyStore</tt>. We enable split knowledge of the key password, so that dual control is required to load the key.

We propose keeping at least three copies of the same key, but where each copy is password-protected by a different pair of admins. Then if one admin is on vacation or otherwise indisposed, that's OK because we only require two admins to load the key when we restart our app.

In the next article in this series, we will present <tt>!DualControlConsole</tt> for submitting split passwords via SSL, and thereafter <tt>!DualControlManager</tt> as used by <tt>!DualControlGenSecKey</tt> above to combine these passwords. We will demonstrate how <tt>!DualControlManager</tt> is similarly used by our app to load a key, with dual control. 

<h4>Coming up</h4>

In "Dual Control Console" we will present <tt>!DualControlConsole</tt> to submit split passwords via SSL - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/DualControlConsole.java"><tt>!DualControlConsole.java</tt></a>

In "Dual Control Key Management" we will present <tt>!DualControlManager</tt> to read split passwords via SSL - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/DualControlManager.java"><tt>!DualControlManager.java</tt></a>

In "Dual Control Mock Console" we will present a unit test orchestrating <tt>!DaulControlManager</tt> and <tt>!DualControlConsole</tt> threads - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/test/dualcontrol/DualControlTest.java"><tt>!DualControlTest.java</tt></a>

In "Dual Control Revoke and Enroll" we will present other tools similar to <tt>!DualControlGenSec</tt>, namely <tt>!DualControlRevoke</tt> and <tt>!DualControlEnroll</tt> to manage admin staff reshuffles - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/DualControlEnroll.java"><tt>!DualControlEnroll.java</tt></a> and <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/DualControlRevoke.java"><tt>!DualControlRevoke.java</tt></a>

In "Dual Control Crypto Server" we implement a dual-controlled crypto server to unburden our apps, simplify key management and enhance security - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/CryptoServer.java"><tt>!CryptoServer.java</tt></a> and its <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/CryptoHandler.java"><tt>!CryptoHandler.java</tt></a>

In "Dual Control Key Protection" we address increased protection against brute-force password attacks e.g. via PBE of the keystore using <tt>PBKDF2</tt> with a high number of iterations, so that the key takes a second or two to recover, rather than half a millisecond - preview <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/JCEKSBruteForceTimer.java"><tt>JCEKSBruteForceTimer.java</tt></a> and <a href="https://code.google.com/p/vellum/source/browse/trunk/src/dualcontrol/RecryptedKeyStores.java"><tt>!RecryptedKeyStores.java</tt></a>

In "Dual Control Key Rotation" we'll address periodic key revision e.g. migrating from a old "dek2013" key a to revised "dek2014" key.

<h4>Further reading</h4>

See an extended preview article: <a href="https://code.google.com/p/vellum/wiki/DualControl">vellum/wiki/DualControl</a>.

<h4>Resources</h4>

You can browse the code for this exercise at <a href="http://code.google.com/p/vellum">code.google.com/vellum</a> in the <a href="https://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fdualcontrol"><tt>dualcontrol</tt></a> package.


<tt><a href="https://twitter.com/evanxsummers" class="twitter-follow-button" data-show-count="false">@evanxsummers</a></tt>
