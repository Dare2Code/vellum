#labels Java, SSL, keytool, KeyStore, TrustManager

<h4>Overview</h4>

We consider a bunch of remote clients connecting to our Java server over SSL sockets. Naturally, we generate a private key for each client, and perhaps import all our clients' self-signed certificates into our server truststore.

In this article, we'll sign the client certificates using a local CA certificate. In this case our truststore contains our CA certificate only. However, our server should somehow support certificate revocation, e.g. so that we can disable access for devices that go amiss.


<h4>SSLContext</h4>

Naturally an <tt>SSLServerSocket</tt> is created using an <tt>SSLContext</tt>, which is initialized via a keystore and a truststore, as in the following example.

{{{
public class LocalCaTest {
    ...
    static void accept(KeyStore keyStore, char[] keyPassword, KeyStore trustStore,
            int port) throws GeneralSecurityException, IOException {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPassword);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("SunX509");
        trustManagerFactory.init(trustStore);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(keyManagerFactory.getKeyManagers(),
                trustManagerFactory.getTrustManagers(), new SecureRandom());
        SSLServerSocket serverSocket = (SSLServerSocket) sslContext.
                getServerSocketFactory().createServerSocket(port);
        try {
            serverSocket.setNeedClientAuth(true);
            handle(serverSocket.accept());
        } finally {
            serverSocket.close();
        }
    }    
}
}}}
where we create an SSL context for our server socket, and accept a client connection.

A keystore contains our asymmetric private key, which naturally is paired with its public key certificate. Moreover, the keystore must contain the certificate chain of that key certificate, through to its root certificate. Indeed we'll see that <tt>keytool</tt> will not allow a signed certificate to be imported unless its parent certificate chain is already present in the keystore.

The truststore contains peer or CA certificates that we trust. Any peer certificate chain that includes a certificate in our truststore, is trusted. That is to say, if our truststore contains a CA certificate, then we trust all certificates issued by that CA.

Since a keystore must contain the certificate chain of the key certificate, and the truststore must not contain certificate chains per se, they differ critically in this respect, and so the keystore should not be misused as the truststore.


<h4>Server certificate signing</h4>

Naturally we create a keystore containing a private key, and its self-signed cert (for starters), using <tt>keytool -genkeypair</tt>.
{{{
$ keytool -keystore server.jks -genkeypair -alias server -dname "CN=server" \
  -keyalg rsa -keysize 2048 -validity 365 -noprompt
}}}
where we specify a validity period of 365 days.

We export a certificate signing request (CSR) as follows.
{{{
$ keytool -keystore server.jks -alias server -certreq -rfc -file server.csr
}}}
Let's create our "local CA" key, which will be used to issue signed certificates.
{{{
$ keytool -keystore ca.jks -genkeypair -alias ca -dname "CN=ca" \
  -keyalg rsa -keysize 2048 -validity 365 -noprompt
}}}
Incidently, our server naturally resides in a DMZ accessible to the Internet, whereas our "CA" key should be isolated on a more secure internal machine.

We can sign the CSR using using Java7's <tt>keytool -gencert</tt>.
{{{
$ keytool -keystore ca.jks -alias ca -gencert -infile server.csr -dname "CN=server" \
    -validity 365 -rfc -outfile server.signed.pem \
    -ext BasicConstraints:critical=ca:false,pathlen:0 \
    -ext KeyUsage:critical=keyEncipherment \
    -ext ExtendedKeyUsage:critical=serverAuth
}}}
where we set X509v3 extensions to restrict the key usage for good measure, as per certificates from a public CA. 

We now wish to import this signed certificate reply into our server keystore. As mentioned earlier, <tt>keytool</tt> will not allow a signed certificate to be imported unless its parent certificate chain is already present in the keystore.
{{{
$ keytool -keystore server.jks -alias server -importcert -file server.signed.pem
Enter keystore password:
keytool error: java.lang.Exception: Failed to establish chain from reply
}}}
where the signed certificate is a so-called "reply" to its certificate signing request.

So we must import the certificate chain in order starting with the root certificate.
{{{
$ keytool -keystore server.jks -alias ca -importcert -file ca.pem
}}}
An "intermediate" certificate would be next, if we have one. Finally we import the signed certificate reply.
{{{
$ keytool -keystore server.jks -alias server -importcert -file server.signed.pem
}}}


<h4>Certificate chain</h4>

We can list the certicate chain as follows.
{{{
$ keytool -keystore server.jks -alias server -list -v
...
Certificate chain length: 2

Certificate[1]:
Owner: CN=server
Issuer: CN=ca

Certificate[2]:
Owner: CN=ca
Issuer: CN=ca
}}}
where we have signed our server certificate with a local CA root certificate. By definition the "root" certificate of a chain is self-signed.


<h4>Server truststore</h4>

Our server truststore will contain our CA certificate which signs our client certs.
{{{
$ keytool -keystore server.trust.jks -alias ca -importcert -noprompt -file ca.pem
}}}

Note that by definition, any remote peer certificate whose chain contains a certificate in the truststore, is trusted. Therefore since each client certificate chain contains our CA certificate (as it root certificate), it will be trusted. In fact, any certificate issued by our CA is trusted, according to this truststore.

<h4>openssl</h4>

We can use <tt>openssl</tt> to connect to the <tt>SSLServerSocket</tt> and inspect its key certificate chain as follows.
{{{
$ openssl s_client -connect localhost:4444
...
Certificate chain
 0 s:/CN=server
   i:/CN=ca
 1 s:/CN=ca
   i:/CN=ca

Acceptable client certificate CA names
/CN=ca
}}}
where the subject and issuer of the two certificates in our key certificate chain are listed, and our server will accept client certificates whose chain includes the CA certificate, i.e. as its root certificate. (If we are using an intermediate CA certificate to sign the client certs, then that would be imported into the truststore rather than the root certificate.)

This demonstrates why the keystore requires a certificate chain, i.e. to send to the peer for authentication. The peer receives the chain, and authenticates it, stopping as soon as it encounters a certificate that it trusts. Therefore the chain for a trusted certificate need not be stored in the truststore, and actually must not be, otherwise we trust <i>any</i> certificate issued by that trusted cert's root CA. For example, if our CA is !GoDaddy.com, that doesn't mean our clients should trust any server with certificate issued by !GoDaddy.com.


<h4>Intermediate CA certificate</h4>

In practice, we might have multiple servers with different sets of clients. So we might generate an intermediate certificate that is used to sign client certificates for a specific server.

{{{
$ keytool -keystore server-ca.jks -genkeypair -noprompt -keyalg rsa -keysize 2048 \
    -alias server-ca -dname "CN=server-ca" -validity 365     
}}}
where this keystore resides on our secure CA server, and not in the DMZ. We might then sign it using our root CA key. 

We can then use this intermediate CA key to sign the client certs for some server. The server's truststore would contain this intermediate CA certificate, and so trust all of its clients. Even if it is not our <i>root</i> CA certificate, since it is used to sign certificates, it is a "CA certificate" nonetheless.

While it is possible to sign client certificates with the server key as its own CA, this resides in the DMZ, which naturally is our least secure zone. If compromised, this key could be used to sign rogue certificates. So we don't store CA keys in our DMZ.


<h4>Serial numbers</h4>

Incidently, <a href="http://www.docjar.org/html/api/sun/security/tools/KeyTool.java.html"><tt>!KeyTool.java</tt></a>, as used by the <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html"><tt>keytool</tt></a> command-line utility, generates a random serial number as follows.
{{{
        info.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(
            new java.util.Random().nextInt() & 0x7fffffff));
}}}

We see that <tt><a href="http://www.docjar.org/html/api/java/security/cert/X509Certificate.java.html">!X509Certificate</a></tt> (implemented by <a href="http://www.docjar.org/html/api/sun/security/x509/X509CertImpl.java.html"><tt>!X509CertImpl</tt></a>) returns a <tt>!BigInteger</tt> for the certificate serial number, which should be unique, and can be used for revocation.

In a later article, we might build a local CA management tool, which uses a sequence number for certs which it generates programmatically and records in an SQL database.


<h4>Revocable SSL contexts</h4>

Ordinarily we create an <tt>SSLContext</tt> as follows.
{{{
public class SSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPassword,
            KeyStore trustStore) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPassword);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("SunX509");
        trustManagerFactory.init(trustStore);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(keyManagerFactory.getKeyManagers(),
                trustManagerFactory.getTrustManagers(), new SecureRandom());
        return sslContext;
    }
}
}}}
where we provide the keystore and truststore for this SSL context, which can be used to create an <tt>SSLServerSocket</tt>, or client <tt>SSLSocket</tt>.

Since we wish to support a local CA for client certificates, we should enable local certificate revocation in order to retain access control. For convenience, we'll revoke certificates by their common name (CN), which must be unique.

So we create an <tt>SSLContext</tt> with a set of revoked names, as follows.
{{{
public class RevocableNameSSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPass,
            KeyStore trustStore, Set<String> revokedNames) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPass);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        TrustManager revocableTrustManager = new RevocableTrustManager(
                KeyStores.findSoleTrustedCertificate(keyStore),
                KeyStores.findX509TrustManager(trustStore),
                revokedNames);
        sslContext.init(keyManagerFactory.getKeyManagers(),
                new TrustManager[] {revocableTrustManager},
                new SecureRandom());
        return sslContext;
    }
}
}}}
where we initialise a custom <tt>!RevocableTrustManager</tt> with our client certificate issuer and a set of revoked names.
{{{
public class RevocableTrustManager implements X509TrustManager {
    X509Certificate issuerCertificate;
    X509TrustManager delegate;
    Set<String> revokedNames;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        if (certs.length < 2) {
            throw new CertificateException("Invalid cert chain length");
        }
        if (!certs[0].getIssuerX500Principal().equals(
                issuerCertificate.getSubjectX500Principal())) {
            throw new CertificateException("Untrusted issuer");
        }
        if (!Arrays.equals(certs[1].getPublicKey().getEncoded(),
                issuerCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Untrusted issuer public key");
        }
        if (revokedNames.contains(Certificates.getCN(certs[0].getSubjectDN()))) {
            throw new CertificateException("Certificate CN revoked");
        }
        delegate.checkClientTrusted(certs, authType);
    }
}
}}}
where we check that the client certificate is issued by our CA, and not revoked. Finally, we delegate to the standard <a href="http://www.docjar.org/html/api/javax/net/ssl/X509TrustManager.java.html"><tt>!X509TrustManager</tt></a> (implemented by <a href="http://www.docjar.org/html/api/sun/security/ssl/X509TrustManagerImpl.java.html"><tt>!X509TrustManagerImpl</tt></a>) for good measure, e.g. to validate the certificate chain, expiry dates and what not (using <a href="http://www.docjar.org/html/api/sun/security/validator/PKIXValidator.java.html"><tt>PKIXValidator</tt></a>).

Since we use this trust manager on the server to validate clients, we know its <tt>checkServerTrusted()</tt> method is not needed.
{{{
    @Override
    public void checkServerTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        throw new CertificateException("Server authentication not supported");
    }    
}}}

<h4>Dynamic revocation</h4>

The set of revoked certificates' identifiers might be read from a file, URL or database. This could be a <tt>synchronized</tt> <tt>Set</tt> that can be updated concurrently, and so enables a dynamic truststore, which we test as follows.
{{{
public class LocalCaTest {
    ...
    private void testDynamicNameRevocation(KeyStore serverKeyStore, KeyStore serverTrustStore,
            KeyStore clientKeyStore, KeyStore clientTrustStore, String revokedName) 
            throws Exception {
        Set<String> revokedNames = new ConcurrentSkipListSet();
        SSLContext serverSSLContext = RevocableNameSSLContexts.create(
                serverKeyStore, pass, serverTrustStore, revokedNames);
        SSLContext clientSSLContext = SSLContexts.create(clientKeyStore, pass, clientTrustStore);
        ServerThread serverThread = new ServerThread();
        try {
            serverThread.start(serverSSLContext, port, 2);
            Assert.assertNull(ClientThread.connect(clientSSLContext, port));
            Assert.assertNull(serverThread.getErrorMessage());
            revokedNames.add(revokedName);
            clientSSLContext = SSLContexts.create(clientKeyStore, pass, clientTrustStore);
            String errorMessage = ClientThread.connect(clientSSLContext, port);
            Assert.assertEquals("java.security.cert.CertificateException: " + 
                    "Certificate CN revoked", serverThread.getErrorMessage());
            Assert.assertNotNull(errorMessage);
        } finally {
            serverThread.close();
            serverThread.join(1000);
        }
    }
    ...
}}}
where we create a concurrent <tt>Set</tt> for the revoked certificates, and revoke a client certificate after the server has been started. Before the certificate is revoked, the connection should succeed, and afterwards it should fail. 

Incidently, we find that the client session is cached for the SSL context, and so we recreate the <tt>clientSSLContext</tt> instance in our test above. This forces re-initialisation of the client session, and so re-authentication by the server, so that our trust manager is actually invoked and rejects our newly revoked certificate. Perhaps the reader can advise how to disable this client session caching for our unit test?

Our test connects to the server socket as follows.
{{{
    static String connect(SSLContext context, int port) 
            throws GeneralSecurityException, IOException {
        SSLSocket socket = (SSLSocket) context.getSocketFactory().
                createSocket("localhost", port);
        try {
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF("clienthello");
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            Assert.assertEquals("serverhello", dis.readUTF());
            return null;
        } catch (Exception e) {
            return e.getMessage();
        } finally {
            socket.close();
        }
    }
}}}
where we return the error message, otherwise <tt>null</tt>.


<h4>Client keystore</h4>

For example, let's create a private SSL keystore for a test client named "evanx" as follows.
{{{
$ keytool -keystore evanx.jks -genkeypair -keyalg rsa -keysize 2048 -validity 365 \
    -alias evanx -dname "CN=evanx"
}}}
 
We export our certificate as follows.
{{{
$ keytool -keystore evanx.jks -alias evanx -exportcert -rfc
}}}
We cut and paste the exported PEM text into a file, which we can inspect using <tt>openssl</tt> as follows.
{{{
$ openssl x509 -text -in evanx.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1380030508 (0x5241982c)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: CN=evanx
        Validity
            Not Before: Sep 24 13:48:28 2013 GMT
            Not After : Sep 24 13:48:28 2014 GMT
        Subject: CN=evanx
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
}}}
Typically we might import the client's self-signed certificate into our server truststore, as follows.
{{{
$ keytool -keystore server.trust.jks -alias evanx -importcert -file evanx.pem
}}}
Similarly, our server's certificate (perhaps self-signed) is imported into this client's truststore.


<h4>Client certificate signing</h4>

We export a certificate signing request (CSR) to be signed by our local CA.
{{{
$ keytool -keystore evanx.jks -alias evanx -certreq
}}}
We cut and paste the output PEM text into a CSR file, and use Java7's keytool to sign this CSR, using its <tt>-gencert</tt> option, which by the way is not available in earlier JRE's.
{{{
$ keytool -keystore ca.jks -gencert -validity 365 -rfc \
    -dname "CN=evanx" -infile evanx.csr -outfile evanx.signed.pem \
    -ext BasicConstraints:critical=ca:false,pathlen:0 \
    -ext KeyUsage:critical=digitalSignature \
    -ext ExtendedKeyUsage:critical=clientAuth
}}}
where we specify an unchanged DN and validity period for the newly signed certificate. We might add some extensions for good measure, i.e. to restrict key usage.

We can inspect the cert using <tt>openssl</tt>.
{{{
$ openssl x509 -text -in evanx.signed.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 448957773 (0x1ac28d4d)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=ca
        Validity
            Not Before: Oct 16 20:02:24 2013 GMT
            Not After : Jul 11 20:02:24 2016 GMT
        Subject: CN=evanx
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
}}}
We see that the X509v3 extensions are set as follows.
{{{

            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Extended Key Usage: critical
                TLS Web Client Authentication
            X509v3 Key Usage: critical
                Digital Signature
}}}
Compare these settings to certificate bought from !GoDaddy.com:
{{{
        X509v3 extensions:
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
}}}
where we find that the "Digital Signature" usage is required for client authentication, and "Key Encipherment" is used for server authentication.

Since the keystore requires its key certificate chain to be imported in the correct order starting with the root cert, we import the CA cert first, and then our signed cert.
{{{
$ keytool -keystore evanx.jks -importcert -noprompt \
    -file ca.pem -alias ca
Enter keystore password: 
Certificate was added to keystore

$ keytool -keystore evanx.jks -importcert -noprompt \
    -file evanx.signed.pem -alias evanx
Enter keystore password: 
Certificate reply was installed in keystore
}}}
Otherwise if the parent chain is not present, we're balked by the following <tt>keytool</tt> error.
{{{
keytool error: java.lang.Exception: Failed to establish chain from reply
}}}

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

Incidently, in a follow-up article we will create keystores programmatically for our unit tests, taking cues from <a href="http://www.docjar.org/html/api/sun/security/tools/KeyTool.java.html"><tt>!KeyTool</tt></a>, and emulating the manual procedure presented here.


<h4>Client certificate management</h4>

Clearly a certificate with a duplicate CN impersonates the original certificate with that CN. So when issuing a client certificate, we must take care to ensure the uniqueness of the CN, and should add the certificate (or at least its unique identifier) to a registry of some sort. 

In order to review access, we clearly require a perfect record of all issued certificates. If a certificate is signed but not recorded, or its record is deleted, our server is forever vulnerable to that rogue certificate. 

We might record our signed certs into a keystore file as follows.
{{{
$ keytool -keystore server.issued.jks -importcert -alias evanx -file evanx.pem 
Certificate was added to keystore
}}}
where this is not a truststore per se, but just a database of issued certificates. 

Interestingly, in trying to avoid a truststore containing all our client certificates, we have nevertheless ended up with one! 


<h4>Self-signed client certificates</h4>

If our local CA is compromised by a breach, or abused by a rogue administrator, there is a risk of rogue certificates being issued, of which we have no record. So we might prefer self-signed client certificates which are explicitly imported into our server truststore, where they can be reviewed. 

However, self-signed client keys are effectively CA certificates, and clearly rogue certificates can be created using compromised client keys, e.g. using <tt>keytool -gencert</tt>. To protect the server against such rogue certificates, we might use an explicit trust manager as below, where only leaf certificates explicitly listed in the truststore are trusted.
{{{
public class ExplicitTrustManager implements X509TrustManager {
    Map<String, X509Certificate> certificateMap = new HashMap();
    X509TrustManager delegate;
    
    public ExplicitTrustManager(KeyStore trustStore) 
        throws GeneralSecurityException {
        this.delegate = KeyStores.findX509TrustManager(trustStore);
        for (String alias: Collections.list(trustStore.aliases())) {
            certificateMap.put(alias, (X509Certificate) 
                    trustStore.getCertificate(alias));
        }
    }
    ...
}}}
where we build a map of the certificates in our truststore. 

We validate peer certificate chains as follows.
{{{    
    private void checkTrusted(X509Certificate[] chain) 
            throws CertificateException {
        if (chain.length != 1) {
            throw new CertificateException("Invalid cert chain length");
        }
        X509Certificate trustedCertificate = certificateMap.get(
                X509Certificates.getCN(chain[0].getSubjectDN()));
        if (trustedCertificate == null) {
            throw new CertificateException("Untrusted peer certificate");
        }
        if (!Arrays.equals(chain[0].getPublicKey().getEncoded(),
                trustedCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Invalid peer certificate");
        }
    }
}}}
where we check that the first cert in the chain sent by the peer, is contained in our map.

We can use this trust manager on the server and client.
{{{
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        checkTrusted(chain);
        delegate.checkClientTrusted(chain, authType);
    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        checkTrusted(chain);
        delegate.checkServerTrusted(chain, authType);
    }    
}}}

<h4>Conclusion</h4>

We can sign client certificates using a local CA root certificate. However, we should then support certificate revocation, e.g. to disable certificates for devices that have gone amiss. So we introduce a custom SSL trust manager to support a local revocation list.

<img align="right" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

Naturally, our SSL server resides in the DMZ, whereas we want to isolate our local CA on a secure internal server. Even so, we discuss the risk of rogue certificates signed by our CA, and argue that importing each client certificate into the truststore enables us to review access.

The keystore naturally contains the server certificate, and so if this is misused as the truststore, then a rogue certificate can be created by signing it with the server key.

The keystore must contain the certificate chain of the key certificate, whereas the truststore must not contain the certificate chains of its trusted certificates. When using a public CA, the keystore will contain that CA's root certificate, and if misused as the truststore, then <i>any</i> certificate issued by that public CA would be trusted.

We note that self-signed client certificates are effectively CA certificates, and so can be used to create rogue certificates. So we present a custom trust manager that treats these as leaf certificates rather than root CA certificates.


<h4>Furthermore</h4>

We'll delve into the unit testing of our custom trust manager in a follow-up article. Thereafter, we might implement a local CA management tool that records issued certificates, and supports standard CRLs, or ideally a local CA server that supports the <a href="http://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">Online Certificate Status Protocol</a>.

<h4>Resources</h4>

You can browse the code for this exercise on <a href="https://code.google.com/p/vellum">code.google.com/vellum</a>.

<h4>Other reading</h4>

Also relating to Java crypto in this blog: <a href="https://weblogs.java.net/blog/evanx/archive/2013/01/24/password-salt">Password Salt</a> for secure passwords; and leveraging the <a href="https://weblogs.java.net/blog/evanx/archive/2012/11/07/google-authenticator-thus-enabled">Google Authenticator</a> mobile app for multi-factor authentication for your own sites.

