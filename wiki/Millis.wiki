
November 2012

DRAFT

Isn't <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html">!TimeUnit</a> the best thing since sliced bread?! Indeed anything and everything from Doug Lea is always thus :)

That aside, for the purposes of some [Timestamped Timestamped] thingies with <tt>millis</tt> since the Epoch, we find ourselves cobbling together a <tt>Millis</tt> util class.

{{{
public class Millis {
    
    public static long elapsedMillis(long startMillis) {
        return System.currentTimeMillis() - startMillis;
    }

    public static boolean isElapsed(long startMillis, long millis) {
        return (System.currentTimeMillis() - startMillis) > millis;
    }

    public static boolean isElapsed(Date startTime, long millis) {
        return elapsedMillis(startTime) > millis;
    }

    public static long elapsedMillis(Date startTime) {
        if (startTime == null) return System.currentTimeMillis();
        return System.currentTimeMillis() - startTime.getTime();
    }

    public static long getIntervalMillis(Date from, Date to) {
        return Math.abs(to.getTime() - from.getTime());
    }
    ...
}}}

Very lazy stuff. 

Before we carry on, as a general caution, be aware of what <i>millis</i> you are playing around with. Is it a time interval between two events, or the time of an event? 

Also there is a difference between the time of an event, and the time of day of an event, as seen on someone's clock. The time of an event, measured as the number of millis since the Epoch, is absolute, but the time of that event on the clock is relative to the !TimeZone in which that clock resides. A clock might reside on the server, or on a client, which are oftimes in different time zones. 

Time without time zone is like measurement without units. It's not rocket science, but it's bound to end in disaster, especially in rocket science!

<h4>Time conversion</h4>

Of course we often want to convert to and from millis.

{{{ 
    public static long toSeconds(long millis) {
        return millis/1000;
    }

    public static long toMinutes(long millis) {
        return millis/1000/60;
    }

    public static long toHours(long millis) {
        return millis/1000/60/60;
    }

    public static long toDays(long millis) {
        return millis/1000/60/60/24;
    }
    
    public static long fromSeconds(long seconds) {
        return seconds*1000;
    }

    public static long fromMinutes(long minutes) {
        return minutes*60*1000;
    }

    public static long fromHours(long hours) {
        return hours*60*60*1000;
    }
    
    public static long fromDays(long days) {
        return days*24*60*60*1000;
    }
}}}

As i was saying, it's exactly rocket science - but when rocket scientists get these wrong, their rockets tend to explode.

We roll in a <tt>format()</tt> method to handle zero values, otherwise we see zero timestamps formatted like <tt>"00:02:00"</tt> which actually indicates our default time zone e.g. GMT+02. Recall that at the moment of time of that UNIX Epoch back in the early 70s, it was only actually 00:00 up in Greenwich. So for most all of us, the time of day of the Epoch was not even zero, which is a bit disappointing, no?

{{{       
    public static String formatTimeSeconds(long millis) {
        if (millis == 0) return "00:00:00";
        return DefaultDateFormats.timeSecondsFormat.format(new Date(millis));
    }

    public static String formatTimeMillis(long millis) {
        if (millis == 0) return "00:00:00,000";
        return DefaultDateFormats.timeMillisFormat.format(new Date(millis));
    }
}}}

Beware that this only works for intervals - or for the time, but only then in the same time zone where this time was measured e.g. via <tt>System.currentTimeMillis()</tt>. 

In a follow-up article we absolutely must delve into <tt>!TimeZone</tt> and <tt>Calendar</tt> and its impact and implications vis-a-vis the <tt>Date</tt> and <tt>Millis</tt> util.

For the parsing of intervals.
{{{
    public static Long parseInterval(String string) {
        int index = string.indexOf(" ");
        if (index > 0) {
            return TimeUnit.valueOf(string.substring(index + 1)).toMillis(Long.parseLong(string.substring(0, index)));
        } else if (string.length() >= 2 &&
                Character.isLowerCase(string.charAt(string.length() - 1)) && 
                Character.isDigit(string.charAt(string.length() - 2))) {            
            long value = Long.parseLong(string.substring(0, string.length() - 1));    
            if (string.endsWith("d")) {
                return TimeUnit.DAYS.toMillis(value);
            } else if (string.endsWith("h")) {
                return TimeUnit.HOURS.toMillis(value);
            } else if (string.endsWith("m")) {
                return TimeUnit.MINUTES.toMillis(value);
            } else if (string.endsWith("s")) {
                return TimeUnit.SECONDS.toMillis(value);
            }
        }  
        throw new ParseRuntimeException(string);
    }    
}
}}}
where this is especially convenient for configuration settings of time intervals e.g.

{{{
  <parameter name="interval" value="60s"/>
}}}

or if we configure our appllication using JSON,
{{{
{ 
  ...
  "interval" : "12h";
}
}}}

or via a database table (my personal favourite),

{{{
  insert into config (name, value) values ('interval', '1d'); 
}}}


or even a home-grown file-based configuration utility, which we don't necessarily recommend but will nonetheless introduce in another article :)

{{{
Config default {
  ...
  interval: 60s
}
}}}

<h4>Safe date format</h4>

When someone once told me that <a href="http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"><tt>!SimpleDateFormat</tt></a> is not thread-safe, at some stage we incorporated a trivial <tt>synchronized</tt> <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/SafeDateFormat.java">wrapper</a> for it - athough we should be using Apache Commons <a href="http://commons.apache.org/lang/api-2.5/org/apache/commons/lang/time/FastDateFormat.html"><tt>FastDateFormat</tt></a>, hey?

{{{
public class SafeDateFormat {

   SimpleDateFormat dateFormat;
   String pattern;

   public SafeDateFormat(String pattern) {
      this.pattern = pattern;
      dateFormat = new SimpleDateFormat(pattern);
   }

   public String getPattern() {
      return pattern;
   }

   public synchronized String format(Date date) {
      if (date == null) {
         return "";
      }
      return dateFormat.format(date);
   }

   public synchronized Date parse(String string){
       return parse(string, null);
       
   }
   
   public synchronized Date parse(String string, Date defaultValue){
      if (string == null || string.isEmpty()) {
         return defaultValue;
      }
      if (string.length() > pattern.length()) {
          string = string.substring(0, pattern.length());
      }
        try {
            return dateFormat.parse(string);
        } catch (ParseException e) {
            throw new ParseRuntimeException(string, e);
        }
   }
}
}}}
where this <tt>parse()</tt> truncates the timestamp string to the length of the pattern we are trying to parse.

We use the following default date and timestamp formats, just like our database.
{{{
public class DefaultDateFormats {
    public static final SafeDateFormat dateFormat = new SafeDateFormat("yyyy-MM-dd");
    public static final SafeDateFormat timestampFormat = new SafeDateFormat("yyyy-MM-dd HH:mm:ss,SSS");
    public static final SafeDateFormat timeFormat = new SafeDateFormat("HH:mm:ss,SSS");
}
}}}

<h4>Conclusion</h4>

In this [Timestamped Timestamped] series, we'll sometimes make use of a <tt>Millis.java</tt> convenience class which is presented here.

There is not to say we don't love !TimeUnit, because we absolutely do! 

We use a trivial !SimpleDateFormat wrapper, although we should definitely try Apache's !FastDateFormat rather.

We introduce some parsing for intervals in a convenient format e.g. <tt>4s, 2h, 1d,</tt> especially for nice readable configuration settings.

<h4>Further reading</h4>

We haven't even started on <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html"><tt>!TimeZone</tt></a> here - but we must! 

And then of course there's <a href="http://threeten.sourceforge.net/apidocs-2012-10-25/">JSR 310</a>, which we should probably be using rather than anything else, hey?

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i collate these articles and their code - e.g. see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/Millis.java"><tt>Millis.java</tt></a> class.