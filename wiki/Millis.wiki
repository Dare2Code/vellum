
November 2012

DRAFT

Isn't <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html">!TimeUnit</a> the best thing since sliced bread?! Indeed anything and everything from Doug Lea is always thus :)

Having said that, for the purposes of some [Timestamped Timestamped] thingies, for handling <tt>millis</tt> since the Epoch, we find ourselves introducing a <tt>Millis</tt> util class.

{{{
public class Millis {
    
    public static boolean isElapsed(long startMillis, long millis) {
        return (System.currentTimeMillis() - startMillis) > millis;
    }

    public static boolean isElapsed(Date startTime, long millis) {
        return elapsedMillis(startTime) > millis;
    }
   
    public static long elapsedMillis(Date startTime) {
        long currentMillis = System.currentTimeMillis();
        if (startTime == null) return currentMillis;
        return currentMillis - startTime.getTime();
    }

    public static long getAbsIntervalMillis(Date from, Date to) {
        return Math.abs(to.getTime() - from.getTime());
    }
    ...
}}}

Elementary stuff for lazy programmers :)

Of course we often want to convert to and from millis.

{{{ 
    public static long toSeconds(long millis) {
        return millis/1000;
    }

    public static long toMinutes(long millis) {
        return millis/1000/60;
    }

    public static long toHours(long millis) {
        return millis/1000/60/60;
    }

    public static long toDays(long millis) {
        return millis/1000/60/60/24;
    }
    
    public static long fromSeconds(long seconds) {
        return seconds*1000;
    }

    public static long fromMinutes(long minutes) {
        return minutes*60*1000;
    }

    public static long fromHours(long hours) {
        return hours*60*60*1000;
    }
    
    public static long fromDays(long days) {
        return days*24*60*60*1000;
    }
}}}

We handle formatting to handle zero values.

{{{       
    public static String formatTime(long millis) {
        if (millis == 0) return "00:00:00";
        return DateFormats.timeFormat.format(new Date(millis));
    }

    public static String formatTimestamp(long millis) {
        if (millis == 0) return "00:00:00,000";
        return DateFormats.timestampFormat.format(new Date(millis));
    }
}}}

where in the case of time of day, this only works for the default time zone!

And in parsing,

{{{
    public static Long parseInterval(String string) {
        int index = string.indexOf(" ");
        if (index > 0) {
            return TimeUnit.valueOf(string.substring(index + 1)).toMillis(Long.parseLong(string.substring(0, index)));
        } else if (string.length() >= 2 &&
                Character.isLowerCase(string.charAt(string.length() - 1)) && 
                Character.isDigit(string.charAt(string.length() - 2))) {            
            long value = Long.parseLong(string.substring(0, string.length() - 1));    
            if (string.endsWith("d")) {
                return TimeUnit.DAYS.toMillis(value);
            } else if (string.endsWith("h")) {
                return TimeUnit.HOURS.toMillis(value);
            } else if (string.endsWith("m")) {
                return TimeUnit.MINUTES.toMillis(value);
            } else if (string.endsWith("s")) {
                return TimeUnit.SECONDS.toMillis(value);
            }
        }  
        throw new ParseRuntimeException(string);
    }    
}
}}}

where this supports some convenient configuration of time intervals e.g.

{{{
  <parameter name="interval" value="60s"/>
}}}

Or

{{{
  insert into config (name, value) values ('interval', '1d'); 
}}}

Or 

{{{
{ 
  ...
  "interval" : "12h";
}
}}}

Or even a home-grown file-based configuration utility, which we don't necessarily recommend but will nevertheless introduce next month in another article :)

{{{
Config default {
  ...
  interval: 60s
}
}}}

<h4>Safe date format</h4>

Incidently, since someone once told us that <a href="http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"><tt>!SimpleDateFormat</tt></a> is not thread-safe, we introduce a <tt>synchronized</tt> <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/SafeDateFormat.java">wrapper</a> for it - athough we should probably be using Apache Commons <a href="http://commons.apache.org/lang/api-2.5/org/apache/commons/lang/time/FastDateFormat.html"><tt>FastDateFormat</tt></a>!?

{{{
public class SafeDateFormat {

   SimpleDateFormat dateFormat;
   String pattern;

   public SafeDateFormat(String pattern) {
      this.pattern = pattern;
      dateFormat = new SimpleDateFormat(pattern);
   }

   public String getPattern() {
      return pattern;
   }

   public synchronized String format(Date date) {
      if (date == null) {
         return "";
      }
      return dateFormat.format(date);
   }

   public synchronized Date parse(String string){
       return parse(string, null);
       
   }
   
   public synchronized Date parse(String string, Date defaultValue){
      if (string == null || string.isEmpty()) {
         return defaultValue;
      }
      if (string.length() > pattern.length()) {
          string = string.substring(0, pattern.length());
      }
        try {
            return dateFormat.parse(string);
        } catch (ParseException e) {
            throw new ParseRuntimeException(string, e);
        }
   }
}
}}}

<h4>Default date formats</h4>

Just for completeness, here below find the default date and time formats we like to use.

{{{
public class DateFormats {

    public static final String millisTimestampPattern = "yyyy-MM-dd HH:mm:ss,SSS";
    public static final String millisTimePattern = "HH:mm:ss,SSS";
    public static final SafeDateFormat dateFormat = new SafeDateFormat("yyyy-MM-dd");
    public static final SafeDateFormat shortDateFormat = new SafeDateFormat("yyMMdd");
    public static final SafeDateFormat millisTimestampFormat = new SafeDateFormat(millisTimestampPattern);
    public static final SafeDateFormat millisTimeFormat = new SafeDateFormat(millisTimePattern);
    public static final SafeDateFormat timestampFormat = millisTimestampFormat;
    public static final SafeDateFormat timeFormat = new SafeDateFormat("HH:mm:ss");
    public static final SafeDateFormat shortTimeFormat = new SafeDateFormat("HH:mm");

    public static String formatTime(long millis) {
        if (millis == 0) return "";
        return millisTimeFormat.format(new Date(millis));
    }
    
    public static Date parse(SafeDateFormat dateFormat, String string) {
        return dateFormat.parse(string, null);
    }

    public static Date parseTimestampMillis(String string) {
        SafeDateFormat format = DateFormats.millisTimestampFormat;
        if (string.length() > format.getPattern().length()) {
            string = string.substring(0, format.getPattern().length());
        }
        return parse(format, string);
    }

    public static Date parseTimestamp(String string) {
        SafeDateFormat format = DateFormats.timestampFormat;
        if (string.length() > format.getPattern().length()) {
            string = string.substring(0, format.getPattern().length());
        }
        return parse(format, string);
    }

    public static Date parseDate(String string) {
        if (string.length() > DateFormats.timestampFormat.getPattern().length()) {
            string = string.substring(0, DateFormats.timestampFormat.getPattern().length());
        }
        if (string.length() == DateFormats.timestampFormat.getPattern().length()) {
            int index = string.indexOf(".");
            if (index == string.length() - 4) {
                string = string.substring(0, index) + "," + string.substring(index + 1);
            }
            return parse(DateFormats.timestampFormat, string);
        }
        return parse(DateFormats.dateFormat, string);
    }
}
}}}

where the parsing considers the length of the string to decide which format to employ.

<h4>Calendars</h4>

Which brings us to our <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/util/Calendars.java"><tt>Calendars</tt></a> util class.

{{{
public class Calendars {

    public static Calendar newCalendar(Date date) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar;
    }

    public static Date nextDay(Date date) {
        Calendar calendar = newCalendar(date);
        calendar.add(Calendar.DATE, 1);
        return calendar.getTime();
    }

    public static Calendar newCalendar(long time) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(new Date(time));
        return calendar;
    }

    public static int getHourOfDay(Date date) {
        return newCalendar(date).get(HOUR_OF_DAY);
    }

    public static int getMinute(Date date) {
        return newCalendar(date).get(MINUTE);
    }

    public static void setTime(Calendar calendar, int hour, int minute, int second) {
        calendar.set(HOUR_OF_DAY, hour);
        calendar.set(MINUTE, minute);
        calendar.set(SECOND, second);
        calendar.set(MILLISECOND, 0);        
    }

    public static int getCurrentYear() {
        Calendar calendar = new GregorianCalendar();
        return calendar.get(Calendar.YEAR);
    }
    ...
}
}}}

where we haven't even started on <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html"><tt>!TimeZone</tt></a> - which we'll leave a proper discussion for another day :)

And then of course there's <a href="http://threeten.sourceforge.net/apidocs-2012-10-25/">JSR 310</a>, which we should probably be using rather than anything else?!

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - in particular see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/Millis.java"><tt>Millis.java</tt></a> class.