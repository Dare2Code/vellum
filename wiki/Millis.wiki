

DRAFT

Isn't <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html">!TimeUnit</a> the best thing since sliced bread?! Indeed anything and everything from Doug Lea is always thus :)

Having said that, for the purposes of some [Timestamped Timestamped] thingies, for handling <tt>millis</tt> since the Epoch, we find ourselves introducing a <tt>Millis</tt> util class.

{{{
public class Millis {
    
    public static boolean isElapsed(long startMillis, long millis) {
        return (System.currentTimeMillis() - startMillis) > millis;
    }

    public static boolean isElapsed(Date startTime, long millis) {
        return elapsedMillis(startTime) > millis;
    }
   
    public static long elapsedMillis(Date startTime) {
        long currentMillis = System.currentTimeMillis();
        if (startTime == null) return currentMillis;
        return currentMillis - startTime.getTime();
    }

    public static long getAbsIntervalMillis(Date from, Date to) {
        return Math.abs(to.getTime() - from.getTime());
    }
    ...
}}}

Elementary stuff for lazy programmers :)

Of course we often want to convert to and from millis.

{{{ 
    public static long toSeconds(long millis) {
        return millis/1000;
    }

    public static long toMinutes(long millis) {
        return millis/1000/60;
    }

    public static long toHours(long millis) {
        return millis/1000/60/60;
    }

    public static long toDays(long millis) {
        return millis/1000/60/60/24;
    }
    
    public static long fromSeconds(long seconds) {
        return seconds*1000;
    }

    public static long fromMinutes(long minutes) {
        return minutes*60*1000;
    }

    public static long fromHours(long hours) {
        return hours*60*60*1000;
    }
    
    public static long fromDays(long days) {
        return days*24*60*60*1000;
    }
}}}

And formatting.

{{{       
    public static String formatTime(long millis) {
        if (millis == 0) return "00:00:00";
        return DateFormats.timeFormat.format(new Date(millis));
    }

    public static String formatTimestamp(long millis) {
        if (millis == 0) return "00:00:00,000";
        return DateFormats.timestampFormat.format(new Date(millis));
    }
}}}

In parsing, we get a bit more funky.

{{{
    public static Long parse(String string) {
        int index = string.indexOf(" ");
        if (index > 0) {
            return TimeUnit.valueOf(string.substring(index + 1)).toMillis(Long.parseLong(string.substring(0, index)));
        } else if (string.length() >= 2 &&
                Character.isLowerCase(string.charAt(string.length() - 1)) && 
                Character.isDigit(string.charAt(string.length() - 2))) {            
            long value = Long.parseLong(string.substring(0, string.length() - 1));    
            if (string.endsWith("d")) {
                return TimeUnit.DAYS.toMillis(value);
            } else if (string.endsWith("h")) {
                return TimeUnit.HOURS.toMillis(value);
            } else if (string.endsWith("m")) {
                return TimeUnit.MINUTES.toMillis(value);
            } else if (string.endsWith("s")) {
                return TimeUnit.SECONDS.toMillis(value);
            }
        }  
        throw new ParseRuntimeException(string);
    }    
}
}}}

where this supports some convenient options for configuration of time intervals e.g.

{{{
  <parameter name="interval" value="60s"/>
}}}

Or

{{{
  insert into config (name, value) values ('interval', '60s'); 
}}}

Or 

{{{
{ 
  ...
  "interval" : "60s";
}
}}}

Or even a home-grown file-based configuration util which we'll introduce next time :)

{{{
Config default {
  ...
  interval: 60s
}}}

<h4>Safe date format</h4>

Incidently, since someone once told us that <tt>SimpleDateFormat</tt> is not thread-safe, we introduce a <tt>synchronized</tt> wrapper for it.

{{{
public class SafeDateFormat {

   SimpleDateFormat dateFormat;
   String pattern;

   public SafeDateFormat(String pattern) {
      this.pattern = pattern;
      dateFormat = new SimpleDateFormat(pattern);
   }

   public String getPattern() {
      return pattern;
   }

   public synchronized String format(Date date) {
      if (date == null) {
         return "";
      }
      return dateFormat.format(date);
   }

   public synchronized Date parse(String string){
       return parse(string, null);
       
   }
   
   public synchronized Date parse(String string, Date defaultValue){
      if (string == null || string.isEmpty()) {
         return defaultValue;
      }
      if (string.length() > pattern.length()) {
          string = string.substring(0, pattern.length());
      }
        try {
            return dateFormat.parse(string);
        } catch (ParseException e) {
            throw new ParseRuntimeException(string, e);
        }
   }
}
}}}

<h4>Default date formats</h4>

Just for completeness, here below find the default date and time formats we like to use.

{{{
public class DateFormats {

    public static final String millisTimestampPattern = "yyyy-MM-dd HH:mm:ss,SSS";
    public static final String millisTimePattern = "HH:mm:ss,SSS";
    public static final SafeDateFormat dateFormat = new SafeDateFormat("yyyy-MM-dd");
    public static final SafeDateFormat shortDateFormat = new SafeDateFormat("yyMMdd");
    public static final SafeDateFormat millisTimestampFormat = new SafeDateFormat(millisTimestampPattern);
    public static final SafeDateFormat millisTimeFormat = new SafeDateFormat(millisTimePattern);
    public static final SafeDateFormat timestampFormat = millisTimestampFormat;
    public static final SafeDateFormat timeFormat = new SafeDateFormat("HH:mm:ss");
    public static final SafeDateFormat shortTimeFormat = new SafeDateFormat("HH:mm");

    public static String formatTime(long millis) {
        if (millis == 0) return "";
        return millisTimeFormat.format(new Date(millis));
    }
    
    public static Date parse(SafeDateFormat dateFormat, String string) {
        return dateFormat.parse(string, null);
    }

    public static Date parseTimestampMillis(String string) {
        SafeDateFormat format = DateFormats.millisTimestampFormat;
        if (string.length() > format.getPattern().length()) {
            string = string.substring(0, format.getPattern().length());
        }
        return parse(format, string);
    }

    public static Date parseTimestamp(String string) {
        SafeDateFormat format = DateFormats.timestampFormat;
        if (string.length() > format.getPattern().length()) {
            string = string.substring(0, format.getPattern().length());
        }
        return parse(format, string);
    }

    public static Date parseDate(String string) {
        if (string.length() > DateFormats.timestampFormat.getPattern().length()) {
            string = string.substring(0, DateFormats.timestampFormat.getPattern().length());
        }
        if (string.length() == DateFormats.timestampFormat.getPattern().length()) {
            int index = string.indexOf(".");
            if (index == string.length() - 4) {
                string = string.substring(0, index) + "," + string.substring(index + 1);
            }
            return parse(DateFormats.timestampFormat, string);
        }
        return parse(DateFormats.dateFormat, string);
    }
}
}}}

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - in particular see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/Millis.java"><tt>Millis.java</tt> class</a>.