
November 2012 - DRAFT

Isn't <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html">!TimeUnit</a> the best thing since sliced bread?! Indeed anything and everything from Doug Lea is always thus :)

That aside, for the purposes of some [Timestamped Timestamped] thingies with <tt>millis</tt> since the Epoch, we find ourselves cobbling together a <tt>Millis</tt> util class.

{{{
public class Millis {
    
    public static long elapsedMillis(long startMillis) {
        return System.currentTimeMillis() - startMillis;
    }

    public static boolean isElapsed(long startMillis, long millis) {
        return (System.currentTimeMillis() - startMillis) > millis;
    }
    ...
}}}

Very lazy stuff. 

<h4>Time and time again</h4>

This <tt>Millis</tt> util primarily deals with time <i>intervals</i>, but sometimes also with moments in time since the Epoch, measured in milliseconds, courtesy of <tt>System.currentTimeMillis()</tt>.

But before we carry on, as a general caution, be aware of what <i>millis</i> we might be talking about and playing around with. Is it a time interval between two events, or the time of an event? 

Besides that, there is a difference between the time of an event, and the time of day of an event, as seen on someone's clock. The time of an event, measured as the number of millis since the Epoch, is absolute, but the time of day of that event as seen on some clock e.g. as <tt>10:32am</tt>, is relative to the !TimeZone for which that clock is configured. 

Consider that there is a different clock on every server, and every client hitting some server from different parts of the world. Even on the same physical server, different UNIX accounts, not to mention virtual machines, can be configured with different time zones, and so their clocks reflect a different time of day.

<h4>Absolute time</h4>

Time without its time zone is like measurement without units. Remember what happened to that Arianne rocket when the units got mixed up? So we have to be careful with those there numbers. 

In this article, we will think absolutely, in terms of milliseconds since the Epoch, and not be looking at any clocks, so that time zones are out of the picture.

In a follow-up article, we absolutely must delve into <tt>Date</tt>, <tt>!TimeZone</tt> and <tt>Calendar</tt>.

<h4>Time conversion</h4>

Of course we often want to convert to and from millis.

{{{ 
    public static long toSeconds(long millis) {
        return millis/1000;
    }

    public static long toMinutes(long millis) {
        return millis/1000/60;
    }

    public static long toHours(long millis) {
        return millis/1000/60/60;
    }

    public static long toDays(long millis) {
        return millis/1000/60/60/24;
    }
    
    public static long fromSeconds(long seconds) {
        return seconds*1000;
    }

    public static long fromMinutes(long minutes) {
        return minutes*60*1000;
    }

    public static long fromHours(long hours) {
        return hours*60*60*1000;
    }
    
    public static long fromDays(long days) {
        return days*24*60*60*1000;
    }
}}}

As i was saying, not exactly rocket science - but when rocket scientists get these wrong, their rockets tend to explode.

<h4>Format</h4>

We roll in a format method. 

{{{       
    public static String formatIntervalMillis(long millis) {
        if (millis == 0) return "00:00:00,000";
        long hour = millis/Millis.fromHours(1);
        long minute = (millis % Millis.fromHours(1))/Millis.fromMinutes(1);
        long second = (millis % Millis.fromMinutes(1))/Millis.fromSeconds(1);
        long millisecond = millis % Millis.fromSeconds(1);
        return String.format("%02d:%02d:%02d,%03d", hour, minute, second, millisecond);        
    }
}}}

Let's test. 

{{{
public class MillisTest {

    @Test
    public void testIntervalMillis() {
        Assert.assertEquals(Millis.formatIntervalMillis(1001), "00:00:01,001");
        Assert.assertEquals(Millis.formatIntervalMillis(60888), "00:01:00,888");
        Assert.assertEquals(Millis.formatIntervalMillis(3600999), "01:00:00,999");
    }    
}}}
I'm so happy that there are 60 seconds in a minute, and 3600 seconds in an hour!
{{{
    @Test
    public void breakingBad() {
        System.out.println(new SimpleDateFormat("HH:mm:ss").format(new Date(0)));
        System.out.println(new SimpleDateFormat("HH:mm:ss").format(new Date(System.currentTimeMillis())));
        System.out.println(Millis.formatIntervalSeconds(System.currentTimeMillis() % Millis.fromDays(1)));
    }    
}
}}}
We see that using <tt>!SimpleDateFormat</tt>, and pretending that a time interval is a time of day, on the day of the Epoch, is putting your clock on the block. Recall that at the moment of time on Earth that the UNIX Epoch happened way back in 1970, it was actually 00:00:00 only up there in Greenwich. So for most of us, the time of the Epoch was not even at midnight. Gutting. In fact for a good deal of us, it wasn't even 1970 yet - it was still 1969 - yeah baby!
{{{
02:00:00
22:43:50
20:43:50
}}}

<h4>Parse</h4>

For the parsing of intervals.
{{{
    public static long parse(String string) {
        int index = string.indexOf(" ");
        if (index > 0) {
            return TimeUnit.valueOf(string.substring(index + 1)).toMillis(
                Long.parseLong(string.substring(0, index)));
        } else if (string.length() >= 2 &&
                Character.isLowerCase(string.charAt(string.length() - 1)) && 
                Character.isDigit(string.charAt(string.length() - 2))) {            
            long value = Long.parseLong(string.substring(0, string.length() - 1));    
            if (string.endsWith("d")) {
                return TimeUnit.DAYS.toMillis(value);
            } else if (string.endsWith("h")) {
                return TimeUnit.HOURS.toMillis(value);
            } else if (string.endsWith("m")) {
                return TimeUnit.MINUTES.toMillis(value);
            } else if (string.endsWith("s")) {
                return TimeUnit.SECONDS.toMillis(value);
            }
        }  
        throw new ParseRuntimeException(string);
    }    
}
}}}
The test case below is quite illustrative.
{{{
    @Test
    public void testParse() {
        Assert.assertEquals(Millis.parse("1 SECONDS"), 1000);
        Assert.assertEquals(Millis.parse("1m"), 60000);
        Assert.assertEquals(Millis.parse("60m"), 3600000L);
        Assert.assertEquals(Millis.parse("60m"), Millis.parse("1h"));
        Assert.assertEquals(Millis.parse("24h"), Millis.parse("1d"));
    }
}}}

where this is especially convenient for configuration settings of time intervals e.g.

{{{
  <parameter name="interval" value="60s"/>
}}}

or if we configure our appllication using JSON,
{{{
  { ...
    "interval" : "12h"; 
  }
}}}

or via a database table (my personal favourite),

{{{
  insert into config (name, value) values ('interval', '1d'); 
}}}


or even a home-grown file-based configuration utility, which we don't necessarily recommend but will nonetheless introduce in another article :)

{{{
Config default {
  ...
  interval: 60s
}
}}}

<h4>Conclusion</h4>

In this [Timestamped Timestamped] series, we'll sometimes make use of a <tt>Millis</tt> convenience class which is presented here.

We introduce some parsing for intervals in a format especially convenient for configuration settings e.g. <tt>60s</tt>.

Time without time zone is like measurement without units, which is potentially disastrous. However in this article we deal with time intervals and absolute time since the Epoch, in order to steer clear of time zones altogether (and <tt>Date</tt> and <tt>Calendar</tt>), for now.

<h4>Coming up</h4>

We should of course delve into <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Date.html"><tt>Date</tt></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html"><tt>!TimeZone</tt></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html"><tt>Calendar</tt></a>. 

<h4>Further reading</h4>

Check out <a href="http://threeten.sourceforge.net/apidocs-2012-10-25/">JSR 310</a>.

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i collate these articles and their code - e.g. see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/Millis.java"><tt>Millis</tt></a> class.