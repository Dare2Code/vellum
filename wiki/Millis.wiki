
November 2012

DRAFT

Isn't <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html">!TimeUnit</a> the best thing since sliced bread?! Indeed anything and everything from Doug Lea is always thus :)

That aside, for the purposes of some [Timestamped Timestamped] thingies with <tt>millis</tt> since the Epoch, we find ourselves cobbling together a <tt>Millis</tt> util class.

{{{
public class Millis {
    
    public static long elapsedMillis(long startMillis) {
        return System.currentTimeMillis() - startMillis;
    }

    public static boolean isElapsed(long startMillis, long millis) {
        return (System.currentTimeMillis() - startMillis) > millis;
    }
    ...
}}}

Very lazy stuff. 

Our <tt>Millis</tt> util primarily deals with time <i>intervals</i>, but sometimes also with moments in time since the Epoch, measured in milliseconds, courtesy of <tt>System.currentTimeMillis()</tt>.

Before we carry on, as a general caution, be aware of what <i>millis</i> you are playing around with. Is it a time interval between two events, or the time of an event? 

Also there is a difference between the time of an event, and the time of day of an event, as seen on someone's clock. The time of an event, measured as the number of millis since the Epoch, is absolute, but the time of that event on the clock is relative to the !TimeZone in which that clock resides. A clock might reside on the server, or on a client, which are oftimes in different time zones. 

Time without time zone is like measurement without units. It's not rocket science, but it's bound to end in disaster, especially in rocket science!

Having said that, we are ignoring time zone in this article, and thinking in absolute terms, rather than looking wall clocks.

<h4>Format</h4>

We roll in a <tt>format()</tt> method. 

{{{       
    public static String formatIntervalMillis(long millis) {
        if (millis == 0) return "00:00:00,000";
        long hour = millis/Millis.fromHours(1);
        long minute = (millis % Millis.fromHours(1))/Millis.fromMinutes(1);
        long second = (millis % Millis.fromMinutes(1))/Millis.fromSeconds(1);
        long millisecond = millis % Millis.fromSeconds(1);
        return String.format("%02d:%02d:%02d,%03d", hour, minute, second, millisecond);        
    }
}}}

Let's test. 

{{{
public class MillisTest {

    @Test
    public void testIntervalMillis() {
        Assert.assertEquals(Millis.formatIntervalMillis(1001), "00:00:01,001");
        Assert.assertEquals(Millis.formatIntervalMillis(60888), "00:01:00,888");
        Assert.assertEquals(Millis.formatIntervalMillis(3600999), "01:00:00,999");
    }    

    @Test
    public void breakingBad() {
        System.out.println(new SimpleDateFormat("HH:mm:ss").format(new Date(0)));
        System.out.println(new SimpleDateFormat("HH:mm:ss").format(new Date(System.currentTimeMillis())));
        System.out.println(Millis.formatIntervalSeconds(System.currentTimeMillis() % Millis.fromDays(1)));
    }    
}
}}}

We see below that using <tt>SimpleDateFormat</tt>, and pretending that a time interval is a time on the day of the Epoch, is a non-starter. Recall that at the moment of time of that UNIX Epoch back in the early 70s, it was only actually 00:00 up in Greenwich. So for most all of us, the time of day of the Epoch was not even zero, which is a bit disappointing, i'm sure.

{{{
02:00:00
22:43:50
20:43:50
}}}

In a follow-up article, we absolutely must delve into <tt>Date</tt>, <tt>!TimeZone</tt> and <tt>Calendar</tt>.

<h4>Parse</h4>

For the parsing of intervals.
{{{
    public static Long parseInterval(String string) {
        int index = string.indexOf(" ");
        if (index > 0) {
            return TimeUnit.valueOf(string.substring(index + 1)).toMillis(Long.parseLong(string.substring(0, index)));
        } else if (string.length() >= 2 &&
                Character.isLowerCase(string.charAt(string.length() - 1)) && 
                Character.isDigit(string.charAt(string.length() - 2))) {            
            long value = Long.parseLong(string.substring(0, string.length() - 1));    
            if (string.endsWith("d")) {
                return TimeUnit.DAYS.toMillis(value);
            } else if (string.endsWith("h")) {
                return TimeUnit.HOURS.toMillis(value);
            } else if (string.endsWith("m")) {
                return TimeUnit.MINUTES.toMillis(value);
            } else if (string.endsWith("s")) {
                return TimeUnit.SECONDS.toMillis(value);
            }
        }  
        throw new ParseRuntimeException(string);
    }    
}
}}}
where this is especially convenient for configuration settings of time intervals e.g.

{{{
  <parameter name="interval" value="60s"/>
}}}

or if we configure our appllication using JSON,
{{{
{ 
  ...
  "interval" : "12h";
}
}}}

or via a database table (my personal favourite),

{{{
  insert into config (name, value) values ('interval', '1d'); 
}}}


or even a home-grown file-based configuration utility, which we don't necessarily recommend but will nonetheless introduce in another article :)

{{{
Config default {
  ...
  interval: 60s
}
}}}

<h4>Conclusion</h4>

In this [Timestamped Timestamped] series, we'll sometimes make use of a <tt>Millis.java</tt> convenience class which is presented here.

There is not to say we don't love !TimeUnit, because we absolutely do! 

We use a trivial !SimpleDateFormat wrapper, although we should definitely try Apache's !FastDateFormat rather.

We introduce some parsing for intervals in a convenient format e.g. <tt>4s, 2h, 1d,</tt> especially for nice readable configuration settings.

<h4>Coming up</h4>

We haven't even started on <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Date.html"><tt>Date</tt></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html"><tt>!TimeZone</tt></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html"><tt>Calendar</tt></a>. 

<h4>Further reading</h4>

Check out <a href="http://threeten.sourceforge.net/apidocs-2012-10-25/">JSR 310</a>.

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i collate these articles and their code - e.g. see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/Millis.java"><tt>Millis.java</tt></a> class.