
November 2012 - DRAFT

Isn't <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html">!TimeUnit</a> the best thing since sliced bread?! Indeed anything and everything from Doug Lea is always thus :)

That aside, for the purposes of some [Timestamped Timestamped] thingies with <tt>millis</tt> since the Epoch, we find ourselves cobbling together a <tt>Millis</tt> util class.

{{{
public class Millis {
    
    public static long elapsedMillis(long startMillis) {
        return System.currentTimeMillis() - startMillis;
    }

    public static boolean isElapsed(long startMillis, long millis) {
        return (System.currentTimeMillis() - startMillis) > millis;
    }
    ...
}}}

Some lazy stuff. 

<h4>Time and time again</h4>

The <tt>Millis</tt> util class presented here primarily deals with time <i>intervals</i>, but sometimes also time since the Epoch, measured in milliseconds, courtesy of <tt>System.currentTimeMillis()</tt>. Actually i'm inclined to rename this class to <tt>!MillisIntervals</tt>, to be clearer.

Most of the time we know which <i>millis</i> we're talking about. That is, either the time interval between two events, or the time of an event i.e. the "epochal time" given by <tt>System.currentTimeMillis()</tt>.

Besides that, there is the difference between the epochal time of an event, and the time of an event as recorded on our clock and calendar. The epochal time is absolute, but the "clock time" is relative to the !TimeZone for which that clock is configured. 

Consider that every server has its own clock, as does every client hitting any given server, often from different parts of the world. Even on the same physical server, different UNIX accounts, not to mention virtual machines, can be configured with different time zones, and so their clocks reflect a different time of day.

We read http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#currentTimeMillis,
<blockquote>
  See the description of the class Date for a discussion of slight discrepancies that may arise between "computer time" and coordinated universal time (UTC).
</blockquote>

We will certainly do that, but not today! 

<h4>Epochal time</h4>

Time without its time zone is sort of like measurement without units, in the sense that it will cause problems at some stage. Remember what happened to that Arianne rocket when the units got mixed up? So we have to be careful with numbers without qualifications. Of course measurement units determine scale, whereas time zones determine an offset (amongst other things like daylight savings), and time has units as well. 

Our default time unit for intervals is assumed to be milliseconds, and time itself we express as milliseconds since the Epoch. In this article at least, we will not be looking at any clocks, so that time zones are out of the picture, for now.

In a follow-up article, we absolutely must delve into <a href="http://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a>, <tt>!TimeZone</tt>, <tt>Calendar</tt> and that much maligned <tt>Date</tt>.

<h4>Time conversion</h4>

Of course we often want to convert to and from millis.

{{{ 
    public static long toSeconds(long millis) {
        return millis/1000;
    }

    public static long toMinutes(long millis) {
        return millis/1000/60;
    }

    public static long toHours(long millis) {
        return millis/1000/60/60;
    }

    public static long toDays(long millis) {
        return millis/1000/60/60/24;
    }
    
    public static long fromSeconds(long seconds) {
        return seconds*1000;
    }

    public static long fromMinutes(long minutes) {
        return minutes*60*1000;
    }

    public static long fromHours(long hours) {
        return hours*60*60*1000;
    }
    
    public static long fromDays(long days) {
        return days*24*60*60*1000;
    }
}}}

Not exactly rocket science - but when rocket scientists get these wrong, their rockets tend to explode.

Actually the above type of interval conversions are comprehensively and beautifully handled by <tt>!TimeUnit</tt>, as the following rewrite illustrates.

{{{
    public static long fromDays(long days) {
        return TimeUnit.DAYS.toMillis(days);
    }
}}}

<h4>Format</h4>

We roll in a format method. 

{{{       
    public static String format(long millis) {
        if (millis == 0) return "00:00:00,000";
        long hour = millis/Millis.fromHours(1);
        long minute = (millis % Millis.fromHours(1))/Millis.fromMinutes(1);
        long second = (millis % Millis.fromMinutes(1))/Millis.fromSeconds(1);
        long millisecond = millis % Millis.fromSeconds(1);
        return String.format("%02d:%02d:%02d,%03d", hour, minute, second, millisecond);        
    }
}}}

Let's test. 

{{{
public class MillisTest {

    @Test
    public void testIntervalMillis() {
        Assert.assertEquals(Millis.format(1001), "00:00:01,001");
        Assert.assertEquals(Millis.format(60888), "00:01:00,888");
        Assert.assertEquals(Millis.format(3600999), "01:00:00,999");
    }    
}}}
But now let's do the wrong thing. 
{{{
    @Test
    public void breakingBad() {
        System.out.println(new SimpleDateFormat("HH:mm:ss").format(new Date(0)));
        System.out.println(new SimpleDateFormat("HH:mm:ss").format(new Date(System.currentTimeMillis())));
        System.out.println(Millis.format(System.currentTimeMillis() % Millis.fromDays(1)));
    }    
}
}}}
We see the folly of using <tt>!SimpleDateFormat</tt> and pretending that a time interval is a time of day, on the day of the Epoch. When using <tt>Date</tt> you're putting your clock on the block. 
{{{
02:00:00
22:43:50
20:43:50,437
}}}
where my default time zone seems to be 2 hours ahead of Greenwich.

Recall that at the moment of time on Earth that the UNIX Epoch happened way back around <tt>1970-01-01</tt>, actually the time was <tt>00:00:00</tt> only up there in Greenwich. So for most of us, our clocks where not <tt>00:00:00</tt> at the time of the Epoch. Gutting. In fact for a good deal of us, it wasn't even 1970 yet - it was still 1969 - yeah baby!

<h4>Parse</h4>

And in parsing...
{{{
    public static long parse(String string) {
        int index = string.indexOf(" ");
        if (index > 0) {
            return TimeUnit.valueOf(string.substring(index + 1)).toMillis(
                Long.parseLong(string.substring(0, index)));
        } else if (string.length() >= 2 &&
                Character.isLowerCase(string.charAt(string.length() - 1)) && 
                Character.isDigit(string.charAt(string.length() - 2))) {            
            long value = Long.parseLong(string.substring(0, string.length() - 1));    
            if (string.endsWith("d")) {
                return TimeUnit.DAYS.toMillis(value);
            } else if (string.endsWith("h")) {
                return TimeUnit.HOURS.toMillis(value);
            } else if (string.endsWith("m")) {
                return TimeUnit.MINUTES.toMillis(value);
            } else if (string.endsWith("s")) {
                return TimeUnit.SECONDS.toMillis(value);
            }
        }  
        throw new ParseRuntimeException(string);
    }    
}
}}}
The test case below illustrates the functionality of this method.
{{{
    @Test
    public void testParse() {
        Assert.assertEquals(Millis.parse("1 SECONDS"), 1000);
        Assert.assertEquals(Millis.parse("1m"), 60000);
        Assert.assertEquals(Millis.parse("60m"), 3600000L);
        Assert.assertEquals(Millis.parse("60m"), Millis.parse("1h"));
        Assert.assertEquals(Millis.parse("24h"), Millis.parse("1d"));
    }
}}}
where this is especially convenient for configuration settings of time intervals e.g.
{{{
  <parameter name="interval" value="60s"/>
}}}

or if we configure our appllication using JSON,
{{{
  { ...
    "interval" : "12h"; 
  }
}}}
or via a database table (my personal favourite),
{{{
  insert into config (name, value) values ('interval', '1d'); 
}}}

or even a home-grown file-based configuration utility, which we don't necessarily recommend but will nonetheless introduce in another article :)
{{{
Config default {
  ...
  interval: 60s
}
}}}

<h4>Conclusion</h4>

In this [Timestamped Timestamped] series, we'll sometimes make use of a <tt>Millis</tt> convenience class which is presented here.

This class is a utility for time intervals, rather than "time" per se. 

Working with time without time zone is like measurement without units, i.e. potentially disastrous. That notwithstanding, in this article we deal with time intervals and the absolute time since the Epoch, both measured in milliseconds, in order to steer clear of time zones altogether (and <tt>Date</tt> and <tt>Calendar</tt>), for now.

<h4>Coming up</h4>

We should of course delve into <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Date.html"><tt>Date</tt></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html"><tt>!TimeZone</tt></a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html"><tt>Calendar</tt></a>. 

<h4>Further reading</h4>

http://en.wikipedia.org/wiki/Coordinated_Universal_Time

<a href="http://threeten.sourceforge.net/apidocs-2012-10-25/">JSR 310</a>

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i collate these articles and their code - e.g. see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/Millis.java"><tt>Millis</tt></a> class.