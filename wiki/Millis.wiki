
November 2012

DRAFT

Isn't <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html">!TimeUnit</a> the best thing since sliced bread?! Indeed anything and everything from Doug Lea is always thus :)

Having said that, for the purposes of some [Timestamped Timestamped] thingies with <tt>millis</tt> since the Epoch, we find ourselves introducing a <tt>Millis</tt> util class.

{{{
public class Millis {
    
    public static long elapsedMillis(long startMillis) {
        return System.currentTimeMillis() - startMillis;
    }

    public static boolean isElapsed(long startMillis, long millis) {
        return (System.currentTimeMillis() - startMillis) > millis;
    }

    public static boolean isElapsed(Date startTime, long millis) {
        return elapsedMillis(startTime) > millis;
    }

    public static long elapsedMillis(Date startTime) {
        if (startTime == null) return System.currentTimeMillis();
        return System.currentTimeMillis() - startTime.getTime();
    }

    public static long getIntervalMillis(Date from, Date to) {
        return Math.abs(to.getTime() - from.getTime());
    }
    ...
}}}

Very lazy stuff :)

Of course we often want to convert to and from millis.

{{{ 
    public static long toSeconds(long millis) {
        return millis/1000;
    }

    public static long toMinutes(long millis) {
        return millis/1000/60;
    }

    public static long toHours(long millis) {
        return millis/1000/60/60;
    }

    public static long toDays(long millis) {
        return millis/1000/60/60/24;
    }
    
    public static long fromSeconds(long seconds) {
        return seconds*1000;
    }

    public static long fromMinutes(long minutes) {
        return minutes*60*1000;
    }

    public static long fromHours(long hours) {
        return hours*60*60*1000;
    }
    
    public static long fromDays(long days) {
        return days*24*60*60*1000;
    }
}}}

We handle formatting to handle zero values.

{{{       
    public static String formatTime(long millis) {
        if (millis == 0) return "00:00:00";
        return DateFormats.timeFormat.format(new Date(millis));
    }

    public static String formatTimestamp(long millis) {
        if (millis == 0) return "00:00:00,000";
        return DateFormats.timestampFormat.format(new Date(millis));
    }
}}}

where in the case of the time of day, this only works for the default time zone! In a follow-up article we'll delve into <tt>!TimeZone</tt> vis-a-vis <tt>Calendar</tt> and its impact on <tt>Date</tt> and our <tt>Millis</tt> util.

And in parsing,

{{{
    public static Long parseInterval(String string) {
        int index = string.indexOf(" ");
        if (index > 0) {
            return TimeUnit.valueOf(string.substring(index + 1)).toMillis(Long.parseLong(string.substring(0, index)));
        } else if (string.length() >= 2 &&
                Character.isLowerCase(string.charAt(string.length() - 1)) && 
                Character.isDigit(string.charAt(string.length() - 2))) {            
            long value = Long.parseLong(string.substring(0, string.length() - 1));    
            if (string.endsWith("d")) {
                return TimeUnit.DAYS.toMillis(value);
            } else if (string.endsWith("h")) {
                return TimeUnit.HOURS.toMillis(value);
            } else if (string.endsWith("m")) {
                return TimeUnit.MINUTES.toMillis(value);
            } else if (string.endsWith("s")) {
                return TimeUnit.SECONDS.toMillis(value);
            }
        }  
        throw new ParseRuntimeException(string);
    }    
}
}}}

where actually this was introduced for the configuration of time intervals e.g.

{{{
  <parameter name="interval" value="60s"/>
}}}

or if we configure our appllication using JSON,

{{{
{ 
  ...
  "interval" : "12h";
}
}}}

or via a database table (my personal favourite),

{{{
  insert into config (name, value) values ('interval', '1d'); 
}}}


or even a home-grown file-based configuration utility, which we don't necessarily recommend but will nevertheless introduce in another article :)

{{{
Config default {
  ...
  interval: 60s
}
}}}

<h4>Safe date format</h4>

Incidently, since someone once told us that <a href="http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html"><tt>!SimpleDateFormat</tt></a> is not thread-safe, at some stage we introduced a <tt>synchronized</tt> <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/SafeDateFormat.java">wrapper</a> for it - athough we should be using Apache Commons <a href="http://commons.apache.org/lang/api-2.5/org/apache/commons/lang/time/FastDateFormat.html"><tt>FastDateFormat</tt></a>!?

{{{
public class SafeDateFormat {

   SimpleDateFormat dateFormat;
   String pattern;

   public SafeDateFormat(String pattern) {
      this.pattern = pattern;
      dateFormat = new SimpleDateFormat(pattern);
   }

   public String getPattern() {
      return pattern;
   }

   public synchronized String format(Date date) {
      if (date == null) {
         return "";
      }
      return dateFormat.format(date);
   }

   public synchronized Date parse(String string){
       return parse(string, null);
       
   }
   
   public synchronized Date parse(String string, Date defaultValue){
      if (string == null || string.isEmpty()) {
         return defaultValue;
      }
      if (string.length() > pattern.length()) {
          string = string.substring(0, pattern.length());
      }
        try {
            return dateFormat.parse(string);
        } catch (ParseException e) {
            throw new ParseRuntimeException(string, e);
        }
   }
}
}}}
where <tt>parse()</tt> truncates the timestamp string to the length of the pattern we are trying to parse.

We are accustomed to PostgreSQL's default date and timestamp formats, which are as follows (at least for our locale).
{{{
public class DefaultDateFormats {
    public static final SafeDateFormat dateFormat = new SafeDateFormat("yyyy-MM-dd");
    public static final SafeDateFormat timestampFormat = new SafeDateFormat("yyyy-MM-dd HH:mm:ss,SSS");
    public static final SafeDateFormat timeFormat = new SafeDateFormat("HH:mm:ss,SSS");
}
}}}

<h4>Conclusion</h4>

In code related to this [Timestamped Timestamped] series, we introduce a <tt>Millis.java</tt> convenience class, which is not to say we don't love !TimeUnit, because we absolutely do! Similarly we introduced a trivial !SimpleDateFormat wrapper, although some googling reveals Apache's !FastDateFormat, which looks great. 

For the pur

<h4>Further reading</h4>

We haven't even started on <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html"><tt>!TimeZone</tt></a> - which we'll leave a proper discussion for another day :)

And then of course there's <a href="http://threeten.sourceforge.net/apidocs-2012-10-25/">JSR 310</a>, which we should probably be using rather than anything else?!

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - in particular see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/datatype/Millis.java"><tt>Millis.java</tt></a> class.