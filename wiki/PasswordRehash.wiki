
February 2013 (DRAFT)

<h4>Introduction</h4>

As argued in the prequel, the most secure passwords are no passwords, e.g. using Google Login, Facebook Connect, Mozilla Persona or what-have-you. Such an approach simplifies our implementation effort, improves security, and makes registration and login more convenient for the end-user. However for internal enterprise apps, those login services might not be suitable, D'oh!

<img align="left" style="margin-right: 4px" src="http://www.jroller.com/evanx/resource/wooden-shield.png" />
<p align="left" style="margin-right: 4px" src="http://www.jroller.com/evanx/resource/gnome-keys-250.png" />
<p align="left" style="margin-right: 4px" src="http://www.jroller.com/evanx/resource/Gnome-preferences-desktop-personal-250-crop.png" />

In the [PasswordHash Password Hash] prequel, we presented an implementation using <tt>PBKDF2WithHmacSHA1</tt>, with a high number of iterations. The hashing operation takes as long as we are willing to make the user wait.

In this article, we wish to cater for multiple revisions of the number of iterations and key size, and even migrate hashes to the latest revision on the fly when the user logs in.

<h4>PBKDF2</h4>

According to the <a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet">OWASP Password Storage Cheat Sheet</a>,

  <i>General hashing algorithms (e.g. MD5, SHA) are not recommended for password storage. Instead an algorithm specifically designed for the purpose should be used such as bcrypt, PBKDF2 or scrypt.</i>

As presented in [PasswordHash Password Hash], we might choose to hash our passwords using PBKDF2 as follows.

{{{
public class Passwords {
    public static final String ALGORITHM = "PBKDF2WithHmacSHA1";
    public static final int ITERATION_COUNT = 16384;
    public static final int KEY_SIZE = 160;

    public static byte[] hashPassword(char[] password, byte[] salt)
            throws GeneralSecurityException {
        return hashPassword(password, salt, ITERATION_COUNT, KEY_SIZE);
    }

    public static byte[] hashPassword(char[] password, byte[] salt,
            int iterationCount, int keySize) throws GeneralSecurityException {
        PBEKeySpec spec = new PBEKeySpec(password, salt, iterationCount, keySize);
        SecretKeyFactory factory = SecretKeyFactory.getInstance(ALGORITHM);
        return factory.generateSecret(spec).getEncoded();
    }

    public static boolean matches(char[] password, byte[] passwordHash, byte[] salt) 
            throws GeneralSecurityException {
        return matches(password, passwordHash, salt, ITERATION_COUNT, KEY_SIZE);
    }

    public static boolean matches(char[] password, byte[] passwordHash, byte[] salt,
            int iterationCount, int keySize) throws GeneralSecurityException {
        return Arrays.equals(passwordHash, hashPassword(password, salt, 
                iterationCount, keySize));
    }
}
}}}

where using the provided PBKDF2 parameters, we check if the supplied password and its salt matches our hash.

<h4>Crypto parameters</h4>

According to the aforecited <a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet">OWASP Password Storage Cheat Sheet</a>,

  <i>You should measure the time required and make sure that it's as large as possible without providing a significantly noticeable delay when your users authenticate.</i>

We tested the time required as follows.

{{{
   @Test
   public void testEffort() throws Exception {
      String password = "12345678";
      long startMillis = System.currentTimeMillis();
      byte[] saltBytes = Passwords.nextSalt();
      Passwords.hashPassword(password, saltBytes);
      System.out.println("time " + Millis.elapsed(startMillis));
      if (Millis.elapsed(startMillis) < 10) {
         System.out.println("Ooooooo.... i'm not sure");
      } else if (Millis.elapsed(startMillis) > 500) {
         System.out.println("Mmmmmmm.... i don't know");
      }
   }
}}}

Since we have to revise the algorithm parameters as computing power increases, we need to store these parameters, together with the salt, and the password hash, for each user.

<h4>Storage</h4>

So we consider extending <a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet">OWASP's</a> SQL credential table to include the PBKDF2 parameters as follows.

{{{
   LOGIN VARCHAR (100) PRIMARY KEY,
   PASSWORD VARCHAR (32),
   SALT VARCHAR (32),
   PBKDF2_ITERATION_COUNT INTEGER,
   PBKDF2_KEY_SIZE INTEGER,   
}}}

But let's try to migrate to salty passwords without changing our database schema, by taking a page of Bcrypt's book, where we pack the password hash, salt and parameters into one field.

{{{
public class PasswordHash {
    private static final byte version = 0x00;    
    int iterationCount;
    int keySize;
    byte[] hash;
    byte[] salt;
    byte[] iv;

    public PasswordHash(byte[] hash, byte[] salt, byte[] iv, 
            int iterationCount, int keySize) {
        this.hash = hash;
        this.salt = salt;
        this.iv = iv;
        this.iterationCount = iterationCount;
        this.keySize = keySize;
    }
    ...
}}}

where the <tt>iv</tt> (initialization vector) field is intended for the optional AES encryption of the salt, which we'll consider in the finale of this trilogy.

Given a new password and our current algorithm parameters, generate salt, and hash the password as follows.

{{{
    public PasswordHash(char[] password, int iterationCount, int keySize) 
            throws GeneralSecurityException {
        this.iterationCount = iterationCount;
        this.keySize = keySize;
        this.salt = PasswordSalts.nextSalt();
        this.hash = Passwords.hashPassword(password, salt, iterationCount, keySize);
        this.iv = new byte[0];
    }
}}}

We then roll up the password hash, salt and parameters into a byte array as follows.

{{{
    public byte[] getBytes() {
        try {
            ByteArrayOutputStream stream = new ByteArrayOutputStream();
            stream.write(version);
            stream.write(salt.length + hash.length + iv.length + 9);
            stream.write(hash.length);
            stream.write(salt.length);
            stream.write(iv.length);
            stream.write(iterationCount/256);
            stream.write(iterationCount%256);
            stream.write(keySize/256);
            stream.write(keySize%256);
            stream.write(hash);
            stream.write(salt);
            stream.write(iv);
            return stream.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}}}

where this byte array is encoded using Base64 and stored in our "PASSWORD" field in the database. 

When authenticating the password, we unpack the parameters, salt and hash from a byte array. 

{{{       
    public PasswordHash(byte[] bytes) throws IOException {
        ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
        if (stream.read() != version || stream.read() != bytes.length) {
            throw new IOException();
        }
        hash = new byte[stream.read()];
        salt = new byte[stream.read()];
        iv = new byte[stream.read()];
        iterationCount = stream.read()*256 + stream.read();
        keySize = stream.read()*256 +  + stream.read();
        stream.read(hash);
        stream.read(salt);
        stream.read(iv);
    }

    public boolean matches(char[] password) throws GeneralSecurityException {
        return Arrays.equals(hash, Passwords.hashPassword(password, salt, iterationCount, keySize));
    }
}}}

<h4>Testing</h4>

Let's test. 

{{{
    @Test
    public void testPasswordHash() throws Exception {
        char[] password = "12345678".toCharArray();
        PasswordHash passwordHash = new PasswordHash(password, 
                Passwords.ITERATION_COUNT, Passwords.KEY_SIZE);
        byte[] hashBytes = passwordHash.pack();
        String hashString = Base64.encode(hashBytes);
        System.out.printf("%s\n", hashString);
        System.out.printf("byte array length %d, encoded length %d\n", 
                hashBytes.length, hashString.length());
        assertTrue(PasswordHash.isPacked(hashBytes));
        assertTrue(passwordHash.matches(password));
        assertFalse(passwordHash.matches("wrong".toCharArray()));
        assertTrue(new PasswordHash(passwordHash.pack()).matches(password));
        assertFalse(new PasswordHash(passwordHash.pack()).matches("wrong".toCharArray()));
        passwordHash = new PasswordHash(password, 16, 256);
        assertTrue(new PasswordHash(passwordHash.pack()).matches(password));
    }
}}}

{{{
AC0UEAAgAACgiKrEnYus1w5z7YTVfIz5cfQmIWZNLXY3wmqVnRoD361TNE5X
byte array length 45, encoded length 60
}}}

<h4>Migration</h4>

We provide a <tt>static</tt> method to check the bytes to confirm that the contents are consistent.

{{{
    public static boolean isPacked(byte[] packedBytes) {
        ByteArrayInputStream stream = new ByteArrayInputStream(packedBytes);
        if (stream.read() != version) {
            return false;
        }
        int length = stream.read();
        int hashLength = stream.read();
        int saltLength = stream.read();
        int ivLength = stream.read();
        if (packedBytes.length != length || 
                length != hashLength + saltLength + ivLength + 9) {
            return false;
        }
        return true;
    }
}}}

Finally our app could migrate to salty passwords on the fly.

{{{
    public boolean matches(String user, char[] password, byte[] packedBytes) throws Exception {
        if (PasswordHash.isPacked(packedBytes)) {
            PasswordHash passwordHash = new PasswordHash(packedBytes);
            if (passwordHash.matches(password)) {
                if (passwordHash.getIterationCount() != Passwords.ITERATION_COUNT ||
                        passwordHash.getKeySize() != Passwords.KEY_SIZE) {
                    packedBytes = PackedPasswords.hashPassword(password);
                    persistRevisedPasswordHash(user, packedBytes);
                }
                return true;
            }
            return false;
        }
        if (matchesUnsalted(password, packedBytes)) {
            packedBytes = PackedPasswords.hashPassword(password);
            persistRevisedPasswordHash(user, packedBytes);
            return true;
        }
        return false;
    }
}}}

where if the password is correct, but not at the latest revision, or still a legacy unsalted hash, we take the opportunity of migrating that user's password hash to the latest salty non-cracker.

Having said that, PCI requires passwords to be changed every 90 days, so it's not really necessary to migrate existing passwords to higher parameters, when a new password hash will be created soon enough :)

<h4>Summary</h4>

While SHA-2 is recommended these days for general hashing, we should use computationally expensive algorithms for password hashing, so that the passwords are harder to crack. 

<img align="right" style="margin-right: 4px" src="http://jroller.com/evanx/resource/gnome-shield-250.png" />

In the prequel, we presented an implementation using <tt>PBKDF2WithHmacSHA1</tt>, with a high number of iterations. 

Since the hashing operation should take as long as we are willing to make the user wait, the algorithm parameters must be tweaked accordingly.

We pack the hash, salt and parameters into a single field so that we needn't change our database schema, and can migrate from old passwords to new hashes seamlessly the user logs in and their actual password is thus on hand.

So we cater for multiple revisions of the number of iterations and key size, and migrate hashes on the fly to the latest revision on the fly. 

<h4>Coming up</h4>

In "Password Cipher," the finale of this sub-trilogy, we'll encrypt the password salt in our database, using... password-based encryption :)

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - e.g. see <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/crypto/Passwords.java"><tt>Passwords</tt></a>.

