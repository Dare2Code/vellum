
February 2013 (DRAFT)

<h4>Introduction</h4>

The most secure passwords are no passwords, e.g. using Google Login, Facebook Connect, Mozilla Persona or what-have-you. Such an approach simplifies our implementation effort, improves security, and makes registration and login more convenient for the end-user. So that's surely the way forward for consumer sites. However for internal enterprise apps, those login services might not be suitable.

<h4>Background reading</h4>

According to the <a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet">OWASP Password Storage Cheat Sheet</a>,

  <i>General hashing algorithms (e.g. MD5, SHA) are not recommended for password storage. Instead an algorithm specifically designed for the purpose should be used such as bcrypt, PBKDF2 or scrypt.</i>

  <i>You should measure the time required and make sure that its as large as possible without providing a significantly noticeable delay when your users authenticate.</i>

<h4>PBKDF2</h4>

As introduced in [PasswordSalt Password Salt] prequel, we might choose to hash our passwords using PBKDF2 as follows.

{{{
public class Passwords {
    public static final String ALGORITHM = "PBKDF2WithHmacSHA1";
    public static final int ITERATION_COUNT = 16384;
    public static final int KEY_SIZE = 160;

    public static byte[] hashPassword(char[] password, byte[] salt)
            throws GeneralSecurityException {
        return hashPassword(password, salt, ITERATION_COUNT, KEY_SIZE);
    }

    public static byte[] hashPassword(char[] password, byte[] salt,
            int iterationCount, int keySize) throws GeneralSecurityException {
        PBEKeySpec spec = new PBEKeySpec(password, salt, iterationCount, keySize);
        SecretKeyFactory factory = SecretKeyFactory.getInstance(ALGORITHM);
        return factory.generateSecret(spec).getEncoded();
    }

    public static boolean matches(char[] password, byte[] passwordHash, byte[] salt) 
            throws GeneralSecurityException {
        return matches(password, passwordHash, salt, ITERATION_COUNT, KEY_SIZE);
    }

    public static boolean matches(char[] password, byte[] passwordHash, byte[] salt,
            int iterationCount, int keySize) throws GeneralSecurityException {
        return Arrays.equals(passwordHash, hashPassword(password, salt, 
                iterationCount, keySize));
    }
}
}}}

where we check if the supplied password matches our hash with related salt, using the provided PBKDF2 parameters.

<h4>Crypto parameters</h4>

Since we have to revise the algorithm parameters as computing power increases, we need to store these parameters, together with the salt, and the password hash, for each user.

So we consider extending <a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet">OWASP's</a> SQL credential table to include the PBKDF2 parameters as follows.

{{{
   LOGIN VARCHAR (100) PRIMARY KEY,
   PASSWORD VARCHAR (32),
   SALT VARCHAR (32),
   PBKDF2_ITERATION_COUNT INTEGER,
   PBKDF2_KEY_SIZE INTEGER,   
}}}

This would facilitate rehashing passwords on-the-fly to higher parameters when a user logs in and their actual password is thus on hand. 

But let's try to migrate to salty passwords without changing our database schema, by taking a page of Bcrypt's book, where we pack the password hash, salt and parameters into one field.

{{{
public class PasswordHash {
    private static final byte version = 0x00;    
    int iterationCount;
    int keySize;
    byte[] hash;
    byte[] salt;
    byte[] iv;

    public PasswordHash(byte[] hash, byte[] salt, byte[] iv, 
            int iterationCount, int keySize) {
        this.hash = hash;
        this.salt = salt;
        this.iv = iv;
        this.iterationCount = iterationCount;
        this.keySize = keySize;
    }
    ...
}}}

Given a password, we generate the salt, perform the hashing, and roll everything up into a byte array.

Ignore the "iv" (initialization vector) field for now. It is an optional, for the AES encryption of the salt, which we'll consider in the finale of this password trilogy.

{{{
    public PasswordHash(char[] password, int iterationCount, int keySize) 
            throws GeneralSecurityException {
        this.iterationCount = iterationCount;
        this.keySize = keySize;
        this.salt = PasswordSalts.nextSalt();
        this.hash = Passwords.hashPassword(password, salt, iterationCount, keySize);
        this.iv = new byte[0];
    }

    public byte[] pack() {
        try {
            ByteArrayOutputStream stream = new ByteArrayOutputStream();
            stream.write(version);
            stream.write(salt.length + hash.length + iv.length + 8);
            stream.write(hash.length);
            stream.write(salt.length);
            stream.write(iv.length);
            stream.write(iterationCount/256);
            stream.write(iterationCount%256);
            stream.write(keySize/16);
            stream.write(hash);
            stream.write(salt);
            stream.write(iv);
            return stream.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}}}

When authenticating the password, we unpack the parameters, salt and hash from our single <tt>passwordHash</tt> field.
 
{{{       
    public PasswordHash(byte[] packedBytes) throws IOException {
        ByteArrayInputStream stream = new ByteArrayInputStream(packedBytes);
        if (stream.read() != version || stream.read() != packedBytes.length) {
            throw new IOException();
        }
        hash = new byte[stream.read()];
        salt = new byte[stream.read()];
        iv = new byte[stream.read()];
        iterationCount = stream.read()*256 + stream.read();
        keySize = 16 * stream.read();
        stream.read(hash);
        stream.read(salt);
        stream.read(iv);
    }

    public boolean matches(char[] password) throws GeneralSecurityException {
        return Arrays.equals(hash, Passwords.hashPassword(password, salt, iterationCount, keySize));
    }
}}}

Let's test. 

{{{
    @Test
    public void testPasswordHash() throws Exception {
        char[] password = "12345678".toCharArray();
        PasswordHash passwordHash = new PasswordHash(password, 
                Passwords.ITERATION_COUNT, Passwords.KEY_SIZE);
        byte[] hashBytes = passwordHash.pack();
        String hashString = Base64.encode(hashBytes);
        System.out.printf("%s\n", hashString);
        System.out.printf("byte array length %d, encoded length %d\n", 
                hashBytes.length, hashString.length());
        assertTrue(PasswordHash.isPacked(hashBytes));
        assertTrue(passwordHash.matches(password));
        assertFalse(passwordHash.matches("wrong".toCharArray()));
        assertTrue(new PasswordHash(passwordHash.pack()).matches(password));
        assertFalse(new PasswordHash(passwordHash.pack()).matches("wrong".toCharArray()));
        passwordHash = new PasswordHash(password, 16, 256);
        assertTrue(new PasswordHash(passwordHash.pack()).matches(password));
    }
}}}

{{{
ACoUEAwKYV0iZOY51c2AT4Xg63ggvtIVz+shS3o3/nJ3Hg3jrc1ZHrHW
byte array length 42, encoded length 56
}}}

We provide a method to check the bytes to confirm that the contents are consistent.

{{{
    public static boolean isPacked(byte[] packedBytes) {
        ByteArrayInputStream stream = new ByteArrayInputStream(packedBytes);
        if (stream.read() != version) {
            return false;
        }
        int length = stream.read();
        int hashLength = stream.read();
        int saltLength = stream.read();
        int ivLength = stream.read();
        if (packedBytes.length != length || 
                length != hashLength + saltLength + ivLength + 8) {
            return false;
        }
        return true;
    }
}}}

Finally our app might use a method as follows, to migrate to salty passwords on the fly.

{{{
    public boolean matches(String user, char[] password, byte[] packedBytes) throws Exception {
        if (PasswordHash.isPacked(packedBytes)) {
            PasswordHash passwordHash = new PasswordHash(packedBytes);
            if (passwordHash.matches(password)) {
                if (passwordHash.getIterationCount() != Passwords.ITERATION_COUNT ||
                        passwordHash.getKeySize() != Passwords.KEY_SIZE) {
                    packedBytes = PackedPasswords.hashPassword(password);
                    persistRevisedPasswordHash(user, packedBytes);
                }
                return true;
            }
            return false;
        }
        if (matchesUnsalted(password, packedBytes)) {
            packedBytes = PackedPasswords.hashPassword(password);
            persistRevisedPasswordHash(user, packedBytes);
            return true;
        }
        return false;
    }
}}}

where if the password is correct, but not at the latest revision, or still a legacy unsalted hash, we take the opportunity of migrating that user's password hash to the latest salty non-cracker.

<h4>Summary</h4>

While SHA-2 is recommended these days for general hashing, we should use computationally expensive algorithms for password hashing, so that the passwords are harder to crack. 

In the prequel, we presented an implementation using <tt>PBKDF2WithHmacSHA1</tt>, with a high number of iterations. 

Since the hashing operation should take as long as we are willing to make the user wait, the algorithm parameters be tweaked accordingly.

So we cater for multiple revisions of the number of iterations and key size, and migrate hashes on the fly to the latest revision when the user logs in.

<h4>Coming up</h4>

In "Password Cipher," the finalty of this sub-trilogy, we'll encrypt the password salt in our database, using... password-based encryption :)

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - e.g. see <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/crypto/Passwords.java"><tt>Passwords</tt></a>.

