
December 2012 - DRAFT

This provides a long overdue update to [PasswordHash Password Hash], which neglects to add salt!

<h4>Introduction</h4>

Passwords should never be seen in clear text in the wild e.g. transferred over the network, or stored in databases. So we hash them up. 

<h4>Background reading</h4>

(Please note i have sometimes edited and paraphrased the sources for brevity, with the exception of the first quote from OWASP.)

https://www.owasp.org/index.php/Hashing_Java

<blockquote>
If each password is simply hashed, identical passwords will have the same hash. There are two drawbacks to choosing to only storing the passwordâ€™s hash:

Due to the birthday paradox (http://en.wikipedia.org/wiki/Birthday_paradox), the attacker can find a password very quickly especially if the number of passwords the database is large.

An attacker can use a list of precomputed hashes (http://en.wikipedia.org/wiki/Rainbow_table) to break passwords in seconds.

In order to solve these problems, a salt can be concatenated to the password before the digest operation.

A salt is a random number of a fixed length. This salt must be different for each stored entry. It must be stored as clear text next to the hashed password.

In this configuration, an attacker must handle a brute force attack on each individual password. The database is now birthday attack/rainbow crack resistant.
</blockquote>

https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet

<blockquote>
General hashing algorithms (eg, MD5, SHA-1/256/512) are not recommended for password storage. Instead an algorithm specifically designed for the purpose should be used such as bcrypt, PBKDF2 or scrypt.
</blockquote>

http://en.wikipedia.org/wiki/Bcrypt

<blockquote>
bcrypt is a key derivation function for passwords based on the Blowfish cipher.
</blockquote>

http://en.wikipedia.org/wiki/PBKDF2

<blockquote>
PBKDF2 (Password-Based Key Derivation Function 2) is a key derivation function that is part of RSA Laboratories' Public-Key Cryptography Standards (PKCS) series.

PBKDF2 applies a pseudorandom function to the input password or passphrase along with a salt value and repeats the process many times. 

The added computational work makes password cracking much more difficult.

Having a salt added to the password reduces the ability to use precomputed hashes (rainbow tables) for attacks.
</blockquote>

http://en.wikipedia.org/wiki/Scrypt

<blockquote>
A password-based key derivation function (password-based KDF) is generally designed to be computationally intensive, so that it takes a relatively long time to compute (say on the order of several hundred milliseconds). Legitimate users only need to perform the function once per operation (e.g., authentication), and so the time required is negligible. However, a brute force attack would likely need to perform the operation billions of times at which point the time requirements become significant and, ideally, prohibitive.
</blockquote>

<h4>Psuedo salt</h4>

We use <tt>SecureRandom</tt> to produce our salt.
{{{
    public static byte[] nextSalt() {
        byte[] salt = new byte[16];
        SecureRandom random = new SecureRandom();
        random.nextBytes(salt);
        return salt;
    }
}}}
where our salt is a 16 byte random number. Sooo easy :)

<h4>Base64</h4>

Since we will be saving password hashes and their salt in our database (i.e. in a table for user logins), we must encode bytes into text. We will use Base64 (http://en.wikipedia.org/wiki/Base64).

For convenience, let's just include methods which delegate to our Base64 codec of choice e.g. from Apache commons, or the built-in Sun one, or some such.
{{{
    public static String encode(byte[] bytes) {
        return new BASE64Encoder().encode(bytes);
    }

    public static byte[] decode(String string) throws IOException {
        return new BASE64Decoder().decodeBuffer(string);
    }    
}}}

<h4>Crypto</h4>

So let's use PBKDF2.

{{{
    private static final String ALGORITHM = "PBKDF2WithHmacSHA1";
    private static final int ITERATION_COUNT = 9999;
    private static final int KEY_SIZE = 160;

    public static String hashPassword(String password, byte[] salt) {
        try {
            KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, ITERATION_COUNT, KEY_SIZE);
            SecretKeyFactory f = SecretKeyFactory.getInstance(ALGORITHM);
            byte[] hash = f.generateSecret(spec).getEncoded();
            return encode(hash);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    ...
}
}}}
where we have chose an interation count of 9999, and key size of 160 bits, in our <a href="http://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/PBEKeySpec.html"><tt>PBEKeySpec</tt></a>.

When the user chooses a password, we choose the salt, hash the password, and save the salt and hash in a record for that user login in our database. 

In the [https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet OWASP example], we create a SQL credential table with the columns
<ul>
<li> LOGIN VARCHAR (100) PRIMARY KEY,
<li> PASSWORD VARCHAR (32),
<li> SALT VARCHAR (32)
</ul>

{{{
    @Test
    public void test() throws Exception {
        String password = "123456";
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Passwords.encode(saltBytes);
        String hash = Passwords.hashPassword(password, saltBytes);
        assertTrue(Passwords.matches(password, hash, salt));
        assertFalse(Passwords.matches("not my password", hash, salt));
    }    
}}}

where we use the following method to authenticate a supplied password, having retrieved the hash and salt from out database.

We check if a supplied password matches our hash. 

{{{
    public static boolean matches(String password, String passwordHash, String salt) {
        try {
            byte[] saltBytes = decode(salt);
            String hash = hashPassword(password, saltBytes);
            return hash.equals(passwordHash);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}}}

<h4>No salt column</h4>

But what if we wish to migrate to salty passwords without changing a our database schema to store a salt together with the password hash? 

{{{
    @Test
    public void testSaltEncoding() throws Exception {
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Passwords.encode(saltBytes);
        System.out.println(salt);
        assertEquals(salt.length(), 24);
        assertEquals(salt.substring(22, 24), "==");
    }
}}}

So a 16 byte array encoded with Base64 apparently yields a 22 character string followed by two characters of padding. 

{{{
r2tWqOrfKpr64rpOwoRlcw==
}}}

One could concatenate the password and the salt, as follows.

{{{
public class PackedPasswords {
    public static final int HASH_LENGTH = 54;
    public static final String HASH_VERSION_PREFIX = "00";
    private static final int PREFIX_LENGTH = 26;

    private static String pack(String hash, String salt) {
        return HASH_VERSION_PREFIX + salt + hash;
    }

    public static boolean isPacked(String passwordHash) {
        return passwordHash.length() == HASH_LENGTH && passwordHash.startsWith(HASH_VERSION_PREFIX);
    }
    ...
}
}}}

where we prefix a version code to future-proof it i.e. when we decide to change the iteration count, key size or algorithm in future.

{{{
    private static String unpackPassword(String passwordHash) {
        return passwordHash.substring(PREFIX_LENGTH);
    }

    private static String unpackSalt(String passwordHash) {
        return passwordHash.substring(HASH_VERSION_PREFIX.length(), PREFIX_LENGTH);
    }        
}}}

In this case we generate the salt when hashing the password, and pack it into the password. 

{{{
    public static String hashPassword(String password) {
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Base64.encode(saltBytes);
        String hash = Passwords.hashPassword(password, saltBytes);
        return pack(hash, salt);
    }
}}}

When authenticating the password, we unpack the salt and hash from our single password hash field.
 
{{{       
    public static boolean matches(String password, String passwordHash) {
        try {
            String salt = unpackSalt(passwordHash);
            byte[] saltBytes = Passwords.decode(salt);
            passwordHash = unpackPassword(passwordHash);
            String hash = Passwords.hashPassword(password, saltBytes);
            return hash.equals(passwordHash);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}}}

In this case, we could migrate passwords when each user next logs in, by checking the length of the hash, and if the lengh indicates our former unsalted digest, then we rehash the password and save the new salted one.  

{{{
    @Test
    public void testPacked() throws Exception {
        String password = "12345678";
        String hash = PackedPasswords.hashPassword(password);
        System.out.println(hash);
        assertEquals(PackedPasswords.HASH_LENGTH, hash.length());
        assertTrue(PackedPasswords.isPacked(hash));
        assertTrue(PackedPasswords.matches(password, hash));
        assertFalse(PackedPasswords.matches("wrong", hash));
    }
}}}

{{{
00fM5zJNdKKKhAGk5zXIB/pQ==ryphVpbdiqnsGNdKONRXzCjGs0E=
}}}

{{{
    public boolean matches(String user, String password, String passwordHash) throws Exception {
        if (PackedPasswords.isPacked(passwordHash)) {
            return PackedPasswords.matches(password, passwordHash);
        }
        boolean matches = matchesUnsalted(password, passwordHash);
        if (matches) {
            passwordHash = PackedPasswords.hashPassword(password);
            persistNewPasswordHash(user, passwordHash);
        }
        return matches;
    }
}}}

<h4>Conclusion</h4>

Passwords should never be sent across the network, or stored in databases in clear text. So we hash them e.g. SHA-1 [http://en.wikipedia.org/wiki/SHA-1]

http://en.wikipedia.org/wiki/PBKDF2

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/util/Passwords.java"><tt>Passwords</tt></a> class.

