
December 2012 - DRAFT

This is part of the [EnigmaPosts Enigma Posts] series. 

This provides a long overdue update to [PasswordHash Password Hash] (2007) from the [EnigmaPrequels Enigma Prequels] series, where that article neglected to add salt, which is soooo embarassing for whoever wrote that article... which was unfortunately me.

<h4>Introduction</h4>

We know that passwords should never be seen in clear text, or stored as-is in databases; but rather they should be hashed in an irretrievable manner. 

Traditionally <a href="http://en.wikipedia.org/wiki/MD5">MD5</a> has been used, and <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a> is generally recommended these days for general hashing, but actually we'll read that neither of these should be used simplisticly for password hashing as such.

We aren't suprised to read that the <a href="http://www.dailymail.co.uk/sciencetech/article-2223197/Revealed-The-common-passwords-used-online-year-password-STILL-tops-list.html">most common</a> password is "password", followed by other premium choices such as "12345678" and "abc123" etc. This in fact illustrates the importance of salt :)

It goes without saying how vital passwords are to IT security. Which itself goes a long way towards explaining why IT security often seems to break down in such <a href="http://www.dailymail.co.uk/news/article-2123854/1-5million-account-numbers-hacked-Visa-Mastercard-card-data-theft.html">spectacular fashion</a>. 

<h4>Background reading</h4>

(Please note i have sometimes edited and paraphrased the sources for brevity, with the exception of the first quote from OWASP.)

http://en.wikipedia.org/wiki/SHA-2

<blockquote>
SHA-2 is a set of cryptographic hash functions (SHA-224, SHA-256, SHA-384, SHA-512) designed by the National Security Agency (NSA) and published in 2001 by the NIST as a U.S. Federal Information Processing Standard.
</blockquote>

https://www.owasp.org/index.php/Hashing_Java

<blockquote>
If each password is simply hashed, identical passwords will have the same hash. This has two drawbacks:

Due to the birthday paradox (http://en.wikipedia.org/wiki/Birthday_paradox), the attacker can find a password very quickly especially if the number of passwords the database is large.

An attacker can use a list of precomputed hashes (http://en.wikipedia.org/wiki/Rainbow_table) to break passwords in seconds.

In order to solve these problems, a salt can be concatenated to the password before the digest operation.

A salt is a random number of a fixed length. This salt must be different for each stored entry. It must be stored as clear text next to the hashed password.

In this configuration, an attacker must handle a brute force attack on each individual password. The database is now birthday attack and rainbow crack resistant.
</blockquote>

https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet

<blockquote>
General hashing algorithms (eg, MD5, SHA-1/256/512) are not recommended for password storage. Instead an algorithm specifically designed for the purpose should be used such as bcrypt, PBKDF2 or scrypt.
</blockquote>

http://en.wikipedia.org/wiki/Bcrypt

<blockquote>
bcrypt is a key derivation function for passwords based on the Blowfish cipher.
</blockquote>

http://en.wikipedia.org/wiki/PBKDF2

<blockquote>
PBKDF2 (Password-Based Key Derivation Function 2) is a key derivation function that is part of RSA Laboratories' Public-Key Cryptography Standards (PKCS) series.

PBKDF2 applies a pseudorandom function to the input password along with a salt value, and repeats the process many times. 

The added computational work makes password cracking much more difficult.

Having a salt added to the password reduces the ability to use precomputed hashes (rainbow tables) for attacks.
</blockquote>

http://en.wikipedia.org/wiki/Scrypt

<blockquote>
A password-based key derivation function (password-based KDF) is generally designed to be computationally intensive, so that it takes a relatively long time to compute (say on the order of several hundred milliseconds). 

Legitimate users only need to perform the function once per operation (e.g., authentication), and so the time required is negligible. 

However, a brute force attack would likely need to perform the operation billions of times at which point the time requirements become significant and, ideally, prohibitive.
</blockquote>

<h4>Base64</h4>

Since we will be saving password hashes and their salt in our database (i.e. in a table for user logins), we must encode bytes into text. We will use <a href="http://en.wikipedia.org/wiki/Base64">Base64</a>.

For convenience, we introduce methods which delegate to our Base64 codec of choice e.g. from Apache commons, or the built-in Sun one, or some such.
{{{
public class Base64 {
    
    public static String encode(byte[] bytes) {
        return new BASE64Encoder().encode(bytes);
    }

    public static byte[] decode(String string) {
        try {
            return new BASE64Decoder().decodeBuffer(string);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
}}}

<h4>Psuedo salt</h4>

We use <tt>!SecureRandom</tt> to produce our salt.
{{{
public class Passwords {
    public static final int ENCODED_SALT_LENGTH = 24;    
    ...
    public static byte[] nextSalt() {
        byte[] salt = new byte[16];
        SecureRandom random = new SecureRandom();
        random.nextBytes(salt);
        return salt;
    }
}}}
where our salt is a 16 byte random number. Sooo easy :)

First let's have a closer look at the encoded salt.
{{{
    @Test
    public void testSaltEncoding() throws Exception {
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Passwords.encode(saltBytes);
        System.out.println(salt);
        assertEquals(salt.length(), 24);
        assertEquals(salt.substring(22, 24), "==");
    }
}}}

{{{
r2tWqOrfKpr64rpOwoRlcw==
}}}

So apparently a 16 byte array encoded with Base64 yields a 22 character string followed by two characters of padding. 

<h4>Per user salt</h4>

When the user chooses a password, we generate some salt, hash the password using the salt, and save the salt and hash in a record for that user login in our database. 

The [https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet OWASP example] has a SQL credential table with the columns:
<li> LOGIN VARCHAR (100) PRIMARY KEY,
<li> PASSWORD VARCHAR (32),
<li> SALT VARCHAR (32)

<h4>Crypto parameters</h4>

So let's try PBKDF2. (We'll leave Bcrypt and Scrypt for another day. Readers, please provide your opinions on these other options, and indeed PBKDF2 and parameters and what-not presented here.)

PBKDF2 has parameters <tt>iterationCount</tt> and <tt>keySize</tt>. So we introduce the following class.  

{{{
public class PasswordSpec {
    private String algorithm;
    private int iterationCount;
    private int keySize;

    public PasswordSpec(String algorithm, int iterationCount, int keySize) {
        this.algorithm = algorithm;
        this.iterationCount = iterationCount;
        this.keySize = keySize;
    }

    public String hashPassword(char[] password, byte[] salt) {
        try {
            PBEKeySpec spec = new PBEKeySpec(password, salt, iterationCount, keySize);
            SecretKeyFactory factory = SecretKeyFactory.getInstance(algorithm);
            byte[] hash = factory.generateSecret(spec).getEncoded();
            return Base64.encode(hash);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }    
}
}}}

where we use <a href="http://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/PBEKeySpec.html"><tt>PBEKeySpec</tt></a> and stuff.

Then we can revise these parameters in future. 

{{{
public class Passwords {
    private static final PasswordSpec specs[] = {
        new PasswordSpec("PBKDF2WithHmacSHA1", 1000, 128), // 2010
        new PasswordSpec("PBKDF2WithHmacSHA1", 9999, 160), // 2012
    };
    public static final int LATEST_REVISION_INDEX = specs.length - 1;

    public static String hashPassword(char[] password, byte[] salt) {
        return hashPassword(password, salt, LATEST_REVISION_INDEX);
    }

    public static String hashPassword(char[] password, byte[] salt, int revisionIndex) {
        return specs[revisionIndex].hashPassword(password, salt);
    }
    ...
}}}
where we have an array of our <tt>!PasswordSpec</tt>, to which we can add revised parameters in future.

Darn, now we have a <tt>revisionIndex</tt> which we also need to store for each password, together with the salt of course.

Anyway let's test that hashing and matching actually works.
{{{
    @Test
    public void test() throws Exception {
        String password = "12345678";
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Passwords.encode(saltBytes);
        String hash = Passwords.hashPassword(password, saltBytes);
        assertTrue(Passwords.matches(password, hash, salt));
        byte[] otherSaltBytes = Arrays.copyOf(saltBytes, saltBytes.length);
        otherSaltBytes[0] ^= otherSaltBytes[0];
        assertFalse(Passwords.matches(password, hash, Passwords.encode(otherSaltBytes)));
        assertFalse(Passwords.matches("!" + password, hash, salt));
    }
}}}

where we use the following method to authenticate a supplied password, having retrieved the hash and salt from our database.

{{{
    public static boolean matches(char[] password, String passwordHash, String salt) {
        return matches(password, passwordHash, salt, LATEST_REVISION_INDEX);
    }
    
    public static boolean matches(char[] password, String passwordHash, String salt, int revisionIndex) {
        byte[] saltBytes = Base64.decode(salt);
        String hash = hashPassword(password, saltBytes, revisionIndex);
        return hash.equals(passwordHash);
    }
}}}

where we check if the supplied password matches our hash with related salt. 

<h4>No salt column</h4>

But what if we wish to migrate to salty passwords without changing our database schema i.e. adding a new column for the salt.

One could concatenate the password and the salt, as follows.

{{{
public class PackedPasswords {
    public static final int REVISION_PREFIX_LENGTH = 2;

    private static String pack(String hash, String salt, int revisionIndex) {
        assert revisionIndex >= 0 && revisionIndex <= 9;
        return "^" + revisionIndex + salt + hash;
    }

    public static boolean isPacked(String passwordHash) {
        return passwordHash.charAt(0) == '^';
    }

    public static boolean isPackedLatest(String passwordHash) {
        return isPacked(passwordHash, Passwords.LATEST_REVISION_INDEX);
    }
    
    public static boolean isPacked(String passwordHash, int revisionIndex) {
        return passwordHash.charAt(0) == '^' && passwordHash.charAt(1) == ('0' + revisionIndex);
    }
    ...
}}}

where we prefix a version code to future-proof it i.e. when we decide to change the iteration count, key size or algorithm in future.

{{{
    private static String unpackPassword(String passwordHash) {
        return passwordHash.substring(PREFIX_LENGTH);
    }

    private static String unpackSalt(String passwordHash) {
        return passwordHash.substring(HASH_VERSION_PREFIX.length(), PREFIX_LENGTH);
    }        
}}}

In this case we generate the salt when hashing the password, and pack it into the password. 

{{{
    public static String hashPassword(char[] password, int revisionIndex) {
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Base64.encode(saltBytes);
        String hash = Passwords.hashPassword(password, saltBytes, revisionIndex);
        return pack(hash, salt, revisionIndex);
    }
}}}

Can a reader confirm that this is what <a href="http://code.google.com/p/jbcrypt/">Bcrypt</a> does, i.e. concatenates the salt and the password?

Another trick is to splice the salt into the password at an index obtained by hashing the password into say, an 4 bit number. For example, we hash the password to produce an index between 0 and 15, and then insert the salt (exclude the "==" padding), into the password at that index. In this case, one needs the password itself to even unpack the salt from the password hash. Can a reader make any recommendations on this?

When authenticating the password, we unpack the revision index, salt and hash from our single <tt>passwordHash</tt> field.
 
{{{       
    public static boolean matches(char[] password, String passwordHash) {
        int revisionIndex = unpackRevisionIndex(passwordHash);
        String salt = unpackSalt(passwordHash);
        passwordHash = unpackPassword(passwordHash);
        String hash = Passwords.hashPassword(password, Base64.decode(salt), revisionIndex);
        return hash.equals(passwordHash);
    }    
}}}

In this case, we could migrate passwords when each user next logs in, by checking the length of the hash, and if the lengh indicates our former unsalted digest, then we rehash the password and save the new salted one.  

{{{
    @Test
    public void testPacked() throws Exception {
        String password = "12345678";
        String hash = PackedPasswords.hashPassword(password);
        System.out.println(hash);
        assertEquals(PackedPasswords.HASH_LENGTH, hash.length());
        assertTrue(PackedPasswords.isPacked(hash));
        assertTrue(PackedPasswords.matches(password, hash));
        assertFalse(PackedPasswords.matches("wrong " + password, hash));
    }
}}}

{{{
0^fM5zJNdKKKhAGk5zXIB/pQ==ryphVpbdiqnsGNdKONRXzCjGs0E=
}}}

Finally our app might use a method as follows to migrate to salty passwords.

{{{
    public boolean matches(String user, char[] password, String passwordHash) throws Exception {
        if (PackedPasswords.isPacked(passwordHash)) {
            if (PackedPasswords.matches(password, passwordHash)) {
                if (!PackedPasswords.isPackedLatest(passwordHash)) {
                    passwordHash = PackedPasswords.hashPassword(password);
                    persistRevisedPasswordHash(user, passwordHash);                    
                }
                return true;
            }
            return false;
        }
        if (matchesUnsalted(password, passwordHash)) {
            passwordHash = PackedPasswords.hashPassword(password);
            persistRevisedPasswordHash(user, passwordHash);
            return true;
        }
        return false;
    }
}}}

where if the password is correct, but still a legacy unsalted hash, or not at the latest revision, we take the opportunity of migrating that user's password hash to the latest salty non-cracker. 

<h4>Computational effort</h4>

According to https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet

<blockquote>
You should measure the time required and make sure that its as large as possible without providing a significantly noticeable delay when your users authenticate.
</blockquote>

Otherwise we should tweak the iteration count and key size.

So perhaps the time required to hash the password should be less than 100ms for consumer sites? I'm just guessing and don't really know so hopefully a reader can comment. In the case of secure admin sites, perhaps we are happier with it taking a bit longer.

{{{
    @Test
    public void testEffort() throws Exception {
        String password = "12345678";
        long startMillis = System.currentTimeMillis();
        byte[] saltBytes = Passwords.nextSalt();
        Passwords.hashPassword(password, saltBytes);
        System.out.println("time " + Millis.elapsed(startMillis));
        if (Millis.elapsed(startMillis) < 10) {
            System.out.println("Ooooooo.... i don't know");
        } else if (Millis.elapsed(startMillis) > 500) {
            System.out.println("Ooooooo....");
        }
    }
}}}

Given that CPU power is increasing every year, we need the dynamic solution where we can revise the parameters :)

<h4>Furthermore</h4>

According to https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet

<blockquote>
An additional password storage defense mechanism involves storing the salt in a different location than the password hash. Use of the server's filesystem is one commonly used mechanism for salt isolation, assuming the password hashes are stored in different location such as a database.
</blockquote>

So i guess the salt could be encrypted in the database, and this key loaded from a keystore by our application, i.e. off the filesystem. Our app uses this key to decrypt the salts retrieved from the database. In this case, both our database and filesystem needs to be compromised, and password data and keystore both be stolen, to effect password theft. Please comment on such a mechanism, so that we can present it later in this series.

<h4>Conclusion</h4>

Passwords should never be seen or stored in clear text, or in any reversible fashion. 

Since the passwords that people manage to come up with are, urm, far from random, we add salt, to protect against rainbow attacks and what-not.

We present an implementation using <tt>PBKDF2WithHmacSHA1</tt>, which seems to be quite common according to some googling. We cater for multiple revisions, typically to increase the number of iterations and key size, and illustrate how hashes might be migrated on the fly to the latest revision.

Please comment! Security is soooo important, and i'm sure i have some errors and omissions, and wouldn't want to mislead any readers, as i've done so often before - sorry about that!

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - e.g. see <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/util/Passwords.java"><tt>Passwords</tt></a>.

