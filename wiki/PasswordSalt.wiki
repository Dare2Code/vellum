
This provides a long overdue update to [PasswordHash Password Hash], which neglects to add salt!

<h4>Introduction</h4>

Passwords should never be seen in clear text in the wild e.g. transferred over the network, or stored in databases. So we hash them up. 

<h4>Crypto</h4>

http://en.wikipedia.org/wiki/PBKDF2

<blockquote>
Having a salt added to the password reduces the ability to use precomputed hashes (rainbow tables) for attacks.
</blockquote>

https://www.owasp.org/index.php/Hashing_Java

<blockquote>
If each password is simply hashed, identical passwords will have the same hash. There are two drawbacks to choosing to only storing the passwordâ€™s hash:

Due to the birthday paradox (http://en.wikipedia.org/wiki/Birthday_paradox), the attacker can find a password very quickly especially if the number of passwords the database is large.

An attacker can use a list of precomputed hashes (http://en.wikipedia.org/wiki/Rainbow_table) to break passwords in seconds.

In order to solve these problems, a salt can be concatenated to the password before the digest operation.

A salt is a random number of a fixed length. This salt must be different for each stored entry. It must be stored as clear text next to the hashed password.

In this configuration, an attacker must handle a brute force attack on each individual password. The database is now birthday attack/rainbow crack resistant.
</blockquote>

{{{
public class Passwords {
    public static String ALGORITHM = "PBKDF2WithHmacSHA1";

    public static String hashPassword(String password, byte[] salt) {
        try {
            KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 2048, 160);
            SecretKeyFactory f = SecretKeyFactory.getInstance(ALGORITHM);
            byte[] hash = f.generateSecret(spec).getEncoded();
            return encode(hash);
        } catch (Exception e) {
            throw Exceptions.newRuntimeException(e);
        }
    }
    ...
}}}

{{{
    public static byte[] nextSalt() {
        byte[] salt = new byte[16];
        SecureRandom random = new SecureRandom();
        random.nextBytes(salt);
        return salt;
    }
}}}

{{{
    public static boolean matches(String password, String passwordHash, String salt) {
        try {
            byte[] saltBytes = decode(salt);
            String hash = hashPassword(password, saltBytes);
            return hash.equals(passwordHash);
        } catch (Exception e) {
            Exceptions.warn(e);
            return false;
        }
    }
}}}

For convenience, we include methods which delegate to a Base64 codec e.g. from Apache commons, or the built-in Sun one.
{{{
    public static String encode(byte[] bytes) {
        return new BASE64Encoder().encode(bytes);
    }

    public static byte[] decode(String string) throws IOException {
        return new BASE64Decoder().decodeBuffer(string);
    }    
}
}}}


<h4>Conclusion</h4>

Passwords should never be sent across the network, or stored in databases in clear text. So we hash them e.g. SHA-1 [http://en.wikipedia.org/wiki/SHA-1]

http://en.wikipedia.org/wiki/PBKDF2

<h4>Sneak preview</h4>

But what if we wish to migrate to salty passwords without changing a our database schema to store a salt? 

One could concatenate the password and the salt, or even splice the salt into the encoded hashed password, for example as follows.

{{{
    private static String pack(int length, String hash, String salt) {
        return hash.substring(0, length) + salt.substring(0, 22) + hash.substring(length);
    }
}}}

where <tt>length</tt> is the length of the password. 

{{{
    private static String unpackPassword(int length, String passwordHash) {
        return passwordHash.substring(0, length) + passwordHash.substring(length + 22);
    }

    private static String unpackSalt(int length, String passwordHash) {
        return passwordHash.substring(length, length + 22) + "==";
    }        
}}}

<h4>Further reading</h4>

http://code.google.com/p/jbcrypt/

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/util/Passwords.java"><tt>Passwords</tt></a> class.


