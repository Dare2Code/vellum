
December 2012 - DRAFT

This provides a long overdue update to [PasswordHash Password Hash], which neglects to add salt!

<h4>Introduction</h4>

Passwords should never be seen in clear text in the wild e.g. transferred over the network, or stored in databases. So we hash them up. 

Because the <a href="http://www.dailymail.co.uk/sciencetech/article-2223197/Revealed-The-common-passwords-used-online-year-password-STILL-tops-list.html">most common</a> password is still apparently "password", and non-random choices such as "abc123" feature very highly, we better add salt.

<h4>Background reading</h4>

(Please note i have sometimes edited and paraphrased the sources for brevity, with the exception of the first quote from OWASP.)

https://www.owasp.org/index.php/Hashing_Java

<blockquote>
If each password is simply hashed, identical passwords will have the same hash. This has two drawbacks:

Due to the birthday paradox (http://en.wikipedia.org/wiki/Birthday_paradox), the attacker can find a password very quickly especially if the number of passwords the database is large.

An attacker can use a list of precomputed hashes (http://en.wikipedia.org/wiki/Rainbow_table) to break passwords in seconds.

In order to solve these problems, a salt can be concatenated to the password before the digest operation.

A salt is a random number of a fixed length. This salt must be different for each stored entry. It must be stored as clear text next to the hashed password.

In this configuration, an attacker must handle a brute force attack on each individual password. The database is now birthday attack and rainbow crack resistant.
</blockquote>

https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet

<blockquote>
General hashing algorithms (eg, MD5, SHA-1/256/512) are not recommended for password storage. Instead an algorithm specifically designed for the purpose should be used such as bcrypt, PBKDF2 or scrypt.
</blockquote>

http://en.wikipedia.org/wiki/Bcrypt

<blockquote>
bcrypt is a key derivation function for passwords based on the Blowfish cipher.
</blockquote>

http://en.wikipedia.org/wiki/PBKDF2

<blockquote>
PBKDF2 (Password-Based Key Derivation Function 2) is a key derivation function that is part of RSA Laboratories' Public-Key Cryptography Standards (PKCS) series.

PBKDF2 applies a pseudorandom function to the input password along with a salt value, and repeats the process many times. 

The added computational work makes password cracking much more difficult.

Having a salt added to the password reduces the ability to use precomputed hashes (rainbow tables) for attacks.
</blockquote>

http://en.wikipedia.org/wiki/Scrypt

<blockquote>
A password-based key derivation function (password-based KDF) is generally designed to be computationally intensive, so that it takes a relatively long time to compute (say on the order of several hundred milliseconds). 

Legitimate users only need to perform the function once per operation (e.g., authentication), and so the time required is negligible. 

However, a brute force attack would likely need to perform the operation billions of times at which point the time requirements become significant and, ideally, prohibitive.
</blockquote>

<h4>Psuedo salt</h4>

We use <tt>!SecureRandom</tt> to produce our salt.
{{{
    public static byte[] nextSalt() {
        byte[] salt = new byte[16];
        SecureRandom random = new SecureRandom();
        random.nextBytes(salt);
        return salt;
    }
}}}
where our salt is a 16 byte random number. Sooo easy :)

<h4>Base64</h4>

Since we will be saving password hashes and their salt in our database (i.e. in a table for user logins), we must encode bytes into text. We will use <a href="http://en.wikipedia.org/wiki/Base64">Base64</a>.

For convenience, we include methods which delegate to our Base64 codec of choice e.g. from Apache commons, or the built-in Sun one, or some such.
{{{
    public static String encode(byte[] bytes) {
        return new BASE64Encoder().encode(bytes);
    }

    public static byte[] decode(String string) {
        try {
            return new BASE64Decoder().decodeBuffer(string);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }    
}}}

<h4>Crypto</h4>

So let's try PBKDF2. (We'll leave Bcrypt and Scrypt for another day. Readers, please provide your opinions on these other options, and indeed PBKDF2 and parameters and what-not presented here.)

{{{
public class Passwords {
    private static final String ALGORITHM = "PBKDF2WithHmacSHA1";
    private static final int ITERATION_COUNT = 99999;
    private static final int KEY_SIZE = 160;

    public static String hashPassword(String password, byte[] salt) {
        try {
            KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, ITERATION_COUNT, KEY_SIZE);
            SecretKeyFactory f = SecretKeyFactory.getInstance(ALGORITHM);
            byte[] hash = f.generateSecret(spec).getEncoded();
            return encode(hash);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    ...
}
}}}
where we have chosen an interation count of 99999, and key size of 160 bits, in our <a href="http://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/PBEKeySpec.html"><tt>PBEKeySpec</tt></a>.

When the user chooses a password, we choose the salt, hash the password, and save the salt and hash in a record for that user login in our database. 

The [https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet OWASP example] has a SQL credential table with the columns:
<li> LOGIN VARCHAR (100) PRIMARY KEY,
<li> PASSWORD VARCHAR (32),
<li> SALT VARCHAR (32)

Let's test how this would work. 

{{{
    @Test
    public void test() throws Exception {
        String password = "12345678";
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Passwords.encode(saltBytes);
        String hash = Passwords.hashPassword(password, saltBytes);
        assertTrue(Passwords.matches(password, hash, salt));
        byte[] otherSaltBytes = Arrays.copyOf(saltBytes, saltBytes.length);
        otherSaltBytes[0] ^= otherSaltBytes[0];
        assertFalse(Passwords.matches(password, hash, Passwords.encode(otherSaltBytes)));
        assertFalse(Passwords.matches("!" + password, hash, salt));
    }
}}}

where we use the following method to authenticate a supplied password, having retrieved the hash and salt from our database.

{{{
    public static boolean matches(String password, String passwordHash, String salt) {
        byte[] saltBytes = decode(salt);
        String hash = hashPassword(password, saltBytes);
        return hash.equals(passwordHash);
    }
}}}

where we check if the supplied password matches our hash with related salt. 

<h4>No salt column</h4>

But what if we wish to migrate to salty passwords without changing our database schema i.e. adding a new column for the salt.

First let's have a closer look at the encoded salt.
{{{
    @Test
    public void testSaltEncoding() throws Exception {
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Passwords.encode(saltBytes);
        System.out.println(salt);
        assertEquals(salt.length(), 24);
        assertEquals(salt.substring(22, 24), "==");
    }
}}}

{{{
r2tWqOrfKpr64rpOwoRlcw==
}}}

So apparently a 16 byte array encoded with Base64 yields a 22 character string followed by two characters of padding. 

One could concatenate the password and the salt, as follows.

{{{
public class PackedPasswords {
    public static final int HASH_LENGTH = 54;
    public static final String HASH_VERSION_PREFIX = "0^";
    private static final int PREFIX_LENGTH = 26;

    private static String pack(String hash, String salt) {
        return HASH_VERSION_PREFIX + salt + hash;
    }

    public static boolean isPacked(String passwordHash) {
        return passwordHash.length() == HASH_LENGTH && passwordHash.startsWith(HASH_VERSION_PREFIX);
    }
    ...
}
}}}

where we prefix a version code to future-proof it i.e. when we decide to change the iteration count, key size or algorithm in future.

{{{
    private static String unpackPassword(String passwordHash) {
        return passwordHash.substring(PREFIX_LENGTH);
    }

    private static String unpackSalt(String passwordHash) {
        return passwordHash.substring(HASH_VERSION_PREFIX.length(), PREFIX_LENGTH);
    }        
}}}

In this case we generate the salt when hashing the password, and pack it into the password. 

{{{
    public static String hashPassword(String password) {
        byte[] saltBytes = Passwords.nextSalt();
        String salt = Base64.encode(saltBytes);
        String hash = Passwords.hashPassword(password, saltBytes);
        return pack(hash, salt);
    }
}}}

Can a reader confirm that this is what <a href="http://code.google.com/p/jbcrypt/">Bcrypt</a> does, i.e. concatenates the salt and the password?

Another trick is to splice the salt into the password at an index obtained by hashing the password into an 4 bit number. Can a reader comment on that?

When authenticating the password, we unpack the salt and hash from our single <tt>passwordHash</tt> field.
 
{{{       
    public static boolean matches(String password, String passwordHash) {
        String salt = unpackSalt(passwordHash);
        passwordHash = unpackPassword(passwordHash);
        String hash = Passwords.hashPassword(password, Passwords.decode(salt));
        return hash.equals(passwordHash);
    }
}}}

In this case, we could migrate passwords when each user next logs in, by checking the length of the hash, and if the lengh indicates our former unsalted digest, then we rehash the password and save the new salted one.  

{{{
    @Test
    public void testPacked() throws Exception {
        String password = "12345678";
        String hash = PackedPasswords.hashPassword(password);
        System.out.println(hash);
        assertEquals(PackedPasswords.HASH_LENGTH, hash.length());
        assertTrue(PackedPasswords.isPacked(hash));
        assertTrue(PackedPasswords.matches(password, hash));
        assertFalse(PackedPasswords.matches("wrong " + password, hash));
    }
}}}

{{{
0^fM5zJNdKKKhAGk5zXIB/pQ==ryphVpbdiqnsGNdKONRXzCjGs0E=
}}}

Finally our app might use a method as follows to migrate to salty passwords.

{{{
    public boolean matches(String user, String password, String passwordHash) throws Exception {
        if (PackedPasswords.isPacked(passwordHash)) {
            return PackedPasswords.matches(password, passwordHash);
        }
        if (matchesUnsalted(password, passwordHash)) {
            passwordHash = PackedPasswords.hashPassword(password);
            persistNewPasswordHash(user, passwordHash);
            return true;
        }
        return false;
    }
}}}

where if the password is correct, but still a legacy unsalted hash, we take the opportunity of migrating that user's password hash to a salty non-cracker. 

<h4>Furthermore</h4>

According to https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet

<blockquote>
An additional password storage defense mechanism involves storing the salt in a different location than the password hash. Use of the server's filesystem is one commonly used mechanism for salt isolation, assuming the password hashes are stored in different location such as a database.
</blockquote>

So i guess the salt should be encrypted in the database, and this key loaded from a keystore by our application, i.e. off the filesystem. Our app uses this key to decrypt the salts retrieved from the database. In this case, both our database and filesystem needs to be compromised, and password data and keystore both be stolen, to effect password theft. Please comment on such a mechanism, so that we can present it later in this series.

<h4>Conclusion</h4>

Passwords should never be sent across the network, or stored in databases in clear text. So we hash them e.g. using [http://en.wikipedia.org/wiki/SHA-1 SHA-1].

Since the passwords people come up with are, at best, not as random as they could be, and typically at worst, the weakest link of our system, we add salt. 

Moreover, in order to increase the computational effort involved so as to hinder any salty cracker, we use a <a href="http://en.wikipedia.org/wiki/PBKDF2">key derivation function</a> with many iterations, namely RSA's PBKDF2, with the SHA-1 hash function.

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - see the <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/util/Passwords.java"><tt>Passwords</tt></a> class.

