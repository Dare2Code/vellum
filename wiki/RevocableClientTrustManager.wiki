#labels SSL, keytool, Java

<h4>Overview</h4>

We consider innumerable clients connecting to a Java server over SSL sockets. 

Naturally, we generate certificates for each client, and can import these self-signed certificates into our server truststore.

In this article, we sign the client certificates using our server certificate, which is then our local CA root certificate, and as such our server must support certificate revocation.

<h4>SSLContexts</h4>

Ordinarily we create an <tt>SSLContext</tt> as follows.
{{{
public class SSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPassword,
            KeyStore trustStore) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPassword);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("SunX509");
        trustManagerFactory.init(trustStore);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(keyManagerFactory.getKeyManagers(),
                trustManagerFactory.getTrustManagers(), new SecureRandom());
        return sslContext;
    }
}}}

Let's implement a custom <tt>!X509TrustManager</tt> to support local certificate revocation. 

{{{
public class RevocableSSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPass,
            KeyStore trustStore, List<String> revocationList) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPass);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        TrustManager revocableTrustManager = new RevocableClientTrustManager(
                getPrivateKeyCertificate(keyStore),
                getX509TrustManager(trustStore),
                revocationList);
        sslContext.init(keyManagerFactory.getKeyManagers(),
                new TrustManager[]{revocableTrustManager},
                new SecureRandom());
        return sslContext;
    }
}
}}}
where we initialise a custom <tt>!RevocableClientTrustManager</tt> with our server cert, and a collection of revoked certificates' CNs.

{{{
public class RevocableClientTrustManager implements X509TrustManager {
    X509Certificate serverCertificate;
    X509TrustManager delegate;
    Collection<String> revokedCNList;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        if (!certs[0].getIssuerX500Principal().equals(
                serverCertificate.getSubjectX500Principal())) {
            throw new CertificateException("Untrusted issuer");
        }
        if (!Arrays.equals(certs[1].getPublicKey().getEncoded(),
                serverCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Invalid server certificate");
        }
        if (revokedCNList.contains(getCN(certs[0].getSubjectDN()))) {
            throw new CertificateException("Certificate CN revoked");
        }
        delegate.checkClientTrusted(certs, authType);
    }
}
}}}
where we check that the client certificate is signed by our server certificate, and not revoked. Finally, we delegate to the standard <tt>!X509TrustManager</tt> for good measure.

We might prefer to revoke certificates by serial number.
{{{
        if (revokedSerialNumberList.contains(certs[0].getSerialNumber())) {
            throw new CertificateException("Certificate serial number revoked");
        }
}}}

<h4><tt>keytool</tt></h4>

Let's use <tt>keytool</tt> to create our private SSL keystore for a client, say evanx.
{{{
$ keytool -keystore evanx.jks -genkeypair -keyalg rsa -keysize 2048 -validity 365 -alias evanx \
    -dname "CN=evanx, OU=test"
}}}
We export our certificate as follows.
{{{
$ keytool -keystore evanx.jks -alias evanx -exportcert -rfc
}}}
We cut and paste the exported PEM text into a file, which we can inspect using <tt>openssl</tt> as follows.
{{{
$ openssl x509 -text -in evanx.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1380030508 (0x5241982c)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: CN=evanx, OU=test
        Validity
            Not Before: Sep 24 13:48:28 2013 GMT
            Not After : Sep 24 13:48:28 2014 GMT
        Subject: CN=evanx, OU=test
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
}}}
We import the cert into the server SSL truststore.
{{{
$ keytool -keystore server.trust.jks -alias evanx -importcert -file evanx.pem
}}}

Similarly, the server cert is imported into the clients' truststores.

<h4>Client certificate signing</h4>

Alternatively, we could export a CSR, and sign this with the server cert. In this case our server is a local CA, which must support certificate revocation e.g. using <tt>!RecovableClientTrustManager</tt>.
{{{
$ keytool -keystore evanx.jks -alias evanx -certreq
}}}

We use Java7's keytool to sign the CSR.

{{{
$ keytool -keystore server.jks -gencert -validity 365 -rfc \
    -dname "CN=evanx, OU=test" -infile evanx.csr -outfile evanx.signed.pem
}}}

Note that <tt>-gencert</tt> is not available in Java6's keytool.

We inspect the cert using <tt>openssl</tt>.

{{{
$ openssl x509 -text -in evanx.signed.pem | grep CN
        Issuer: CN=server, OU=test
        Subject: CN=evanx, OU=test
}}}

Since our keystore requires our cert chain to be imported in the correct order starting with the root cert, we import the server cert first, and then our signed cert.

{{{
$ keytool -keystore evanx.jks -importcert -noprompt \
    -file server.pem -alias server 
Enter keystore password: 
Certificate was added to keystore

$ keytool -keystore evanx.jks -importcert -noprompt \
    -file evanx.signed.pem -alias evanx
Enter keystore password: 
Certificate reply was installed in keystore
}}}

Our client keystore can double up as our truststore since it contains the server cert as the root of its certificate chain. If our server cert is CA-signed, we can't do that, since our keystore certificate chain would include the CA's root cert, and so we would trust <i>any</i> cert signed by that CA.

Our server keystore can also double up as its truststore, since it contains its cert which signs our client certs.

<h4>Client certificate management</h4>

Clearly a rogue certificate with a duplicate CN can impersonate a valid certificate. So when issuing a certificate, we must take care to ensure the uniqueness of the CN, and add the certificate, or at least its unique identifier, to a registry of some sort. 

If a certificate is signed but not recorded, or its record is deleted, our server is forever vulnerable to that rogue certificate. In order to regularly review access, we require a perfect record of all issued certificates. We might record our signed certs into a keystore file as follows.
{{{
$ keytool -keystore server.issued.jks -importcert -alias evanx -file evanx.pem 
Certificate was added to keystore
}}}
where this is not a truststore per se, but just a database of issued certificates. 

Interestingly, in trying to avoid a truststore containing all our client certificates, we have nevertheless ended up with one! 

<h4>Self-signed client certificates</h4>

All told, given the risk of a rogue certificate, we recommend self-signed client certificates whenever possible, where these are explicitly imported into our server truststore. 

<img align="right" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

Note that when using self-signed certs (or CA certs), the server keystore must not be used as its truststore, since the keystore naturally contains the server certificate, and so a rogue certificate can be created by signing it with the server key, e.g. using <tt>keytool -gencert</tt>, as illustrated above.

<h4>Conclusion</h4>

We can sign client certificates using our server certificate, which is then our local CA root certificate. We introduce a custom <tt>!RevocableClientTrustManager</tt> to support this scenario.

<h4>Also see</h4>

We'll perform unit testing of <tt>!RevocableClientTrustManager</tt> in a follow-up article.

Also in this series on Java crypto: <a href="https://weblogs.java.net/blog/evanx/archive/2013/01/24/password-salt">Password Salt</a>, <a href="https://weblogs.java.net/blog/evanx/archive/2012/11/07/google-authenticator-thus-enabled">Google Authenticator</a>.
