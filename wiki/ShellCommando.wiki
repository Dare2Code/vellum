
This article is the first installment of the [BinBash Bin Bash] series :) 

== Introduction == 

We write lots of cron scripts to perform routine maintenance tasks on our systems, so... 

We might want a script to perform various tasks in succession, but also be able to invoke those individually in an adhoc fashion e.g. to test them.

== Template == 

The following is a basic template, with one custom command for illustration, namely <tt>command1_df()</tt>.

{{{
#!/bin/bash

set -o nounset

command1_df() { # partition
  partition=$1
  df -h | grep $1
}

command0_help() {
  echo "The following commands are available:" 
  cat $0 | grep '^command[0-9]_' | sed 's/^command\([0-9]\)_\(.*\)() { # \(.*\)/\2: \1 args: \3/'
}

command0_default() {
  echo "Sorry but the default invocation of this script has no functionality yet."
  command0_help
}

invoke() {
  if [ $# -gt 0 ]
  then
    command=$1
    shift
  else
    command=default
  fi
  command$#_$command $@
}

invoke $@
}}}

Firstly, we always set the bash option <tt>nounset</tt> so that if our script encounters an unset variable, this is treated as an inherently unsafe bug, and the script will abort.

We implement custom commands in the script as per the <tt>command1_df()</tt> example, using a specific naming convention whereby the function name is prefixed by "command" and a digit which is the number of arguments that are expected, courtesy of <tt>$#</tt> in <tt>invoke()</tt>.

If no command-line arguments are provided, we will invoke the function <tt>command0_default()</tt>.

==== Help ====

The above implementation of <tt>command0_help()</tt> lists all the functions at our command, where we document the expected arguments in the script itself via a comment next to the function declaration. 

<code language="xml">
evanx@beethoven:~$ sh scripts/test.sh
Sorry but the default invocation of this script has no functionality yet.
The following commands are available:
df: 1 args: partition
</code>
where <tt>command0_help()</tt> will parse the script itself for command functions, and print any comments regarding their usage. 

We might provide help on a specific command as follows.
<code language="sh">
command1_help() {
  command0_help | grep $1
}
</code>

For example,

<code language="xml">
evanx@beethoven:~$ sh scripts/test.sh help df
df: 1 args: partition
</code>

==== Invocation ====

Consider our first custom function, using <tt>df</tt>.

<code language="shell">
command1_df() { # partition
  partition=$1
  df -h | grep $1
}
</code>

We invoke the <tt>command1_df()</tt> with one argument, which we see in its implementation is 
just a pattern we grep from the output of <tt>df</tt>. 

<code language="xml">
evanx@beethoven:~$ sh scripts/test.sh df home
/dev/sdb2             128G  109G   13G  90% /home
</code>

If we do not provide the correct number of arguments that the function is expecting, the script will abort as follows. 

<code language="xml">
evanx@beethoven:~$ sh scripts/test.sh df 
scripts/test.sh: 25: command0_df: not found
</code>
where the intentioned function is actually prefixed by <tt>command1</tt> since it requires 1 argument.

If we provide an invalid command, the script will abort as follows.

<code language="xml">
evans@beethoven:~$ sh scripts/test.sh dff home
scripts/test.sh: 25: command1_dff: not found
</code>

=== Example ===

As an example, let's implement a new command to print yesterday's date in our preferred format. 

{{{
command0_yesterday() { # print yesterday's date in YYYY-MM-DD format
  date -d 'yesterday' +'%Y-%m-%d'
}
}}}

Let's check the usage. 

<code language="xml">
evans@beethoven:~$ sh scripts/test.sh help yesterday
yesterday: 0 args: print yesterday's date in YYYY-MM-DD format
</code>

And let's invoke it. 

<code language="xml">
evans@beethoven:~$ sh scripts/test.sh yesterday
2013-04-26
</code>

== Conclusion == 

We introduce a template for a convenient menu-esque approach to invoking functions in a bash script.

The implementation will ensure that <tt>command</tt> functions are invoked with the correct number of arguments, by virtue of the using the number of arguments in the function name itself e.g. <tt>command1</tt> will prefix functions requiring one argument only.

=== Coming up ===

In an upcoming article, we'll use the above approach for LSI MegaRAID commands as follows.
<code language="xml">
$ sh scripts/megaraid.sh 
commands:
1 ldGetProp ld 
2 ldSetProp ld prop
1 setProp prop
1 getProp prop
1 pdInfo slot
1 pdMakeGood slot
3 pdReplaceMissing slot array row
1 pdRbld_showProg slot
1 pdRbld_start slot
1 ldInfo ld
1 ldInfo_state ld
0 alarmSilence 
0 alarmDisplay 
0 pdInfo 
0 pdGetMissing 
0 pdList 
0 events 
</code>

where for example the <tt>ldSetProp</tt> function is implemented as follows.

{{{
megaraid2_ldSetProp() { # ld prop
  /opt/MegaRAID/CmdTool2/CmdTool264 -ldSetProp $2 -l$1 -a0
}
}}}

Such scripts provide a useful reference for such commands, if nothing else :)

=== Resources === 

See the [BinBash Bin Bash] page. 


