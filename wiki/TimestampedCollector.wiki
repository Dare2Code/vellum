

{{{
public class TimestampedCollector<T extends Timestamped>  {
    long capacityMillis;
    long lastTimestamp;
    LinkedList<T> linkedList = new LinkedList();
    
    public TimestampedCollector(long capacityMillis) {
        this.capacityMillis = capacityMillis;
    }
    
    public synchronized void addLast(T element) {
        if (element.getTimestamp() == 0 || element.getTimestamp() < lastTimestamp) {
            throw new IllegalArgumentException();
        }
        lastTimestamp = element.getTimestamp();
        prune(lastTimestamp);
        linkedList.addLast(element);
    }

    public synchronized Deque<T> newDeque(long lastTimestamp) {
        prune(lastTimestamp);
        return new ArrayDeque(linkedList);
    }

    public synchronized Deque<T> tailDeque(int capacity) {
        if (linkedList.size() <= capacity) {
            return new ArrayDeque(linkedList);
        } else {
            return new ArrayDeque(linkedList.subList(linkedList.size() - capacity, linkedList.size()));
        }
    }    
    
    private void prune(long latestTimestamp) {
        while (linkedList.size() > 0 && 
                linkedList.getFirst().getTimestamp() < latestTimestamp - capacityMillis) {
            linkedList.removeFirst();
        }
    }
}
}}}