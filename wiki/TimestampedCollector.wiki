

{{{
public class TimestampedCollector<T extends Timestamped>  {
    long capacityMillis;
    long lastTimestamp;
    LinkedList<T> linkedList = new LinkedList();
    
    public TimestampedCollector(long capacityMillis) {
        this.capacityMillis = capacityMillis;
    }
    
    public synchronized void addLast(T element) {
        if (element.getTimestamp() == 0 || element.getTimestamp() < lastTimestamp) {
            throw new IllegalArgumentException();
        }
        lastTimestamp = element.getTimestamp();
        prune(lastTimestamp);
        linkedList.addLast(element);
    }

    public synchronized Deque<T> newDeque(long lastTimestamp) {
        prune(lastTimestamp);
        return new ArrayDeque(linkedList);
    }

    public synchronized Deque<T> tailDeque(int capacity) {
        if (linkedList.size() <= capacity) {
            return new ArrayDeque(linkedList);
        } else {
            return new ArrayDeque(linkedList.subList(linkedList.size() - capacity, linkedList.size()));
        }
    }    
    
    private void prune(long latestTimestamp) {
        while (linkedList.size() > 0 && 
                linkedList.getFirst().getTimestamp() < latestTimestamp - capacityMillis) {
            linkedList.removeFirst();
        }
    }
}
}}}

{{{
public class TimestamperCollectorTest implements Runnable {
    long capacityMillis = 30;
    long scheduledInterval = 10;
    long scheduledDelay = 0;
    final TimestampedCollector collector = new TimestampedCollector(capacityMillis);
    ScheduledFuture future = Executors.newScheduledThreadPool(1).scheduleAtFixedRate(
            this, scheduledDelay, scheduledInterval, TimeUnit.MILLISECONDS);
    boolean verbose = false;
            
    @Override
    public void run() {
        long timestamp = System.currentTimeMillis();
        String value = "record at " + timestamp;
        collector.addLast(new TimestampedElement(value, timestamp));
        if (verbose) {
            System.out.println(value);
        }
    }
    
    @Test
    public void test() throws Exception {
        check();
        check();
        future.cancel(true);
    }
    
    private void check() throws Exception {
        verbose = true;
        long startMillis = System.currentTimeMillis();
        Thread.sleep(capacityMillis);
        verbose = false;
        Deque<Timestamped> deque = collector.newDeque(startMillis + capacityMillis);
        SortedSet<Timestamped> set = new TreeSet(new TimestampedComparator());
        set.addAll(deque);
        Assert.assertEquals("first", deque.getFirst().getTimestamp(), set.first().getTimestamp());
        Assert.assertEquals("last", deque.getLast().getTimestamp(), set.last().getTimestamp());
        Assert.assertTrue("first", set.first().getTimestamp() >= startMillis);
        Assert.assertTrue("last time" , 
                set.last().getTimestamp() >= startMillis + capacityMillis - scheduledInterval);
        Assert.assertTrue("capacityMillis", 
                set.last().getTimestamp() - set.first().getTimestamp() <= capacityMillis);
        System.out.println("size " + deque.size());
        System.out.println("startMillis " + startMillis);
        System.out.println("first " + set.first().getTimestamp());
        System.out.println("last " + set.last().getTimestamp());
        System.out.println("capacity " + (capacityMillis/scheduledInterval));
    }    
}
}}}

<pre>
record at 1340137798399
record at 1340137798409
record at 1340137798419
size 3
startMillis 1340137798394
first 1340137798399
last 1340137798419
capacity 3
record at 1340137798429
record at 1340137798439
record at 1340137798449
size 3
startMillis 1340137798428
first 1340137798429
last 1340137798449
capacity 3
</pre>