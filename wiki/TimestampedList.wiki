
<h1>Timestamped List</h1>

We herewith continue the no-hit wonder <i>"Timestamped: a trilogy in a few parts,"</i> this being the second part, where we introduce an interface for so-called <tt>Timestamped</tt> records, and a special <tt>List</tt> to store them, with a time-based capacity. 

<img src="http://upload.wikimedia.org/wikipedia/commons/1/12/Gnome-appointment-new.svg"/>

We will be analysing logs in this unwinding series. Ultimately we gonna hook up a remote Log4j appender to digest our logs to gather stats, and make some judgement calls as to the rapidly changing status of our app.  

<h2>Timestamped</h2>

I give you the namesake interface of this series.
{{{
public interface Timestamped {
    public long getTimestampMillis();    
}
}}}

Also have an adapter for a Log4j logging event. 
{{{
public class TimestampedLoggingEventAdapter implements Timestamped {
    LoggingEvent loggingEvent;

    public TimestampedLoggingEventAdapter(LoggingEvent loggingEvent) {
        this.loggingEvent = loggingEvent;
    }

    @Override
    public long getTimestampMillis() {
        return loggingEvent.getTimeStamp();
    }
}
}}}

Or a generic wrapped element.
{{{
public class TimestampedElement<T> implements Timestamped {
    T element;
    long timestampMillis;

    public TimestampedElement(T element, long timestampMillis) {
        this.element = element;
        this.timestampMillis = timestampMillis;
    }

    public T getElement() {
        return element;
    }
    
    @Override
    public long getTimestampMillis() {
        return timestampMillis;
    }
}
}}}

We might want equality by the timestamp for this element.

{{{
    @Override
    public int hashCode() {
        return (int) (timestampMillis % Integer.MAX_VALUE);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Timestamped) {
            return timestampMillis == ((Timestamped) obj).getTimestampMillis();
        }
        return false;
    }
}}}

Also, a comparator will undoubtedly be required at some stage. 

{{{
public class TimestampedComparator implements Comparator<Timestamped> {

    @Override
    public int compare(Timestamped o1, Timestamped o2) {
        if (o1.getTimestampMillis() < o2.getTimestampMillis()) return -1;
        if (o1.getTimestampMillis() > o2.getTimestampMillis()) return 1;
        else return 0;
    }    
}
}}}

<h2>Timestamped List</h2>

Now have the namesake of this article, a list of timestamped thingies with a time-based capacity - a "circular buffer" or FILO queue or some such thing.
{{{
public class TimestampedList<T extends Timestamped>  {

    LinkedList<T> linkedList = new LinkedList();
    long capacityMillis;

    public TimestampedList(long capacityMillis) {
        this.capacityMillis = capacityMillis;
    }
    
    public synchronized void add(T element) {
        prune(element.getTimestampMillis());
        linkedList.add(0, element);
    }

    private synchronized void prune(long timestamp) {
        while (linkedList.size() > 0) {
            T last = linkedList.getLast();
            if (last != null && last.getTimestampMillis() < timestamp - capacityMillis) {
                return;
            }
            linkedList.remove(last);
        }
    }
}}}

where, considering a scenario where this is continuously digesting log records at a helluva rate, we compose a <tt>!LinkedList</tt> rather than extend one, in order to prevent someone even considering a <tt>remove()</tt> or <tt>add()</tt> or some such interference - which would be bang of order, and as such, is a guaranteed encounter; a ticking timebomb - apt one might say, but still best avoided altogether.

Note that since we <tt>add()</tt> elements at the head of the list, so it's in reverse chronological order.

Crucially, when we <tt>add()</tt> an element at the head, we <tt>prune()</tt> older elements from the tail, so that our list is not growing out of control. 

In order to inspect the contents, we use <tt>getList()</tt>, which returns a defensive copy, and so is a helluva costly operation. Perhaps you could recommend an alternative strategy?

{{{
    public synchronized List<T> getList() {
        return getList(System.currentTimeMillis());
    }
    
    public synchronized List<T> getList(long millis) {
        prune(millis);
        return new ArrayList(linkedList);
    }

    public synchronized List<T> getSubList(int size) {
        if (linkedList.size() <= size) {
            return new ArrayList(linkedList);
        } else {
            return new ArrayList(linkedList.subList(0, size));
        }
    }    
}
}}}
where the <tt>getSubList()</tt> requests the latest so-many elements (or less). In this case we can display the last so-many elements (in reverse chronological order).

Let's test this thing. 

{{{
public class TimestampedListTest implements Runnable {

    long capacityMillis = 30;
    long scheduledInterval = 10;
    long scheduledDelay = 0;
    boolean verbose = false;
    final TimestampedList timestampedList = new TimestampedList(capacityMillis);
    ScheduledFuture future = Executors.newScheduledThreadPool(1).scheduleAtFixedRate(
            this, scheduledDelay, scheduledInterval, TimeUnit.MILLISECONDS);
            
    @Override
    public void run() {
        long timestamp = System.currentTimeMillis();
        String value = "record at " + timestamp;
        timestampedList.add(new TimestampedElement(value, timestamp));
        if (verbose) {
            System.out.println(value);
        }
    }
    
    @Test
    public void test() throws Exception {
        check();
        check();
        future.cancel(true);
    }    
}}}
where we schedule a thread to insert records all the while.

{{{    
    private void check() throws Exception {
        verbose = true;
        long startMillis = System.currentTimeMillis();
        Thread.sleep(capacityMillis);
        verbose = false;
        List<Timestamped> list = timestampedList.getList(startMillis + capacityMillis);
        SortedSet<Timestamped> set = new TreeSet(new TimestampedComparator());
        set.addAll(list);
        Assert.assertEquals("first", list.get(0).getTimestampMillis(), set.last().getTimestampMillis());
        Collections.reverse(list);
        Assert.assertEquals("last", list.get(0).getTimestampMillis(), set.first().getTimestampMillis());
        Assert.assertTrue("first", set.first().getTimestampMillis() >= startMillis);
        Assert.assertTrue("last time" , 
                set.last().getTimestampMillis() >= startMillis + capacityMillis - scheduledInterval);
        Assert.assertTrue("capacityMillis", 
                set.last().getTimestampMillis() - set.first().getTimestampMillis() <= capacityMillis);
        System.out.println("startMillis " + startMillis);
        System.out.println("first " + set.first().getTimestampMillis());
        System.out.println("last " + set.last().getTimestampMillis());
        System.out.println("size " + list.size());
        System.out.println("capacity " + (capacityMillis/scheduledInterval));
    }    
}}}

Given how unpredictable time is, ironically, we can't be sure of the size of the list. However, we find that changing a few <tt>assertTrue()</tt> to a <tt>System.out.println()</tt> makes all tests pass 100%, woohoo! <i>"Put that in your internet, put that in your twitter right there."</i>

{{{
record at 1340050675290
record at 1340050675300
record at 1340050675310
startMillis 1340050675281
first 1340050675290
last 1340050675310
size 3
capacity 3
}}}

We observe the output and nod, ponderously.

<h3>Resources</h3>

https://code.google.com/p/vellum/ - where i will collate these articles and their code.

<h2>Coming soon</h2>

We'll capture log records into our <tt>TimestampedList</tt>, and analyse a sample of logs e.g. for the last minute, to realise  when the wheels are starting to come off our app. 
