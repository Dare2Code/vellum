
<h4>Introduction</h4>

Encryption is great for information security and all that. But the problem with encryption is... key management. An analogy often bandied about is that we lock our doors but leave the key in the lock. <i>Or under the mat but that's my personal favourite, so ssh-ssh.</i>

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

So the Payment Card industry (PCI) has their "Data Security Standard" called "PCI DSS," which outlines best practices, that probably every industry should follow, in my opinion, because it's the only and best thing we got :)

The PCI DSS mandates that "PAN's" aka credit card numbers, must be "rendered unreadable" e.g. encrypted. But it goes without saying that other industries store their own sensitive data; governments too ;)

The PCI DSS standard suggests encrypting the key used to encrypt our data. Darn, we secure the data-encrypting-key (DEK), but now we're lumbered with another key, i.e. a "key-encrypting-key" (KEK). <i>The keys to the kindgom, woohoo!</i>

PCI requires that "dual control" and "split knowledge" be used to protect the PAN, i.e. our most secret data, i.e. the key used to cipher this data. The intent is that no single person can decrypt the data. 

The glaring problem is that sysadmins are a single person, with God-like access to secret data, and custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>
Naturally, <tt>keytool</tt> is tailored for a single omnipotent admin, not for "dual control" by two half-cocked ones. So we present a <tt>DualControlGenSecKey</tt> utility for generating secret keys that are really secret, i.e. they are not "accessible" to anyone, not even "root" ;)

But then our application can't access them either. <i>D'oh!</i> Actually, we can use the same tricks for dual-control of our application to load any keys it requires. <i>Woohoo!</i> But then starting our application requires two coordinated people. <i>D'oh!</i> So we'll present a companion crypto server with the dual-control, in a follow-up article.

<h4><tt>DualControlGenSecKey</tt></h4>

Step 1 for any data security procedure is to generate an encryption key, which ideally no single rogue root user can access. For this purpose, there shall be <tt>DualControlGenSecKey</tt>, as follows.

<pre>
public class DualControlGenSecKey { 
    int submissionCount = Integer.getInteger("dualcontrol.submissions", 3);
    String keyAlias = System.getProperty("alias"); 
    String keyStorePath = System.getProperty("keystore"); 
    String keyStoreType = System.getProperty("storetype");
    String keyAlg = System.getProperty("keyalg");
    int keySize = Integer.getInteger("keysize");
    
    public static void main(String[] args) throws Exception {        
        new DualControlGenSecKey().start(args);
    }

    void start() throws Exception {
        dualMap = new DualControlReader().readDualMap(keyAlias, submissionCount);
        keyStorePassword = getKeyStorePassword();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(keyAlg);
        keyGenerator.init(keySize);
        secretKey = keyGenerator.generateKey();
        keyStore = loadKeyStore(keyStorePath, keyStorePassword);
        KeyStore.Entry entry = new KeyStore.SecretKeyEntry(secretKey);
        for (String dualAlias : dualMap.keySet()) {
            char[] dualPassword = dualMap.get(dualAlias);
            String alias = keyAlias + "-" + dualAlias;
            KeyStore.ProtectionParameter prot = 
                    new KeyStore.PasswordProtection(dualPassword);
            keyStore.setEntry(alias, entry, prot);
        }
        keyStore.store(new FileOutputStream(keyStorePath), keyStorePassword);
    }
    ...
}
</pre>
where <tt>DualControlReader</tt> provides a map of "dual key" aliases and their secret passwords, and we create a entry for each. 

<h4>Demo</h4>

Let's test <tt>DualControlGenSecKey</tt>.

<pre>
  java -Ddualcontrol.submissions=3 \
     -Dkeystore=$keystore -Dstoretype=JCEKS -Dstorepass=$storepass \
     -Dalias=dek2013 -Dkeyalg=AES -Dkeysize=256 \
     dualcontrol.DualControlGenSecKey
</pre>

where we use a <tt>JCEKS</tt>-type keystore for our symmetric secret key, which is specified as 256bit AES, and "dek2013" is our desired alias to reference this key.  

When three admins have submitted their passwords via SSL TCP/IP socket e.g. where their client cert's <tt>CN</tt> identifies them as <tt>evanx</tt>, <tt>henty</tt> and <tt>brand</tt>, we see that <tt>DualControlGenSecKey</tt> saves the secret key under the following "dual-aliases."

<pre>
dek2013-brand-evanx
dek2013-brand-henty
dek2013-evanx-henty
</pre>

Lo and behold, these keys do seem to be have been created.

<pre>
$ keytool -keystore $keystore -storetype JCEKS -storepass $storepass -list | grep Entry
dek2013-brand-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-brand-evanx, 18 Aug 2013, SecretKeyEntry,
</pre>

Actually these three keys are one and the same. However each copy is password-protected using a different "dual-password" combination, known to no one.

<h4><tt>DualControlConsole</h4></tt>

In order for admins to submit their secrets to our <tt>DualControlReader</tt> e.g. from a ssh session on the <tt>localhost</tt>, we provide a minimal SSL client as follows.

<pre>
public class DualControlConsole {
    final static int PORT = 4444;
    final static String HOST = "127.0.0.1";

    public static void main(String[] args) throws Exception {
        Socket socket = DualControlKeyStores.createSSLContext().getSocketFactory().
                createSocket(HOST, PORT);
        DataInputStream dis = new DataInputStream(socket.getInputStream());
        String prompt = dis.readUTF();
        char[] passwd = System.console().readPassword(prompt);
        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
        dos.writeUTF(new String(passwd));
        socket.close();
    }    
}
</pre>
where we submit our password via SSL socket to our supposed dual-controlled app listening on port 4444 on the <tt>localhost</tt>. The server socket will take our username from the <tt>CN</tt> field of our client cert. 

<img align="right" src="http://jroller.com/evanx/resource/Gnome-preferences-desktop-personal-250-crop.png"/>

A known "bug" is that more Godly sysadmins can socially-engineer other less Godly admins to submit their passwords whilst a malicious socket server has been implanted by the most Godly one onto that frikking port! Other naughty tricks that come to mind is the creation of phantom admins, or the impersonation of other admins e.g. during a key generation procedure. 

The workaround for above "bugs," in plain management-speak, is that our "controls" as per our "policies and procedures" prevent or at least detect such attacks, and mitigate consequential risks. A follow-up article will offer some improvements to give admins some confidence that they are not having the wool pulled over their eyes.

<h4><tt>DualControlKeyStores</tt></h4>

Similarly to the standard <tt>-Dnet.javax.ssl.*</tt> command-line options that can be used to specify the default "keyStore" and "trustStore" for SSL sockets, we use <tt>-Ddualcontrol.ssl.keyStore</tt> et al, as below. 

Note that the "keyStore" parameter is our "private keystore" which contains the private key used for SSL e.g. for DSA assymmetric encryption. This should not be confused with our "secret key store" e.g. which contains an AES key for symmetric encryption of our secret data. 
 
<pre>
public class DualControlKeyStores {    
    static final String keyStorePath = System.getProperty("dualcontrol.ssl.keyStore");
    static final char[] keyStorePassword = getPassword("dualcontrol.ssl.keyStorePassword");
    static final char[] keyPassword = getPassword("dualcontrol.ssl.keyPassword");
    static final String trustStorePath = System.getProperty("dualcontrol.ssl.trustStore");
    static final char[] trustStorePassword = getPassword("dualcontrol.ssl.trustStorePassword");    
    
    public static char[] getPassword(String propertyName) {
        return System.getProperty(propertyName).toCharArray();
    }
    
    public static SSLContext createSSLContext() throws Exception {
        return createSSLContext(keyStorePath, keyStorePassword, keyPassword,
                trustStorePath, trustStorePassword);
    }
    ...
}
</pre>

where we create an <tt>SSLContext</tt> using these settings.

<h4><tt>DualControlReader</tt></h4>

Our <tt>DualControlReader</tt> utility class handles reading split knowledge submissions.

<pre>
public class DualControlReader {
    ...
    public Map<String, char[]> readDualMap(String prompt, int submissionCount) throws Exception {
        this.prompt = prompt;
        this.submissionCount = submissionCount;
        Map<String, char[]> map = new TreeMap();
        Map<String, char[]> submissions = readMap();
        for (String name : submissions.keySet()) {
            for (String otherName : submissions.keySet()) {
                if (name.compareTo(otherName) < 0) {
                    String dualAlias = String.format("%s-%s", name, otherName);
                    char[] dualPassword = combineDualPassword(
                            submissions.get(name), submissions.get(otherName));
                    map.put(dualAlias, dualPassword);
                }
            }
        }
        return map;
    }
</pre>

where we invoke <tt>readMap()</tt> to read split knowledge submissions from multiple admins.

<pre>
    private final static int PORT = 4444;
    private final static String LOCAL_ADDRESS = "127.0.0.1";
    private final static String REMOTE_ADDRESS = "127.0.0.1";
    ...
    Map<String, char[]> readMap() throws Exception {
        logger.info("Waiting for submissions on SSL port " + PORT);
        Map<String, char[]> map = new TreeMap();
        SSLServerSocket serverSocket = (SSLServerSocket) 
                DualControlKeyStores.createSSLContext().
                getServerSocketFactory().createServerSocket(PORT, submissionCount, 
                InetAddress.getByName(LOCAL_ADDRESS));
        serverSocket.setNeedClientAuth(true);
        for (int i = 0; i < submissionCount; i++) {
            SSLSocket socket = (SSLSocket) serverSocket.accept();
            if (!socket.getInetAddress().getHostAddress().equals(REMOTE_ADDRESS)) {
                throw new RuntimeException("Remote host address excluded");
            }
            String username = new X500Name(socket.getSession().getPeerPrincipal().
                    getName()).getCommonName();
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF(prompt);
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            char[] chars = dis.readUTF().toCharArray();
            if (true) { // TODO remove
                String[] fields = new String(chars).split(":");
                if (fields.length > 1) {
                    username = fields[0];
                    chars = fields[0].toCharArray();
                }
            }
            map.put(username, chars);
            socket.close();
        }
        serverSocket.close();
        return map;
    }
</pre>

where we listen on a SSL port i.e. an <tt>SSLServerSocket</tt> which we have hard-wired this to <tt>localhost</tt> i.e. via the loopback interface, where <tt>DualControlConsole</tt> invoked in local <tt>ssh</tt> sessions.

Note that the admin's username is determined from their SSL cert, namely the <tt>CN</tt> field.

Incidently, a known bug in the above code, and similarly in <tt>DualControlConsole</tt>, is that we sometimes create strings containing passwords. These will be cleared by the garbage collector at some stage, whereas a better practice is to exclusively use arrays, and clear these soonest.

<h4><tt>DualControlSessions</h4></tt>

We re-engineer our application to similarly get a dual-password, in order to load the key.

<pre>
public class DemoApp {
    private SecretKey dek;     
    ...
    private void loadKey(String keyStorePath, char[] storePass, String alias) throws Exception {
        dek = DualControlSessions.loadKey(keyStorePath, storePass, alias);
    }
}
</pre>

where the application loads keys as if it's too easy to be right, but the caveat is that execution is blocked whilst we are waiting for two admins to submit info via their <tt>DualControlConsole</tt>.

<pre>
public class DualControlSessions {

    public static SecretKey loadKey(String keyStorePath, char[] storePass, String alias) 
            throws Exception {
        char[] dualPass = null;
        try {
            KeyStore dualKeyStore = DualControlKeyStores.loadKeyStore(keyStorePath, storePass);
            Map.Entry<String, char[]> entry = DualControlReader.readDualEntry(alias);
            String dualAlias = entry.getKey();
            dualPass = entry.getValue();
            return (SecretKey) dualKeyStore.getKey(alias + "-" + dualAlias, dualPass);
        } finally {
            if (dualPass != null) {
                Arrays.fill(dualPass, (char) 0);            
            }
        }        
    }
}
</pre>

where we read the dual info using the afore-mentioned <tt>DualControlReader,</tt> which creates an <tt>SSLServerSocket</tt> on a well-known port, listens for connections and reads their submission e.g. using our <tt>DualControlConsole</tt> utility.

<h4>Cryto server</h4>

One might wish to create a central crypto server which is dualled-controlled, rather than burden your app. In that case, you can restart your application without dual-control, and indeed have any number of apps using this server. Furthermore it simplifies key management. 

We'll implement the crypto server in part 2. So we can say, "Dual control? We have an app for that." ;)

<h4>Conclusion</h4>

The problem with encryption is secure key management. It's like we lock the door but leave the key under the mat.

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

PCI requires that "dual control" and "split knowledge" be used to protect our sensitive data so that no single person can extract it, not even your most trustworthy employee today, rogue tomorrow.

Naturally, <tt>keytool</tt> is tailored for a single root admin, rather than "dual-control." 

If we have three admins e.g. A, B and C, then naturally we have three combinations of pairs of admins, namely A-B, B-C and A-C. In order to generate a dual-controlled key, we propose keeping three copies of the same key, but where each copy is password-protected with a different "dual-password" to be provided by a given pair of admins.

We introduce <tt>DualControlGenSecKey</tt> to generate a secret key in a JCEKS key store. This collates passwords from multiple admins using <tt>DualControlReader</tt>, which combines those into new "dual passwords" known to no <i>one</i> i.e. no single person.

To complete the picture, we provide a trivial <tt>DualControlConsole</tt> console utility for admins to submit their passwords via SSL sockets.

Finally, we demonstrate how our app can be dual-controlled to load a key from the store i.e. for ciphering data.

In a follow-up article, we'll implement a dual-controlled crypto server, so we avoid the burden of dual-control in our apps, isolate our keys on the crypto server, and thereby improve security and simplify key management. 

<h4>See also</h4>

You can browse the code for this exercise at <a href="http://code.google.com/p/vellum">code.google.com/vellum</a> in the <a href="https://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fdualcontrol"> <tt>dualcontrol</tt></a> package.