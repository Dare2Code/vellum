Encryption is great for information security and all that. But the problem with encryption is... key management. An analogy often bandied about is that we lock our doors but leave the key in the lock. <i>Or under the mat, but that's my personal favourite so ssh-ssh.</i>

<!--break-->

<p>   
<a style='{text-decoration: none;} :visited{color: black;}' href="https://code.google.com/p/vellum">
<div style="border-bottom: solid 1px; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/5/55/Gnome-security-medium.svg" border="0" align="left" hspace="0"/><span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Dual Control:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A cryptology of the "Enigma Posts"</span>
</div>
</a>

We hereby launch the new 2013 "Dual Control" cryptology, part of the <a href="http://code.google.com/p/vellum">Enigma Posts</a>.

<h4>PCI DSS</h4>

The "Payment Card Industry Data Security Standard" (<a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard">PCI DSS</a>) advocates common sense policies for building a secure network and protecting our data. Actually every enterprise should adopt PCI DSS because it's the only and best such thing we got. Although it focusses on credit card numbers (aka <i>Primary Account Numbers</i>, or PANs), it goes without saying that companies in other industries also have sensitive data that people might want to steal, governments even ;)

<img align=left style="margin-right: 16px" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

PCI DSS suggests encrypting our data-encryption key (DEK) in order to protect it. Great, we now have a "key-encryption key" (KEK) that requires even more protection ;)

PCI DSS mandates that manual key management requires "split knowledge and dual control" e.g. for key generation and loading. The intent is that no single person can extract the clear-text data. 

The glaring problem is that sysadmins are a single person, with god-like access to all our data, and de facto custodian of the proverbial keys to the kindgom. <i>Consequently sysadmins have root access ;)</i>

<h4>Solution overview</h4>

We'll split the knowledge of the key password between two admins, so it's known to no single person. Clearly dual control by those two admins is then required to load the key.

We propose keeping at least three copies of the same key in our keystore, where each copy is password-protected by a different "split password" pairing. Then if one admin is on vacation or otherwise indisposed, that's OK because we only require two admins to load the key when we restart our app.

<h4>DualControlGenSecKey</h4>

Step 1 for any data security endeavour is to generate an encryption key, which preferrably no one can pwn, not even root. Whereas keytool prompts for a password entered by a single admin, we introduce DualControlGenSecKey to handle multiple password submissions via SSL.

<pre>
public class DualControlGenSecKey {
    private int submissionCount;
    private String keyAlias;
    private String keyStoreLocation;
    private String keyStoreType;
    private String keyAlg;
    private int keySize;
    private char[] keyStorePassword;
    private Map<String, char[]> dualPasswordMap;
    private SSLContext sslContext;

    public DualControlGenSecKey(VellumProperties properties, MockableConsole console) {
        this.properties = properties;
        this.console = console;
        submissionCount = properties.getInt("dualcontrol.submissions", 3);
        keyStorePassword = properties.getPassword("storepass", null);
        keyAlias = properties.getString("alias");
    }

    public void init() throws Exception {
        sslContext = DualControlSSLContextFactory.createSSLContext(properties, console);
    }
    ...
}
</pre>

where we choose property names similar to keytool.

<pre>
    public static void main(String[] args) throws Exception {
        DualControlGenSecKey instance = new DualControlGenSecKey(
                new VellumProperties(System.getProperties()), 
                new ConsoleAdapter(System.console()));
        try {
            instance.init();
            instance.call();
        } catch (DualControlException e) {
            instance.console.println(e.getMessage());
        } finally {
            instance.clear();
        }
    }
    ...
}
</pre>
where our main() method passes System properties i.e. -D options, and the System console for entering the SSL keystore password.

<pre>
    public void call() throws Exception {
        keyStoreLocation = properties.getString("keystore");
        if (new File(keyStoreLocation).exists()) {
            throw new Exception("Keystore file already exists: " + keyStoreLocation);
        }
        if (keyStorePassword == null) {
            keyStorePassword = console.readPassword(
                    "Enter passphrase for keystore (%s): ", keyStoreLocation);
            if (keyStorePassword == null) {
                throw new Exception("No keystore passphrase from console");
            }
        }
        KeyStore keyStore = createKeyStore();
        keyStore.store(new FileOutputStream(keyStoreLocation), keyStorePassword);
    }

    public KeyStore createKeyStore() throws Exception {
        String purpose = "new key " + keyAlias;
        return buildKeyStore(
                new DaulControlManager(properties, submissionCount, purpose).
                readDualMap(sslContext));
    }
</pre>

where DaulControlManager provides a map of aliases and passwords, composed from submissions via SSL. We pass this dualPasswordMap to the buildKeyStore() method below.
<pre>      
    public KeyStore buildKeyStore(Map<String, char[]> dualPasswordMap) throws Exception {
        keyAlias = properties.getString("alias");
        keyStoreType = properties.getString("storetype");
        keyAlg = properties.getString("keyalg");
        keySize = properties.getInt("keysize");
        KeyGenerator keyGenerator = KeyGenerator.getInstance(keyAlg);
        keyGenerator.init(keySize);
        SecretKey secretKey = keyGenerator.generateKey();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        setEntry(keyStore, secretKey, keyAlias, dualPasswordMap);
        return keyStore;
    }

    private static void setEntry(KeyStore keyStore, SecretKey secretKey,
            String keyAlias, Map<String, char[]> dualPasswordMap) throws Exception {
        KeyStore.Entry entry = new KeyStore.SecretKeyEntry(secretKey);
        for (String dualAlias : dualPasswordMap.keySet()) {
            char[] dualPassword = dualPasswordMap.get(dualAlias);
            String alias = keyAlias + "-" + dualAlias;
            KeyStore.ProtectionParameter prot =
                    new KeyStore.PasswordProtection(dualPassword);
            keyStore.setEntry(alias, entry, prot);
        }
    }
</pre>

where for each duo we programmatically create a KeyStore entry containing the same key, but protected by a different split password, i.e. known to no single person :)

In general one might argue that we should not write code per se, but rather tests with accompanying code, hand in glove. Well, we've done that in this case, for a change ;)
<pre>
    @Test
    public void testGenKeyStore() throws Exception {
        dualPasswordMap.put("brent-evanx", "bbbb+eeee".toCharArray());
        dualPasswordMap.put("brent-henty", "bbbb+hhhh".toCharArray());
        dualPasswordMap.put("evanx-henty", "eeee+hhhh".toCharArray());
        properties.put("alias", "dek2013");
        properties.put("storetype", "JCEKS");
        properties.put("keyalg", "AES");
        properties.put("keysize", "192");
        DualControlGenSecKey instance = new DualControlGenSecKey();
        KeyStore keyStore = instance.buildKeyStore(properties, dualPasswordMap);
        assertEquals(3, Collections.list(keyStore.aliases()).size());
        assertEquals("dek2013-brent-evanx", Lists.asSortedSet(keyStore.aliases()).first());
        SecretKey key = getSecretKey(keyStore, "dek2013-brent-evanx", "bbbb+eeee".toCharArray());
        assertEquals("AES", key.getAlgorithm());
        assertTrue(Arrays.equals(key.getEncoded(), getSecretKey(keyStore, 
                "dek2013-brent-henty", "bbbb+hhhh".toCharArray()).getEncoded()));
    }
</pre>

where we inspect the KeyStore returned by the buildKeyStore() method, which is exposed especially for this unit test.

<h4>Usage demo</h4>

Let's run DualControlGenSecKey from the command-line.

<pre>
  java -Ddualcontrol.submissions=3 -Ddualcontrol.minPasswordLength=8 \
     -Dkeystore=$keystore -Dstoretype=JCEKS -Dstorepass=$storepass \
     -Dalias=dek2013 -Dkeyalg=AES -Dkeysize=256 \
     dualcontrol.DualControlGenSecKey
</pre>

where we use a JCEKS-type keystore for our symmetric secret key, generated as 256bit AES, and aliased as "dek2013."

For this example, three admins submit their passwords via SSL sockets where their client cert's CN identifies them as evanx, henty and brent. 

<pre>
INFO [DaulControlManager] readDualMap submissionCount: 3
INFO [DaulControlManager] readDualMap purpose: new key dek2013
INFO [DaulControlManager] readSubmissions SSL port 4444
INFO [DaulControlManager] Received evanx
INFO [DaulControlManager] Received henty
INFO [DaulControlManager] Received brent
INFO [DaulControlManager] readDualMap dualAlias: brent-evanx
INFO [DaulControlManager] readDualMap dualAlias: brent-henty
INFO [DaulControlManager] readDualMap dualAlias: evanx-henty
INFO [DualControlGenSecKey] alias dek2013-brent-evanx
INFO [DualControlGenSecKey] alias dek2013-brent-henty
INFO [DualControlGenSecKey] alias dek2013-evanx-henty
</pre>

We see that DualControlGenSecKey creates secret key entries under the following "dual aliases."

<pre>
$ keytool -keystore $keystore -storetype JCEKS -storepass $storepass -list | grep Entry
dek2013-brent-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-evanx-henty, 18 Aug 2013, SecretKeyEntry, 
dek2013-brent-evanx, 18 Aug 2013, SecretKeyEntry,
</pre>

Actually these three keys are one and the same! However each copy has a different "split password," which is a combination of a pair of personal passwords. Consequently the key password is "known to no single person" as per PCI DSS requirements :)

<h4>Furthermore</h4>

In the next article in this series, we will present DualControlConsole for submitting split passwords via SSL, as required for the above demo. 

Thereafter we will present DualControlManager, as used by DualControlGenSecKey to combine these passwords. We will demonstrate how DualControlManager is similarly used by our app to load a key, with dual control. 

<h4>Conclusion</h4>

The problem with encryption is secure key management. We shouldn't leave the key under the mat.

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

PCI requires that "split knowledge and dual control" be used to protect our data-encryption key so that no single person can extract the data in clear-text, not even our most trustworthy employee today, rogue tomorrow.

We present a DualControlGenSecKey utility for generating secret keys that are really secret. We protect the data-encryption keys using password-based encryption, courtesy of JCEKeyStore. We enable split knowledge of the key password, so that dual control is required to load the key.

We propose keeping at least three copies of the same key, but where each copy is password-protected by a different pair of admins. Then if one admin is on vacation or otherwise indisposed, that's OK because we only require two admins to load the key when we restart our app.

<h4>Further reading</h4>

See an extended preview article: <a href="https://code.google.com/p/vellum/wiki/DualControl">code.google.com/p/vellum/wiki/DualControl</a>.

<h4>Resources</h4>

You can browse the code for this exercise at <a href="http://code.google.com/p/vellum">code.google.com/vellum</a> in the <a href="https://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fdualcontrol">dualcontrol</a> package.

<a href="https://twitter.com/evanxsummers" class="twitter-follow-button" data-show-count="false">@evanxsummers</a>
