
The Google Authenticator mobile app, Chrome extension, et al, implement the IETF RFC6238 time-based one-time-password standard,
which hashes the time since the epoch with a secret using the HMAC-SHA1 algorithm. 

Besides enabling multi-factor authentication for our own Google account, how would we employ Google Authenticator for our own websites?!

<!--break-->

<h4>Prequels</h4>

A few years ago i wrote a series of Java crypto articles on this blog, which have been collated on https://code.google.com/p/vellum/ in wiki format, but otherwise not updated. Herewith starts a new rehashed crypto series that will tear down that previous series. 

<p>   
<a style='text-decoration: none;' href="https://code.google.com/p/vellum/wiki/home">
<div style="border-bottom: solid 1px; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/5/55/Gnome-security-medium.svg" border="0" align="left" hspace="0"/><span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Google Authenticator thus enabled:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A part of "The Enigma Posts: a trilogy in a few parts."</span>
</div>
</a>
    
Probably you've heard of the Google Authenticator? See http://en.wikipedia.org/wiki/Google_Authenticator.

<img src="http://jroller.com/evanx/resource/chrome-gauth-topt.png"/>

Should one should install this app on one's phone, or use the Chrome extension, and change one's google account to require the 2-factor authentification? Absolutely! Do it now! :)
On https://www.google.com/settings/security.

<img src="http://jroller.com/evanx/resource/google-accounts-security-window.png"/>

This Google Authenticator app is the client-side implementation of TOTP i.e. a time-based one-time password algorithm. 
In particular, it is an implementation of the IETF RFC6238 TOTP standard (see http://tools.ietf.org/html/rfc6238).

<img src="http://jroller.com/evanx/resource/google-auth-android.png"/>

Each account you configure on your Google Authenticator has a stored secret. The app itself shows the time-based code for each account.
This code is actually the epoch time in 30 second intervals, hashed with the secret using the HMAC-SHA1 algorithm. 
(see http://en.wikipedia.org/wiki/Hash-based_message_authentication_code).

So how do we support Google Authenticator for 2-factor authentication for logins to our own sites?

<h4>Generate random secret, Base32 encoded</h4>

For each user, we generate a random secret to enable 2-factor authentication.

<pre>
public class GenerateSecret {
    Logr logger = LogrFactory.getLogger(getClass());

    void test() {
        byte[] buffer = new byte[10];
        new Random().nextBytes(buffer);
        String secret = new String(new Base32().encode(buffer));
        logger.info("secret " + secret);
    }

    public static void main(String[] args) {
        new GenerateSecret().test();
    }
}
</pre>

where the secret is a 10 byte random number, which is encoded using Base32 (see (see http://en.wikipedia.org/wiki/Base32).

This produces a 16 character string consisting of characters A-Z and 2-7.

<pre>
secret OVEK7TIJ3A3DM3M6
</pre>

<i>(For entering codes into mobiles, a mixed alpha and numeric secret is not uber-convenient, so i personally would prefer alpha only, but take that with a pinch of salt. Perhaps an additional numeric code could be the salt, heh heh).</i>

The user creates a new account on their Google Authenticator app, entering this secret.

<h4>QR code</h4> 

Alternatively, one can use a Google URL as follows, to generate a QR barcode, for the user to scan, using their Google Authenticator app.

<pre>
    String secret = "OVEK7TIJ3A3DM3M6";
    String user = "evanx";
    String host = "beethoven";
    
    public static String getQRBarcodeURL(String user, String host, String secret) {
        String chl = "otpauth%3A%2F%2Ftotp%2F" + user + '@' + host + "%3Fsecret%3D" + secret;
        System.out.println(Strings.decodeUrl(chl));
        return "http://chart.apis.google.com/chart?chs=200x200&chld=M%%7C0&cht=qr&chl=" + chl;
    }

    void test() throws Exception {
        System.out.println(getQRBarcodeURL(user, host, secret));
    }
}
</pre>

<pre>
otpauth://totp/evanx@beethoven?secret=OVEK7TIJ3A3DM3M6
</pre>

<img src="http://chart.apis.google.com/chart?chs=200x200&chld=M%%7C0&cht=qr&chl=otpauth%3A%2F%2Ftotp%2Fevanx@beethoven%3Fsecret%3DOVEK7TIJ3A3DM3M6"/>

(You can right-click on the above link, and scan the barcode into your Google Authenticator, to test it!)

<img src="http://jroller.com/evanx/resource/google-qr.png"/>

Having scanned this into your Google Authenticator app, it will display the time-varying code for this account, together with your other accounts.

<h4>Authentication</h4> 

When users login, they then enter the current code, which changes every 30 seconds on their phone.

On the server, to authenticate this, first we get the current time index i.e. the number of 30s intervals since the epoch.

<pre>
    public static long getTimeIndex() {
        return System.currentTimeMillis()/1000/30;
    }
</pre>

We can then calculate the authentication code, for this exact time, using the user's secret.

<pre>
    private static long getCode(byte[] secret, long timeIndex) throws NoSuchAlgorithmException, InvalidKeyException {
        SecretKeySpec signKey = new SecretKeySpec(secret, "HmacSHA1");
        ByteBuffer buffer = ByteBuffer.allocate(8);
        buffer.putLong(timeIndex);
        byte[] timeBytes = buffer.array();
        Mac mac = Mac.getInstance("HmacSHA1");
        mac.init(signKey);
        byte[] hash = mac.doFinal(timeBytes);
        int offset = hash[19] & 0xf;
        long truncatedHash = hash[offset] & 0x7f;
        for (int i = 1; i < 4; i++) {
            truncatedHash <<= 8;
            truncatedHash |= hash[offset + i] & 0xff;
        }
        return (truncatedHash %= 1000000);
    }
</pre>

The problem is the mobile's clock might be out by a minute or two (or indeed our workstation which we are using a test server), so we need to check codes for a few time indexes before and after the actual time. Hopefully it goes without saying that servers always have the correct time thanks to NTP ;)

<pre>
    public static boolean verifyCode(String secret, int code, long timeIndex, int variance) throws Exception {
        byte[] secretBytes = new Base32().decode(secret);
        for (int i = -variance; i <= variance; i++) {
            if (getCode(secretBytes, timeIndex + i) == code) {
                return true;
            }
        }
        return false;
    }
</pre>

We can add the Google Authenticator Chrome extension to test and compare.

<img src="http://jroller.com/evanx/resource/chrome-gauth-add.png"/>

The question arises how to handle the event of a user loosing their phone? So I guess in addition to "Lost Password," one wants "Lost phone" button to enable users to reset their TOTP secret :)

<h4>Conclusion</h4> 

The Google Authenticator mobile app, Chrome extension, et al, implement the IETF RFC6238 time-based one-time-password standard.

Besides enabling multi-factor authentication for our own Google account, we can easily employ Google Authenticator for multi-factor authentication on our websites!

One just hashes the time since the epoch with a secret using the HMAC-SHA1 algorithm. In case the client's clock is a bit out of whack, we must allow for that. 
 
<h3>Resources</h3>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - in this case, the <a href="http://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fvellumdemo%2Ftotp"><tt>totp</tt> directory.

