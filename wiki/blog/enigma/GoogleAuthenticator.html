
The Google Authenticator mobile apps implement an IETF time-based one-time-password standard. This hashes the time, with a shared secret using the HMAC-SHA1 algorithm, to generate a one-time password.

But besides enabling multi-factor authentication for our own Google account, how would we employ Google Authenticator clients for our own websites?!

<!--break-->

<h4>Prequels</h4>

A few years ago i emitted a series of Java crypto articles on this blog, which have been collated on https://code.google.com/p/vellum in wiki format, but otherwise not updated or patched up e.g. the old "Password Hash" article there neglects to add salt! Anyways, herewith starts a new crypto series to rehash the past, and decipher the future.

<p>   
<a style='text-decoration: none;' href="https://code.google.com/p/vellum/wiki/home">
<div style="border-bottom: solid 1px; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/5/55/Gnome-security-medium.svg" border="0" align="left" hspace="0"/><span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Google Authenticator thus enabled:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A part of "The Enigma Posts: a trilogy in a few parts."</span>
</div>
</a>
    
Probably you've heard of the Google Authenticator? As in http://en.wikipedia.org/wiki/Google_Authenticator.

<img src="http://jroller.com/evanx/resource/chrome-gauth-topt.png"/>

But should one really install this app on one's phone, and add the Chrome extension to one's desktop browser, and change one's google account to require the 2-factor authentification? Absolutely! Do it now! :) On https://www.google.com/settings/security.

<img src="http://jroller.com/evanx/resource/google-accounts-security-window.png"/>

So the <a href="http://code.google.com/p/google-authenticator">Google Authenticator</a> is a client-side implementation of the <a href="http://tools.ietf.org/html/rfc6238">IETF RFC6238</a> standardized <a href="http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">"time-based one-time password algorithm" (TOTP)</a>.

Each account you configure on your Google Authenticator has a stored secret, shared with your web account. The app displays the time-based code for each account, which changes every 30 seconds. This code is indeed the number of 30 second intervals since the UNIX time epoch, hashed with that shared secret using <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">the HMAC-SHA1 algorithm</a>.

<img src="http://jroller.com/evanx/resource/google-auth-android.png"/>

See on http://code.google.com/p/google-authenticator that it also supports the counter-based <a href="http://en.wikipedia.org/wiki/HOTP">HMAC-Based One-time Password (HOTP) algorithm</a> specified in <a href="https://tools.ietf.org/html/rfc4226">RFC 4226</a>, which we ignore here and leave for another article perhaps.

So the question arises, how could we support Google Authenticator clients for multi-factor authentication of logins on our own websites that we build?

<h4>Generate random secret in Base32</h4>

For each user account, we must generate a random secret for the Google Authenticator client.

<pre>
public class GenerateSecret {
    Logr logger = LogrFactory.getLogger(getClass());

    void test() {
        byte[] buffer = new byte[10];
        new Random().nextBytes(buffer);
        String secret = new String(new Base32().encode(buffer));
        logger.info("secret " + secret);
    }

    public static void main(String[] args) {
        new GenerateSecret().test();
    }
}
</pre>
where the secret is a 10 byte random number, which is encoded using <a href="http://en.wikipedia.org/wiki/Base32">Base32</a> (<a href="http://tools.ietf.org/html/rfc3548">RFC3548</a>).

This produces a 16 character string consisting of the characters A-Z and 2-7.
<pre>
secret OVEK7TIJ3A3DM3M6
</pre>

The user creates a new account on their Google Authenticator app, entering this secret.

<img src="http://jroller.com/evanx/resource/chrome-gauth-add.png"/>

For entering codes into mobiles, we find that mixed alpha and numeric secret is not uber-convenient, so one would prefer alpha only. For convenience, one might reorder that secret e.g. OVEKTIJADMM73336, albeit thereby loosing some of its randomness. But take any of my suggestions with a pinch of salt. Heh heh, a crypto pun!

<h4>QR code</h4> 

Alternatively, one can generate a QR barcode e.g. using the Google Chart API service, for the user to scan into their Google Authenticator app.
<pre>
    String secret = "OVEK7TIJ3A3DM3M6";
    String user = "evanx";
    String host = "beethoven";

    void test() throws Exception {
        System.out.println(getQRBarcodeOtpAuthURL(user, host, secret));
        System.out.println(Strings.decodeUrl(getQRBarcodeURLQuery(user, host, secret)));
        System.out.println(getQRBarcodeURL(user, host, secret));
    }
    
    public static String getQRBarcodeURL(String user, String host, String secret) {
        return "http://chart.apis.google.com/chart?" + getQRBarcodeURLQuery(user, host, secret);
    }

    public static String getQRBarcodeURLQuery(String user, String host, String secret) {
        return "chs=200x200&chld=M%7C0&cht=qr&chl=" + 
                Strings.encodeUrl(getQRBarcodeOtpAuthURL(user, host, secret));
    }
   
    public static String getQRBarcodeOtpAuthURL(String user, String host, String secret) {
        return String.format("otpauth://totp/%s@%s&secret=%s", user, host, secret);
    }
</pre>
where the QR code encodes the following URL.
<pre>
otpauth://totp/evanx@beethoven?secret=OVEK7TIJ3A3DM3M6
</pre>
The QR code can be rendered using the following Google Chart request.
<pre>
http://chart.apis.google.com/chart?chs=200x200&chld=M%7C0&cht=qr&chl=
otpauth%3A%2F%2Ftotp%2Fevanx%40beethoven%26secret%3DOVEK7TIJ3A3DM3M6
</pre>
Just for clarity, the following shows the decoded URL query.
<pre>
chs=200x200&chld=M|0&cht=qr&chl=otpauth://totp/evanx@beethoven&secret=OVEK7TIJ3A3DM3M6
</pre>

So we use this Google Chart service to render the QR code onto our computer screen so we can scan it into our phone's Google Authenticator app. <i>Otherwise we have to be poking those tiny buttons with our fat fingers again.</i>

http://chart.apis.google.com/chart?chs=200x200&chld=M%7C0&cht=qr&chl=otpauth%3A%2F%2Ftotp%2Fevanx@beethoven%3Fsecret%3DOVEK7TIJ3A3DM3M6

You can right-click on the above link, and scan the barcode into your Google Authenticator, to test it. <i>Wow, it works! So cool... :)</i> You might get prompted to install a barcode scanner first, which is so easy ;)

<img src="http://jroller.com/evanx/resource/google-qr.png"/>

Having scanned this into our Google Authenticator app, it will display the time-varying code for this account, together with our other accounts. Woohoo!

<img src="http://jroller.com/evanx/resource/google-auth-android.png"/>

<h4>Authentication</h4> 

So when users login to our site, they enter the current 6-digit OTP code displayed on their phone for their account on our website, where this OTP changes every 30 seconds. To authenticate this on the server-side, first we get the current time index i.e. the number of 30s intervals since the UNIX time epoch.

<pre>
  public static long getTimeIndex() {
    return System.currentTimeMillis()/1000/30;
  }
</pre>

So far, soooo easy :)

We can then calculate the authentication code, for this exact time, using the user's secret.

<pre>
  private static long getCode(byte[] secret, long timeIndex) 
          throws NoSuchAlgorithmException, InvalidKeyException {
    SecretKeySpec signKey = new SecretKeySpec(secret, "HmacSHA1");
    ByteBuffer buffer = ByteBuffer.allocate(8);
    buffer.putLong(timeIndex);
    byte[] timeBytes = buffer.array();
    Mac mac = Mac.getInstance("HmacSHA1");
    mac.init(signKey);
    byte[] hash = mac.doFinal(timeBytes);
    int offset = hash[19] & 0xf;
    long truncatedHash = hash[offset] & 0x7f;
    for (int i = 1; i < 4; i++) {
        truncatedHash <<= 8;
        truncatedHash |= hash[offset + i] & 0xff;
    }
    return (truncatedHash %= 1000000);
  }
</pre>

where the time index is put into an 8-byte array, and <tt>HmacSHA1</tt>-hashed to give us 20 bytes. The first nibble (4-bits) of the last byte is taken as an offset (in the range 0 to 15) into the 20-byte array. Four bytes from the offset are then extracted, with the highest-order bit zero'ed. So we have an unsigned zero-based number with a maximum value is 2^31 minus 1 i.e. <tt>Integer_MAX_VALUE</tt> i.e. 2,147,483,647. Finally we take the lower 6 decimal digits as our one-time password code.

Now the problem is the mobile's clock might be out by a minute or two (or indeed our workstation which we are using a test server), so we need to check codes for a few time indexes before and after the supposed time. (Hopefully it goes without saying that servers always have the correct time thanks to NTP ;)

<pre>
  public static boolean verifyCode(String secret, int code, long timeIndex, 
      int variance) throws Exception {
    byte[] secretBytes = new Base32().decode(secret);
    for (int i = -variance; i <= variance; i++) {
        if (getCode(secretBytes, timeIndex + i) == code) {
            return true;
        }
    }
    return false;
  }
</pre>

So let's test this!

<pre>
    void test() throws Exception {
        System.out.println("time: " + getTimeIndex());
        System.out.println("code: " +  getCode(secret, getTimeIndex()));
        System.out.println("codes: " + getCodeList(secret, getTimeIndex(), 5));
        System.out.println("verify: " + verifyCode(secret, testCode, testTimeIndex, 5));
    }
</pre>

<pre>
time: 45076085
code: 766710
codes: [192262, 720538, 629431, 92289, 937348, 766710, 74053, 425245, 738189, 469760, 486815]
verify: true
</pre>

We can add the GAuth Chrome extension to our browser to test and compare :)

<img src="http://jroller.com/evanx/resource/gauth.png"/>

Finally, the question arises how to handle the event of a user loosing their phone (and TOPT secret)? So I guess in addition to the "Forgot Password" one wants a "Lost phone" button ;) That is, to enable users to reset their TOTP secret.

<h4>Conclusion</h4> 

The Google Authenticator mobile apps, and Chrome extension, et al, implement the IETF RFC6238 time-based one-time-password standard. This hashes the time since the epoch with a shared secret, using the HMAC-SHA1 algorithm, i.e. a SHA1 hash-based message authentication code.

Besides enabling multi-factor authentication for our personal Google account, we can easily employ Google Authenticator for multi-factor authentication on our websites!

We just hash the number of 30s time intervals since the epoch, with a secret using the HMAC-SHA1 algorithm. The only slight complication, is that in case the client's clock is a bit out of whack, we must allow some leniency for that. 

<h4>Coming up</h4>

In an upcoming article we'll build a sample site using a <a href="http://twitter.github.com/bootstrap/getting-started.html#examples">Twitter Bootstrap</a> template, adding "Login with Google" via their <a href="https://developers.google.com/accounts/docs/OAuth2">OAuth 2.0 API</a>, and last but not least, password hashing, with salt!
and of course T-OTP with Google Authenticator.

Also we should probably consider counter-based <a href="http://en.wikipedia.org/wiki/HOTP">HOPT</a>, since we might be missing a trick there.

<h4>Resources</h4>

https://code.google.com/p/vellum/ - where i will collate these articles and their code - see the <a href="http://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fvellumdemo%2Ftotp"><tt>vellumdemo.totp</tt></a> directory.

<h4>Link list</h4>

http://en.wikipedia.org/wiki/Hash-based_message_authentication_code.
http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm
http://en.wikipedia.org/wiki/HOTP
http://tools.ietf.org/html/rfc6238
https://tools.ietf.org/html/rfc4226
http://code.google.com/p/google-authenticator


