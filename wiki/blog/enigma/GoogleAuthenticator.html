
The Google Authenticator mobile apps implement an IETF time-based one-time-password standard. This hashes the time, with a shared secret using the HMAC-SHA1 algorithm, to generate a one-time password.

But besides enabling multi-factor authentication for our personal Google account, how would we employ Google Authenticator clients for our own websites?!

<!--break-->

<h4>Prequels</h4>

A few years ago i emitted a series of Java crypto articles on this blog, which have been collated on https://code.google.com/p/vellum in wiki format, but otherwise not updated or patched up e.g. the old "Password Hash" article there neglects to add salt! Anyways, herewith starts a new crypto series to rehash the past, and decipher the future.

<p>   
<a style='text-decoration: none;' href="https://code.google.com/p/vellum/wiki/home">
<div style="border-bottom: solid 1px; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/5/55/Gnome-security-medium.svg" border="0" align="left" hspace="0"/><span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Google Authenticator thus enabled:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A part of "The Enigma Posts: a trilogy in a few parts."</span>
</div>
</a>
    
Probably you've heard of this <a href="http://en.wikipedia.org/wiki/Google_Authenticator">Google Authenticator</a> thingy?

<img src="http://jroller.com/evanx/resource/chrome-gauth-topt.png"/>

So let's blindly install this app on our phone, add the Chrome extension to our desktop browser, and change our Google account to require the 2-factor authentication on https://www.google.com/settings/security.

<img src="http://jroller.com/evanx/resource/google-accounts-security-window.png"/>

<h4>What is this Google Authenticator?</h4>

The <a href="http://code.google.com/p/google-authenticator">Google Authenticator</a> is a client-side implementation of a <a href="http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">"time-based one-time password algorithm" (TOTP)</a>, in particular <a href="http://tools.ietf.org/html/rfc6238">IETF RFC6238</a>.

Each account we configure on our Google Authenticator has a stored secret, shared with some web account. The app displays the time-based code for each secret, which changes every 30 seconds. This code is computed from the number of 30 second intervals since the UNIX time epoch, hashed with that shared secret using the <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC-SHA1 algorithm</a>. <i>Sooo simple! :)</i>

<img src="http://jroller.com/evanx/resource/google-auth-android.png"/>

We see on http://code.google.com/p/google-authenticator that it also supports the counter-based <a href="http://en.wikipedia.org/wiki/HOTP">HMAC-Based One-time Password (HOTP) algorithm</a> specified in <a href="https://tools.ietf.org/html/rfc4226">RFC 4226</a>, which we ignore here and leave for another article perhaps.

So the question arises, can we support Google Authenticator clients for multi-factor authentication on websites that we build? Let's explore what this would entail...

<h4>Random secret in Base32</h4>

For each user account, we generate a random secret for the Google Authenticator client.

<pre>
    void test() {
        byte[] buffer = new byte[10];
        new Random().nextBytes(buffer);
        String secret = new String(new Base32().encode(buffer));
        System.out.println("secret " + secret);
    }
</pre>
where the secret is a 10 byte random number, which is encoded using <a href="http://en.wikipedia.org/wiki/Base32">Base32</a> (<a href="http://tools.ietf.org/html/rfc3548">RFC3548</a>).

This produces a string that is 16 characters long, in particular the characters A-Z and 2-7.
<pre>
secret OVEK7TIJ3A3DM3M6
</pre>

The user creates a new account on their Google Authenticator app, entering this secret.

<img src="http://jroller.com/evanx/resource/chrome-gauth-add.png"/>

For entering codes into mobiles, we find that mixing alpha and numeric is not uber-convenient, and so one might reorder that secret e.g. OVEKTIJADMM73336, albeit thereby loosing some of its randomness. But take any of my suggestions with a pinch of salt. Heh heh, a crypto pun!

<h4>QR code</h4> 

Alternatively, one can generate a QR barcode e.g. using the Google Chart API service, for the user to scan into their Google Authenticator app.
<pre>
    String secret = "OVEK7TIJ3A3DM3M6";
    String user = "evanx";
    String host = "beethoven";

    void test() throws Exception {
        System.out.println(getQRBarcodeOtpAuthURL(user, host, secret));
        System.out.println(Strings.decodeUrl(getQRBarcodeURLQuery(user, host, secret)));
        System.out.println(getQRBarcodeURL(user, host, secret));
    }
    
    public static String getQRBarcodeURL(String user, String host, String secret) {
        return "http://chart.apis.google.com/chart?" + getQRBarcodeURLQuery(user, host, secret);
    }

    public static String getQRBarcodeURLQuery(String user, String host, String secret) {
        return "chs=200x200&chld=M%7C0&cht=qr&chl=" + 
                Strings.encodeUrl(getQRBarcodeOtpAuthURL(user, host, secret));
    }
   
    public static String getQRBarcodeOtpAuthURL(String user, String host, String secret) {
        return String.format("otpauth://totp/%s@%s&secret=%s", user, host, secret);
    }
</pre>
where the QR code encodes the following URL.
<pre>
otpauth://totp/evanx@beethoven?secret=OVEK7TIJ3A3DM3M6
</pre>
The QR code can be rendered using the following Google Chart request.
<pre>
http://chart.apis.google.com/chart?chs=200x200&chld=M%7C0&cht=qr&chl=
otpauth%3A%2F%2Ftotp%2Fevanx%40beethoven%26secret%3DOVEK7TIJ3A3DM3M6
</pre>
Just for clarity, the following shows the decoded URL query.
<pre>
chs=200x200&chld=M|0&cht=qr&chl=otpauth://totp/evanx@beethoven&secret=OVEK7TIJ3A3DM3M6
</pre>

So we use this Google Chart service to render the QR code onto our computer screen so we can scan it into our phone's Google Authenticator app. <i>Otherwise we have to be poking those tiny buttons with our fat fingers again.</i>

http://chart.apis.google.com/chart?chs=200x200&chld=M%7C0&cht=qr&chl=otpauth%3A%2F%2Ftotp%2Fevanx@beethoven%3Fsecret%3DOVEK7TIJ3A3DM3M6

You can right-click on the above link, and scan the barcode into your Google Authenticator, to test it. <i>Wow, it works! So cool... :)</i> You might get prompted to install a barcode scanner first, which is so easy ;)

<img src="http://jroller.com/evanx/resource/google-qr.png"/>

Having scanned this into our Google Authenticator app, it will display the time-varying code for this account, together with our other accounts. Woohoo!

<img src="http://jroller.com/evanx/resource/google-auth-android.png"/>

<h4>Authentication</h4> 

So when users login to our site, they enter the current 6-digit OTP code displayed on their phone for their account on our website, where this OTP changes every 30 seconds. To authenticate this on the server-side, first we get the current time index i.e. the number of 30s intervals since the UNIX time epoch.

<pre>
  public static long getTimeIndex() {
    return System.currentTimeMillis()/1000/30;
  }
</pre>

So far, soooo easy :)

We can then calculate the authentication code, for this time interval, using the user's secret.

<pre>
  private static long getCode(byte[] secret, long timeIndex) 
          throws NoSuchAlgorithmException, InvalidKeyException {
    SecretKeySpec signKey = new SecretKeySpec(secret, "HmacSHA1");
    ByteBuffer buffer = ByteBuffer.allocate(8);
    buffer.putLong(timeIndex);
    byte[] timeBytes = buffer.array();
    Mac mac = Mac.getInstance("HmacSHA1");
    mac.init(signKey);
    byte[] hash = mac.doFinal(timeBytes);
    int offset = hash[19] & 0xf;
    long truncatedHash = hash[offset] & 0x7f;
    for (int i = 1; i < 4; i++) {
        truncatedHash <<= 8;
        truncatedHash |= hash[offset + i] & 0xff;
    }
    return (truncatedHash %= 1000000);
  }
</pre>

where...
<ul>
    <li>The time index is put into an 8-byte array.
    <li>We use <tt>HmacSHA1</tt> to hash this array into 20 bytes.
    <li>The first nibble (4 bits) of the last byte is taken as an offset (from 0 to 15) into the 20-byte array. 
    <li>Four bytes from the offset are then extracted, with the highest-order bit zero'ed. So at this stage, i guess we have an unsigned zero-based 31-bit number with a maximum value of 2^31 minus 1 i.e. <tt>Integer.MAX_VALUE</tt> i.e. 2,147,483,647. 
    <li>We take the lower 6 decimal digits as our one-time password. Voila!
</ul>
Now the only problem is that the clocks might be out of whack by a minute or two (or indeed our workstation which we are using a test server). So we need to check codes for a few time indexes before and after the supposed time. Problem solved! <i>Hopefully it goes without saying that servers always have the correct time thanks to NTP, although you'd be surprised... ;)</i>

<pre>
  public static boolean verifyCode(String secret, int code, long timeIndex, 
      int variance) throws Exception {
    byte[] secretBytes = new Base32().decode(secret);
    for (int i = -variance; i <= variance; i++) {
        if (getCode(secretBytes, timeIndex + i) == code) {
            return true;
        }
    }
    return false;
  }
</pre>

So let's test this!

<pre>
    void test() throws Exception {
        System.out.println("time: " + getTimeIndex());
        System.out.println("code: " +  getCode(secret, getTimeIndex()));
        System.out.println("codes: " + getCodeList(secret, getTimeIndex(), 5));
        System.out.println("verify: " + verifyCode(secret, testCode, testTimeIndex, 5));
    }
</pre>

<pre>
time: 45076085
code: 766710
codes: [192262, 720538, 629431, 92289, 937348, 766710, 74053, 425245, 738189, 469760, 486815]
verify: true
</pre>

We can add the GAuth Chrome extension to our browser to compare, and of course the mobile app :)

<img src="http://jroller.com/evanx/resource/gauth.png"/>

Finally, the question arises how to handle the event of a user losing their phone (and TOTP secret)? So I guess in addition to a "Forgot Password" facility, one needs a "Lost phone" button ;) That is, we need to enable users to reset their TOTP secret, without that becoming the weak link. We'll address this another day ;)

<h4>Conclusion</h4> 

The Google Authenticator mobile apps implement the IETF RFC6238 time-based one-time-password standard. This hashes the time since the epoch with a shared secret using the HMAC-SHA1 algorithm.

Besides enabling multi-factor authentication for our personal Google account, we can easily employ Google Authenticator for multi-factor authentication on our websites. We hash the number of 30s time intervals since the epoch with a secret using the HMAC-SHA1 algorithm. 

A slight complication is that the clocks might be a bit out of sync, so we allow some leniency for that. 

<h4>Coming up</h4>

We should investigate the counter-based <a href="http://en.wikipedia.org/wiki/HOTP">HOTP</a>, since we might be missing a trick there?!

In an upcoming article, we'll build a sample site using a <a href="http://twitter.github.com/bootstrap/getting-started.html#examples">Twitter Bootstrap</a> <a href="http://code.google.com/p/vellum/source/browse/trunk/src/crocserver/web/bindex.html">template</a>, <a href="http://code.google.com/p/vellum/source/browse/trunk/src/crocserver/web/bindex.js">enabling</a> a "Login with Google" via that <a href="https://developers.google.com/accounts/docs/OAuth2">OAuth 2.0 API</a>, in addition to the usual <a href="http://code.google.com/p/vellum/source/browse/trunk/src/vellum/util/Passwords.java">hashed and salted password</a>, and of course this TOTP with Google Authenticator, with some sort of safe reset mechanism. For a <a href="https://croc.linuxd.org">sneak preview</a>, see the so-called <a href="http://code.google.com/p/vellum/source/browse/trunk/src/crocserver/#crocserver%2Fhttphandler%2Faccess"><tt>crocserver</tt></a> package under construction, including some <a href="http://code.google.com/p/vellum/source/browse/trunk/src/crocserver/web/bindex.html">html</a> and <a href="http://code.google.com/p/vellum/source/browse/trunk/src/crocserver/web/bindex.js">javascript</a>.

And then coming "soon" in 2013, we'll build out a crypto server called <a href="http://code.google.com/p/vellum/source/browse/trunk/src/venigma/#venigma%2Fserver"><tt>venigma</tt></a> :)

<h4>Resources</h4>

See https://code.google.com/p/vellum/ where i will collate these articles and their code, e.g. the <a href="http://code.google.com/p/vellum/source/browse/#svn%2Ftrunk%2Fsrc%2Fvellumdemo%2Ftotp"><tt>vellumdemo.totp</tt></a> package.

<h4>Link list</h4>

http://en.wikipedia.org/wiki/Hash-based_message_authentication_code.
http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm
http://en.wikipedia.org/wiki/HOTP
http://tools.ietf.org/html/rfc6238
http://tools.ietf.org/html/rfc4226
http://code.google.com/p/google-authenticator

And since it's this classic video that makes me want to add "thus enabled" to everything - even though Brent says "Android thus disabled" - ironically! :)

http://www.youtube.com/watch?v=XKXz2qDTiBU
