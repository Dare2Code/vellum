Ordinarily we create an SSLContext as follows.
<pre>
public class SSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPassword,
            KeyStore trustStore) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPassword);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("SunX509");
        trustManagerFactory.init(trustStore);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(keyManagerFactory.getKeyManagers(),
                trustManagerFactory.getTrustManagers(), new SecureRandom());
        return sslContext;
    }
}
</pre>
where we provide the keystore and truststore for this SSL context, which can be used to create an SSLServerSocket, or client SSLSocket.

Since we wish to support a local CA for client certificates, we should enable local certificate revocation in order to retain access control. For convenience, we'll revoke certificates by their common name (CN), which must be unique.

So we create an SSLContext with a set of revoked names, as follows.
<pre>
public class RevocableNameSSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPass,
            KeyStore trustStore, Set<String> revokedNames) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPass);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        TrustManager revocableTrustManager = new RevocableTrustManager(
                KeyStores.findSoleTrustedCertificate(keyStore),
                KeyStores.findX509TrustManager(trustStore),
                revokedNames);
        sslContext.init(keyManagerFactory.getKeyManagers(),
                new TrustManager[] {revocableTrustManager},
                new SecureRandom());
        return sslContext;
    }
}
</pre>
where we initialise a custom RevocableTrustManager with our client certificate issuer and a set of revoked names.
<pre>
public class RevocableTrustManager implements X509TrustManager {
    X509Certificate issuerCertificate;
    X509TrustManager delegate;
    Set<String> revokedNames;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        if (chain.length < 2) {
            throw new CertificateException("Invalid cert chain length");
        }
        if (!chain[0].getIssuerX500Principal().equals(
                issuerCertificate.getSubjectX500Principal())) {
            throw new CertificateException("Untrusted issuer");
        }
        if (!Arrays.equals(chain[1].getPublicKey().getEncoded(),
                issuerCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Untrusted issuer public key");
        }
        if (revokedNames.contains(Certificates.getCN(chain[0].getSubjectDN()))) {
            throw new CertificateException("Certificate CN revoked");
        }
        delegate.checkClientTrusted(chain, authType);
    }
}
</pre>
where we check that the client certificate is issued by our CA, and not revoked. Finally, we delegate to the standard <a href="http://www.docjar.org/html/api/javax/net/ssl/X509TrustManager.java.html">X509TrustManager</a> (implemented by <a href="http://www.docjar.org/html/api/sun/security/ssl/X509TrustManagerImpl.java.html">X509TrustManagerImpl</a>) for good measure, e.g. to validate the certificate chain, expiry dates and what not (using <a href="http://www.docjar.org/html/api/sun/security/validator/PKIXValidator.java.html">PKIXValidator</a>).

Since we use this trust manager on the server to validate clients, we know its checkServerTrusted() method is not needed.
<pre>
    @Override
    public void checkServerTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        throw new CertificateException("Server authentication not supported");
    }    
</pre>

<h4>Dynamic revocation</h4>

The set of revoked certificates' identifiers might be read from a file, URL or database. This could be a synchronized Set that can be updated concurrently, and so enables a dynamic truststore, which we test as follows.
<pre>
public class LocalCaTest {
    ...
    private void testDynamicNameRevocation(KeyStore serverKeyStore, KeyStore serverTrustStore,
            KeyStore clientKeyStore, KeyStore clientTrustStore, String revokedName) 
            throws Exception {
        Set<String> revokedNames = new ConcurrentSkipListSet();
        SSLContext serverSSLContext = RevocableNameSSLContexts.create(
                serverKeyStore, pass, serverTrustStore, revokedNames);
        SSLContext clientSSLContext = SSLContexts.create(clientKeyStore, pass, clientTrustStore);
        ServerThread serverThread = new ServerThread();
        try {
            serverThread.start(serverSSLContext, port, 2);
            Assert.assertNull(ClientThread.connect(clientSSLContext, port));
            Assert.assertNull(serverThread.getErrorMessage());
            revokedNames.add(revokedName);
            clientSSLContext = SSLContexts.create(clientKeyStore, pass, clientTrustStore);
            String errorMessage = ClientThread.connect(clientSSLContext, port);
            Assert.assertEquals("java.security.cert.CertificateException: " + 
                    "Certificate CN revoked", serverThread.getErrorMessage());
            Assert.assertNotNull(errorMessage);
        } finally {
            serverThread.close();
            serverThread.join(1000);
        }
    }
    ...
</pre>
where we create a concurrent Set for the revoked certificates, and revoke a client certificate after the server has been started. Before the certificate is revoked, the connection should succeed, and afterwards it should fail. 

Incidently, we find that the client session is cached for the SSL context, and so we recreate the clientSSLContext instance in our test above. This forces re-initialisation of the client session, and so re-authentication by the server, so that our trust manager is actually invoked and rejects our newly revoked certificate. Perhaps the reader can advise how to disable this client session caching for our unit test?

Our test connects to the server socket as follows.
<pre>
    static String connect(SSLContext context, int port) 
            throws GeneralSecurityException, IOException {
        SSLSocket socket = (SSLSocket) context.getSocketFactory().
                createSocket("localhost", port);
        try {
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF("clienthello");
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            Assert.assertEquals("serverhello", dis.readUTF());
            return null;
        } catch (Exception e) {
            return e.getMessage();
        } finally {
            socket.close();
        }
    }
</pre>
where we return the error message, otherwise null which indicates success.


<h4>Client keystore</h4>

For example, let's create a private SSL keystore for a test client named "evanx."
<pre>
$ keytool -keystore evanx.jks -genkeypair -keyalg rsa -keysize 2048 -validity 365 \
    -alias evanx -dname "CN=evanx"
</pre>
 
We print our certificate as PEM text using -rfc.
<pre>
$ keytool -keystore evanx.jks -alias evanx -exportcert -rfc
----BEGIN CERTIFICATE-----
...
</pre>
We cut and paste the exported PEM text into a file, which we can inspect using openssl.
<pre>
$ openssl x509 -text -in evanx.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1380030508 (0x5241982c)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: CN=evanx
        Validity
            Not Before: Sep 24 13:48:28 2013 GMT
            Not After : Sep 24 13:48:28 2014 GMT
        Subject: CN=evanx
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
...
</pre>
We might import the client's self-signed certificate into our server truststore.
<pre>
$ keytool -keystore server.trust.jks -alias evanx -importcert -file evanx.pem
</pre>
Similarly, our server's certificate is imported into this client's truststore.


<h4>Client certificate signing</h4>

We export a certificate signing request (CSR) to be signed by our local CA.
<pre>
$ keytool -keystore evanx.jks -alias evanx -certreq
</pre>
We cut and paste the output PEM text into a CSR file, and use Java7's keytool to sign this CSR, using its -gencert option, which by the way is not available in earlier JRE's.
<pre>
$ keytool -keystore ca.jks -gencert -validity 365 -rfc \
    -dname "CN=evanx" -infile evanx.csr -outfile evanx.signed.pem \
    -ext BasicConstraints:critical=ca:false,pathlen:0 \
    -ext KeyUsage:critical=digitalSignature \
    -ext ExtendedKeyUsage:critical=clientAuth
</pre>
where we specify an unchanged name and validity period for the newly signed certificate. We might add some extensions for good measure, i.e. to restrict key usage.

We can inspect the cert using openssl.
<pre>
$ openssl x509 -text -in evanx.signed.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 448957773 (0x1ac28d4d)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=ca
        Validity
            Not Before: Oct 16 20:02:24 2013 GMT
            Not After : Jul 11 20:02:24 2016 GMT
        Subject: CN=evanx
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
...
</pre>
We see that the X509v3 extensions are set as follows.
<pre>

            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Extended Key Usage: critical
                TLS Web Client Authentication
            X509v3 Key Usage: critical
                Digital Signature
</pre>
We compare these settings to a certificate bought from GoDaddy.com, for example.
<pre>
        X509v3 extensions:
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
</pre>
where our tests indicate that the "Digital Signature" usage is required for client authentication, and "Key Encipherment" is required for server authentication.

Since the keystore requires its key certificate chain to be imported in the correct order starting with the root cert, we import the CA cert first, and then our signed cert.
<pre>
$ keytool -keystore evanx.jks -importcert -noprompt \
    -file ca.pem -alias ca
Enter keystore password: 
Certificate was added to keystore

$ keytool -keystore evanx.jks -importcert -noprompt \
    -file evanx.signed.pem -alias evanx
Enter keystore password: 
Certificate reply was installed in keystore
</pre>
Otherwise if the parent chain is not present, we're balked by the following keytool error.
<pre>
keytool error: java.lang.Exception: Failed to establish chain from reply
</pre>

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

Incidently, in a follow-up article we will create keystores programmatically for our unit tests, taking cues from <a href="http://www.docjar.org/html/api/sun/security/tools/KeyTool.java.html">KeyTool.java</a>, to emulate the manual procedure presented here.


<h4>Client certificate management</h4>

Clearly a certificate with a duplicate CN impersonates the original certificate with that CN. So when issuing a client certificate, we must take care to ensure the uniqueness of its CN, and should add the certificate (or at least its unique identifier) to a registry of some sort. 

In order to review access, we clearly require a perfect record of all issued certificates. If a certificate is signed but not recorded, or its record is deleted, our server is forever vulnerable to that rogue certificate. 

We might record our signed certs into a keystore file as follows.
<pre>
$ keytool -keystore server.issued.jks -importcert -alias evanx -file evanx.pem 
Certificate was added to keystore
</pre>
where this is not a truststore per se, but just a database of issued certificates. 

Interestingly, we sign our client certificates to avoid having such a truststore containing all our client certificates, but nevertheless end up with one.


<h4>Self-signed client certificates</h4>

If our local CA is compromised by a breach, or abused by a rogue administrator, rogue certificates might be created. So we might prefer self-signed client certificates which are explicitly imported into our server truststore where they can be reviewed. 

However, self-signed client keys are effectively CA keys, and so rogue certificates can be created using compromised client keys, e.g. using keytool -gencert. So to protect our server against such rogue certificates, we might use an explicit trust manager as below, where the key certificate must be in the truststore. That is, the client's key certificate must be in the truststore, and it's chain is disregarded.
<pre>
public class ExplicitTrustManager implements X509TrustManager {
    Map<String, X509Certificate> certificateMap = new HashMap();
    X509TrustManager delegate;
    
    public ExplicitTrustManager(KeyStore trustStore) 
        throws GeneralSecurityException {
        this.delegate = KeyStores.findX509TrustManager(trustStore);
        for (String alias: Collections.list(trustStore.aliases())) {
            certificateMap.put(alias, (X509Certificate) 
                    trustStore.getCertificate(alias));
        }
    }
    ...
</pre>
where we build a map of the certificates in our truststore. 

We validate peer certificate chains as follows.
<pre>    
    private void checkTrusted(X509Certificate[] chain) 
            throws CertificateException {
        X509Certificate trustedCertificate = certificateMap.get(
                X509Certificates.getCN(chain[0].getSubjectDN()));
        if (trustedCertificate == null) {
            throw new CertificateException("Untrusted peer certificate");
        }
        if (!Arrays.equals(chain[0].getPublicKey().getEncoded(),
                trustedCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Invalid peer certificate");
        }
    }
</pre>
where we check that the first cert in the chain sent by the peer, is contained in our map.

We could use this trust manager equally on a client, as well as our server.
<pre>
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        checkTrusted(chain);
        delegate.checkClientTrusted(chain, authType);
    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        checkTrusted(chain);
        delegate.checkServerTrusted(chain, authType);
    }    
</pre>

<h4>Auto-import</h4>

The problem with client-authenticated connections is that enrollment is tedious, either requiring a certificate signing process, or otherwise importing the client's certificate in advance, before the client can connect. Clearly a new client cannot register itself via the client-authenticated connection. Moreover certificate expiry requires this process to be repeated regularly.

As a consequence of the inconvenience of client certificate generation, enrollment and renewal, browser certificates are not widely used for consumer sites i.e. for client-authenticated HTTPS. Typically cookies are used to record authenticated sessions, and these might be hijacked using <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting</a>, and used to spoof authenticated clients.

A further impediment to client-authenticated HTTPS sites is that they require a non-client-authenticated HTTPS server for enrollment. Unfortunately the standard port number is the same for both, i.e. 443, which is widely allowed by firewalls. Consequently two hosts are typically required, i.e. with different IP numbers.

So let's implement a dynamic truststore which enables us to support client-authenticated SSL connections, but where new clients can register via this same connection, via a custom trust manager. We wish to achieve convenience comparable to non-client-authenticated SSL connections, but with enhanced security e.g. preventing client spoofing attacks.

For example, we might trust a new client who submits a valid registration request, provide them with a PKCS12 key and certificate e.g. to import into their browser, and automatically import their certificate into our truststore.

<h4>SQL truststore</h4>

Our truststore might be an SQL database table with a column for the client certificate name, and another for the certificate itself.
<pre>
create table client_cert (
  cert_name text,
  cert text, 
  enabled boolean default false
);
</pre>
where the certificate would be Base64-encoded for SQL storage.

We might pre-approve new client devices that we are expecting to connect, by inserting a record with the certificate name but a null entry for the actual certificate. The certificate column is set later when the client connects for the first time. Also, we can revoke clients by setting the enabled column to false.

<h4>SSLSession</h4>

When we accept the connection to the SSLServerSocket, our application validates the request message, and can then import the peer certificate. Our application can get the client certificate via the SSLSession of the client SSLSocket, as demonstrated in the following test code.
<pre>
    static void accept(KeyStore keyStore, char[] keyPassword, KeyStore trustStore,
            int port) throws GeneralSecurityException, IOException {
        SSLContext sslContext = SSLContexts.create(keyStore, keyPassword, trustStore);
        SSLServerSocket serverSocket = (SSLServerSocket) sslContext.
                getServerSocketFactory().createServerSocket(port);
        try {
            serverSocket.setNeedClientAuth(true);
            SSLSocket clientSocket = (SSLSocket) serverSocket.accept();
            javax.security.cert.X509Certificate peer = 
                    clientSocket.getSession().getPeerCertificateChain()[0];
            logger.info("peer: " + peer.getSubjectDN().getName());
            ServerThread.handle(clientSocket);
        } finally {
            serverSocket.close();
        }
    }
</pre>

Our application might validate the content of the message, e.g. a registration request, and import the peer certificate into our dynamic truststore e.g. by updating the record in our SQL truststore.

<h4>Trust manager</h4>

Alternatively our trust manager itself might auto-import certificates. To this end, firstly let's implement a trivial trust manager to accept certificates using a delegate.
<pre>
public class DelegatingClientTrustManager implements X509TrustManager {
    TrustManagerDelegate delegate;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) 
            throws CertificateException {
        if (chain.length == 0) {
            if (!delegate.accept()) {
                throw new CertificateException("No certificate");
            }
        }
        if (!delegate.accept(chain[0])) {
            throw new CertificateException("Certificate not accepted");            
        }
    }
</pre>
where our delegate might accept clients without a certificate, i.e. without requiring client-authentication, where our application will authenticate the message.
<pre>
public class StorageTrustManagerDelegate implements TrustManagerDelegate {
    final private boolean requireCertificate;
    final private boolean autoInsert;
    final private CertificateStorage certificateStorage;
    
    public StorageTrustManagerDelegate(
            boolean requireCertificate, 
            boolean autoInsert, 
            CertificateStorage certificateStorage) {
        this.requireCertificate = requireCertificate;
        this.autoInsert = autoInsert;
        this.certificateStorage = certificateStorage;
    }
    ...
}
</pre>
For example, we might accept a client without an certificate in order to enable it to send a registration request for the server to generate a key and certificate on the client's behalf. For example, the server might respond to such a request with a <a href="http://en.wikipedia.org/wiki/PKCS_12">PKCS12</a> bundle.

In this case the server might sign the certificate, or import it into the truststore. Perhaps the certificate are initially disabled in the truststore database, pending manual approval by the appropriate administrator.

<h4>Certificate storage</h4>

We provide a mockable certificate storage implementation to our trust manager delegate.
<pre>
public interface CertificateStorage {
    public void insert(String commonName, X509Certificate cert) throws CertificateStorageException;
    public boolean exists(String commonName) throws CertificateStorageException;
    public boolean isNull(String commonName) throws CertificateStorageException;
    public void set(String commonName, X509Certificate cert) throws CertificateStorageException;
    public boolean isEnabled(String commonName) throws CertificateStorageException;
    public X509Certificate load(String commonName) throws CertificateStorageException;    
    public void update(String commonName, X509Certificate cert) throws CertificateStorageException;
}
</pre>
where if the record for that common name exists but has a null certificate, then isNull() returns true, and we can set() the certificate. If the certificate exists(), then we can load() it, and update() it i.e. if it has expired.
<pre>
    @Override
    public boolean accept(X509Certificate peerCertificate) throws CertificateException {
        String commonName = Certificates.getCommonName(peerCertificate.getSubjectDN());
        try {
            if (certificateStorage.exists(commonName)) {
                if (certificateStorage.isNull(commonName)) {
                    certificateStorage.set(commonName, peerCertificate);
                    return true;
                } else {
                    X509Certificate trustedCertificate = certificateStorage.load(commonName);
                    if (new Date().after(trustedCertificate.getNotAfter())) {
                        certificateStorage.update(commonName, peerCertificate);
                        return true;
                    } else if (certificateStorage.isEnabled(commonName)) {                        
                        return Arrays.equals(peerCertificate.getPublicKey().getEncoded(),
                                trustedCertificate.getPublicKey().getEncoded());
                    } else {
                        return false;
                    }
                }
            } else if (autoInsert) {
                certificateStorage.insert(commonName, peerCertificate);
                return true;
            } else {
                return false;                
            }
        } catch (CertificateStorageException e) {
            throw new CertificateException(e);
        }
    }
</pre>
where we check that an existing certificate is enabled i.e. has not been thereby revoked. If we auto-insert a new certificiate, then enabled might be false, where our application might enable it automatically following registration, or require an administrator to do so manually.


<h4>Conclusion</h4>

We can sign client certificates using a local CA root certificate. However, we should then support certificate revocation, e.g. to disable certificates for devices that have gone amiss. So we introduce a custom SSL trust manager to support a local revocation list.

<img align="right" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

Naturally, our SSL server resides in our DMZ, whereas we want to isolate our local CA on a secure internal server. Even so, we discuss the risk of rogue certificates signed by our CA, and argue that importing each client certificate into the truststore enables us to review access.

We note that self-signed client certificates are effectively CA certificates, and so can be used to create rogue certificates. So we present a custom trust manager to check that the peer's key certificate is in the truststore. 

Naturally, the keystore must contain the certificate chain of the key certificate, including root CA certificate, and if the keystore is misused as a truststore, then <i>any</i> certificate issued by that CA would be trusted. If we are using a public CA, then we would trust any certiticate issued by that CA, not just our own.

Finally, we introduce a trust manager to enable automated registration, where new clients' certificates are imported into our truststore when they connect for the first time, and thereafter we validate our clients' certificates, to protect against spoofing attacks.


<h4>Furthermore</h4>

We'll delve into the unit testing of our custom trust manager in a follow-up article. Thereafter, we might implement a local CA management tool that records issued certificates, and supports standard CRLs, or ideally a local CA server that supports the <a href="http://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">Online Certificate Status Protocol</a>.

<h4>Resources</h4>

You can browse the code for this exercise on <a href="https://code.google.com/p/vellum">code.google.com/vellum</a>.

<h4>Other reading</h4>

Also relating to Java crypto in this blog: <a href="https://weblogs.java.net/blog/evanx/archive/2013/01/24/password-salt">Password Salt</a> for secure passwords; and leveraging the <a href="https://weblogs.java.net/blog/evanx/archive/2012/11/07/google-authenticator-thus-enabled">Google Authenticator</a> mobile app for multi-factor authentication for your own sites.

