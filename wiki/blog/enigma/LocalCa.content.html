Ordinarily we create an SSLContext as follows.
<pre>
public class SSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPassword,
            KeyStore trustStore) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPassword);
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance("SunX509");
        trustManagerFactory.init(trustStore);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(keyManagerFactory.getKeyManagers(),
                trustManagerFactory.getTrustManagers(), new SecureRandom());
        return sslContext;
    }
}
</pre>

Since we wish to support a local CA for client certificates, we should enable local certificate revocation in order to retain access control. For convenience, we'll revoke certificates by their common name (CN), which must be unique.

So we create an SSLContext with a set of revoked names, as follows.
<pre>
public class RevocableNameSSLContexts {
    ...
    public static SSLContext create(KeyStore keyStore, char[] keyPass,
            KeyStore trustStore, Set<String> revokedNames) throws Exception {
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
        keyManagerFactory.init(keyStore, keyPass);
        SSLContext sslContext = SSLContext.getInstance("TLS");
        TrustManager revocableTrustManager = new RevocableTrustManager(
                KeyStores.findSoleTrustedCertificate(keyStore),
                KeyStores.findX509TrustManager(trustStore),
                revokedNames);
        sslContext.init(keyManagerFactory.getKeyManagers(),
                new TrustManager[] {revocableTrustManager},
                new SecureRandom());
        return sslContext;
    }
}
</pre>
where we initialise a custom RevocableTrustManager with our signing cert, and a set of revoked names.
<pre>
public class RevocableTrustManager implements X509TrustManager {
    X509Certificate issuerCertificate;
    X509TrustManager delegate;
    Set<String> revokedNames;
    ...
    @Override
    public void checkClientTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        if (certs.length < 2) {
            throw new CertificateException("Invalid cert chain length");
        }
        if (!certs[0].getIssuerX500Principal().equals(
                issuerCertificate.getSubjectX500Principal())) {
            throw new CertificateException("Untrusted issuer");
        }
        if (!Arrays.equals(certs[1].getPublicKey().getEncoded(),
                issuerCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Untrusted issuer public key");
        }
        if (revokedNames.contains(X509Certificates.getCN(certs[0].getSubjectDN()))) {
            throw new CertificateException("Certificate CN revoked");
        }
        delegate.checkClientTrusted(certs, authType);
    }
}
</pre>
where we check that the client certificate is issued by our CA, and not revoked. Finally, we delegate to the standard X509TrustManager for good measure, e.g. to validate the certificate chain, expiry dates and what-not.

Since we use this trust manager on the server rather than a client, we do not expect its checkServerTrusted() method to be invoked.
<pre>
    @Override
    public void checkServerTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        throw new CertificateException("Server authentication not supported");
    }    
</pre>

<h4>Dynamic revocation</h4>

The set of revoked certificates' identifiers might be read from a file, URL or a database. This could be a synchronized Set that can be updated concurrently, and so enables a dynamic truststore, which we test as follows.
<pre>
public class LocalCaTest {
    ...
    private void testDynamicNameRevocation(KeyStore serverKeyStore, KeyStore serverTrustStore,
            KeyStore clientKeyStore, KeyStore clientTrustStore,
            String revokedName) throws Exception {
        Set<String> revokedNames = new ConcurrentSkipListSet();
        SSLContext serverSSLContext = RevocableNameSSLContexts.create(
                serverKeyStore, pass, serverTrustStore, revokedNames);
        SSLContext clientSSLContext = SSLContexts.create(clientKeyStore, pass, clientTrustStore);
        ServerThread serverThread = new ServerThread();
        try {
            serverThread.start(serverSSLContext, port, 2);
            Assert.assertNull(ClientThread.connect(clientSSLContext, port));
            Assert.assertNull(serverThread.getErrorMessage());
            revokedNames.add(revokedName);
            clientSSLContext = SSLContexts.create(clientKeyStore, pass, clientTrustStore);
            String errorMessage = ClientThread.connect(clientSSLContext, port);
            Assert.assertEquals("java.security.cert.CertificateException: " + 
                    "Certificate CN revoked", 
                    serverThread.getErrorMessage());
            Assert.assertNotNull(errorMessage);
        } finally {
            serverThread.close();
            serverThread.join(1000);
        }
    }
    ...
</pre>
where we create a concurrent Set for the revoked certificates, and revoke a client certificate after the server has been started. Before the certificate is revoked, the connection should succeed, and afterwards it should fail. 

Incidently, we find that the client session is cached for the SSL context, and so we recreate the clientSSLContext instance in our test above. This forces re-initialisation of the client session, and so re-authentication by the server, so that our trust manager is actually invoked and rejects our newly revoked certificate. Perhaps the reader can advise how to disable this client session caching for our unit test?

We connect to the server socket as follows.
<pre>
    static String connect(SSLContext context, int port) 
            throws GeneralSecurityException, IOException {
        SSLSocket socket = (SSLSocket) context.getSocketFactory().
                createSocket(HOST, port);
        try {
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            dos.writeUTF("clienthello");
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            Assert.assertEquals("serverhello", dis.readUTF());
            return null;
        } catch (Exception e) {
            return e.getMessage();
        } finally {
            socket.close();
        }
    }
</pre>
where we return the error message, otherwise null.


<h4>Client keystore</h4>

For example, we create a private SSL keystore for a test client named "evanx" as follows.
<pre>
$ keytool -keystore evanx.jks -genkeypair -keyalg rsa -keysize 2048 -validity 365 -alias evanx \
    -dname "CN=evanx"
</pre>
 
We export our certificate as follows.
<pre>
$ keytool -keystore evanx.jks -alias evanx -exportcert -rfc
</pre>
We cut and paste the exported PEM text into a file, which we can inspect using openssl as follows.
<pre>
$ openssl x509 -text -in evanx.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1380030508 (0x5241982c)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: CN=evanx
        Validity
            Not Before: Sep 24 13:48:28 2013 GMT
            Not After : Sep 24 13:48:28 2014 GMT
        Subject: CN=evanx
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
</pre>
We import the client cert into the server SSL truststore.
<pre>
$ keytool -keystore server.trust.jks -alias evanx -importcert -file evanx.pem
</pre>
Similarly, our CA cert is imported into this client's truststore.

Incidently, in a follow-up article we will create keystores programmatically for our unit tests, taking cues from <a href="http://www.docjar.org/html/api/sun/security/tools/KeyTool.java.html">KeyTool</a>, and emulating the manual procedure.


<h4>Client certificate signing</h4>

We export a certificate signing request (CSR) as follows, and sign this with our local CA cert.
<pre>
$ keytool -keystore evanx.jks -alias evanx -certreq
</pre>
We cut and paste the output PEM text into a CSR file, and use Java7's keytool to sign this CSR, using its new -gencert option, which by the way is not available in earlier JRE's.
<pre>
$ keytool -keystore ca.jks -gencert -validity 365 -rfc \
    -dname "CN=evanx" -infile evanx.csr -outfile evanx.signed.pem \
    -ext BasicConstraints:critical=ca:false,pathlen:0 \
    -ext KeyUsage:critical=digitalSignature \
    -ext ExtendedKeyUsage:critical=clientAuth
</pre>
where we specify an unchanged DN and validity period for the newly signed certificate. We might add some extensions for good measure, i.e. to restrict key usage.

We can inspect the cert using openssl.
<pre>
$ openssl x509 -text -in evanx.signed.pem
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 448957773 (0x1ac28d4d)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=ca
        Validity
            Not Before: Oct 16 20:02:24 2013 GMT
            Not After : Jul 11 20:02:24 2016 GMT
        Subject: CN=evanx
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
</pre>
We see that the X509v3 extensions are set as follows.
<pre>

            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Extended Key Usage: critical
                TLS Web Client Authentication
            X509v3 Key Usage: critical
                Digital Signature
</pre>

Since the keystore requires its key certificate chain to be imported in the correct order starting with the root cert, we import the CA cert first, and then our signed cert.
<pre>
$ keytool -keystore evanx.jks -importcert -noprompt \
    -file ca.pem -alias ca
Enter keystore password: 
Certificate was added to keystore

$ keytool -keystore evanx.jks -importcert -noprompt \
    -file evanx.signed.pem -alias evanx
Enter keystore password: 
Certificate reply was installed in keystore
</pre>

<img align="right" style="margin-left: 4px" src="http://jroller.com/evanx/resource/gnome-keys-250.png" />

<h4>Client certificate management</h4>

Clearly a certificate with a duplicate CN, impersonates the original certificate with that CN. So when issuing a client certificate, we must take care to ensure the uniqueness of the CN, and add the certificate or at least its unique identifier to a registry of some sort. 

If a certificate is signed but not recorded, or its record is deleted, our server is forever vulnerable to that rogue certificate. In order to review access, we clearly require a perfect record of all issued certificates. So we might record our signed certs into a keystore file as follows.
<pre>
$ keytool -keystore server.issued.jks -importcert -alias evanx -file evanx.pem 
Certificate was added to keystore
</pre>
where this is not a truststore per se, but just a database of issued certificates. 

Interestingly, in trying to avoid a truststore containing all our client certificates, we have nevertheless ended up with one! 

<h4>Self-signed client certificates</h4>

Given the risk of a rogue certificate, one might recommend using self-signed client certificates which are explicitly imported into our server truststore, where they can be reviewed. Any issued certificate which goes unrecorded or is given a duplicate identifier by mistake or on purpose, presents a vulnerability.

Note that when using self-signed client certs (or CA-signed server certs), the server keystore must not be used as its truststore, since the keystore naturally contains the server certificate, and so a rogue certificate can be created by signing it with the server key, e.g. using keytool -gencert, as illustrated above. 

Similarly, when using CA-signed server certs, the server keystore contains the CA root key, and so must not be used as the truststore. Otherwise any client cert signed by that CA would trusted, rather than just the client certs we have specifically added to the truststore.

As a precaution, we might use an explicit trust manager, implemented as follows.
<pre>
public class ExplicitTrustManager implements X509TrustManager {
    X509TrustManager delegate;
    Map<String, X509Certificate> certificateMap = new HashMap();
    
    public ExplicitTrustManager(KeyStore trustStore) 
        throws GeneralSecurityException {
        this.delegate = KeyStores.getX509TrustManager(trustStore);
        for (String alias: Collections.list(trustStore.aliases())) {
            certificateMap.put(alias, (X509Certificate) 
                    trustStore.getCertificate(alias));
        }
    }
    ...
</pre>
where we build a map of the certificates in our truststore, and check peer certificate chains as follows.
<pre>    
    private void checkTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        if (certs.length < 1) {
            throw new CertificateException("Invalid cert chain length");
        }
        X509Certificate trustedCertificate = certificateMap.get(
                getCN(certs[0].getSubjectDN()));
        if (trustedCertificate == null) {
            throw new CertificateException("Untrusted client certificate");            
        }
        if (!Arrays.equals(certs[0].getPublicKey().getEncoded(),
                trustedCertificate.getPublicKey().getEncoded())) {
            throw new CertificateException("Invalid client certificate");
        }
    }
</pre>
where we check that the first cert in the chain sent by the peer, is contained in our map.

We can use this trust manager on the server and client.
<pre>
    @Override
    public void checkClientTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        checkTrusted(certs);
        delegate.checkClientTrusted(certs, authType);
    }

    @Override
    public void checkServerTrusted(X509Certificate[] certs, String authType) 
            throws CertificateException {
        checkTrusted(certs);
        delegate.checkServerTrusted(certs, authType);
    }    
</pre>

<h4>Conclusion</h4>

We can sign client certificates using a local CA root certificate. However, we should then support certificate revocation, e.g. to disable specific clients. So we introduce a custom SSL trust manager to support a local revocation list. Naturally this is only useful is if we can configure our server to use it!

<img align="right" src="http://jroller.com/evanx/resource/Gnome-application-certificate-250-crop.png">

We discuss the risk of rogue certificates, and recommend using self-signed client certificates whenever possible, rather than a local CA as presented here.

We introduce an explicit trust manager, which only trusts the peer certificate if it is contained in the truststore, irregardless of its certificate chain. This protects against rogue certificates signed by trusted certificates.

<h4>Furthermore</h4>

We'll delve into the unit testing of our custom trust manager in a follow-up article. Thereafter, we might implement a local CA management tool that records issued certificates, and supports standard CRLs.

<h4>Resources</h4>

You can browse the code for this exercise on <a href="https://code.google.com/p/vellum">code.google.com/vellum</a>.

<h4>Other reading</h4>

Also relating to Java crypto in this blog: <a href="https://weblogs.java.net/blog/evanx/archive/2013/01/24/password-salt">Password Salt</a> for secure passwords; and leveraging the <a href="https://weblogs.java.net/blog/evanx/archive/2012/11/07/google-authenticator-thus-enabled">Google Authenticator</a> mobile app for multi-factor authentication for your own sites.

