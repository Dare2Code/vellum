
Let's say we have a following class with Swing components.

<pre>
public class PersonEditor {
    JPanel mainPanel;
    JTextField firstname;
    JTextField surname;
    JFormattedTextField dateOfBirth;
    ...
    public PersonEditor() {
        GSwingBuilder.build(this); // inject the above components
    }
    ...    
}
</pre>

Let's create the following companion resource file, named <tt>PersonEditor.def</tt>.

<pre>
    JPanel mainPanel;
    JTextField firstname;
    JTextField surname;
    JFormattedTextField dateOfBirth;
    ...    
    mainPanel = panel();
        tabbedPane();
            panel();              
                firstnameLabel = label(); gbc(0, 0);
                firstname; gbc(gridx = 1);
                surnameLabel = label(); gbc(0, 1);
                surname; gbc(1, 1);
                ...
                applyChanges = button();
            panel();
            ...
</pre>
where firstly, we have cut and pasted the component declarations from <tt>PersonEditor.java</tt>.
<img alt="lockstart_session.png" src="http://weblogs.java.net/blog/evanx/archive/lockstart_session.png" width="64" height="64" align="right" hspace="16" vspace="8"/>
But then we present a hierarchy of objects that are to be constructed using various methods eg. <tt>panel()</tt>, <tt>tabbedPane()</tt>, <tt>label()</tt>. Also, declared components are referenced by name eg. <tt>firstname</tt>, <tt>surname</tt>.

So the above resource file is like an extension script used in conjunction with the following Java builder that we implement.

<pre> 
 public class GSwingBuilder extends GBuilder {

    JPanel panel() {
        return new JPanel(new GridBagLayout());
    }

    GridBagConstraints gbc(int gridx, int gridy) {
        ...
    }        

    JLabel label() {
        return new JLabel();
    }
    ...
    JTextField createTextField() {
        return new JTextField();               
    }

    JFormattedTextField createFormattedTextField() {
        return new JFormattedTextField();
    }    
    ...
    void add(Container container, Component component, GridBagConstraints gbc) {
        container.add(component, gbc);
    }
}
</pre>

The <tt>build()</tt> method in the <tt>GBuilder</tt> superclass will parse the resource file script in order construct the objects (using reflection to find and invoke methods in the above builder subclass), and importantly, invoke <tt>add()</tt> to assemble the components. Finally it injects the constructed components into the declared fields of our <tt>PersonEditor</tt> object.

<img alt="jabber_protocol_64.png" src="http://weblogs.java.net/blog/evanx/archive/jabber_protocol_64.png" width="64" height="64" align="left" hspace="16" vspace="8"/>
This offers the following niceties. Firstly and most importantly, we can use indentation to express our hierarchy most conveniently. Secondly, constituent components can be either unnamed eg. panels and panes, or named ie. for referencing and injection of input components into our UI controller class, and also of course for resource injection into these components ie. of translatable labels, customisable colors, fonts, <i>et cetera</i>.

So we create a Java builder class where we can define whatever methods we want, and the script file references these methods, together with fields in the target class, in order to construct, assemble and inject objects into the target.

Isn't this quite flexible, given that we couple Java code with our script in this way, such that builder code extends the script, and the script extends the target code?!

Next we might consider how this can be applied to HTML component trees e.g. where we create a <tt>GBuilder</tt> subclass called <tt>GHtmlBuilder</tt>, define a component tree using a script, and expose the components we want to access via the Java target class, for the purpose of creating HTML output using Java code (for its programmability) together with a complementary builder script.