
Last week we introduced the trivial namesake Timestamped interface, and used the excellent ArrayDeque of Java6 to collect such things, imposing a time-based capacity and some external synchronization. Now let's test this with some threads.

<!--break-->

<p>   
<a style='text-decoration: none;' href="https://code.google.com/p/vellum/wiki/home">
<div style="border-bottom: solid 1px; color: #000000; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/1/12/Gnome-appointment-new.svg" border="0" align="left" hspace="0"/><span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Deque shredder:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A part of "Timestamped: a trilogy in a few parts."</span>
</div>
</a>

Just to remind the reader, and for completeness herewithin, our <a href="http://weblogs.java.net/blog/evanx/archive/2012/06/27/timestamped-deque">deque collector</a> for our <tt>Timestamped</tt> thingies, looks like follows.

<pre>
public class TimestampedDequer<T extends Timestamped>  {
    long capacityMillis;
    long lastTimestamp;
    ArrayDeque<T> deque = new ArrayDeque();
    
    public TimestampedDequer(long capacityMillis) {
        this.capacityMillis = capacityMillis;
    }
    
    public synchronized void addLast(T element) {
        if (element.getTimestamp() == 0 || element.getTimestamp() < lastTimestamp) {
            deque.clear(); // throw our toys out the cot exception
        } else {
            lastTimestamp = element.getTimestamp();
            prune(lastTimestamp);
            deque.addLast(element);
        }
    }

    private void prune(long latestTimestamp) {
        while (deque.size() > 0 && 
                deque.getFirst().getTimestamp() <= latestTimestamp - capacityMillis) {
            deque.removeFirst();
        }
    }

    public synchronized Deque<T> snapshot(long lastTimestamp) {
        prune(lastTimestamp);
        return deque.clone();
    }

    public synchronized Deque<T> tail(int size) {
        Deque tail = new ArrayDeque();
        Iterator<T> it = deque.descendingIterator();
        for (int i = 0; i < size && it.hasNext(); i++) {
            tail.addFirst(it.next());
        }
        return tail;
    }    
}
</pre>
where we use the efficient <a href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayDeque.html"><tt>ArrayDeque</tt></a> implementation of Java6.

<img src="http://jroller.com/evanx/resource/bicycle-guardians-deck-rider-black-front-crop.jpg" align="right" hspace="8"/>
As discussed last time, we remove expired elements from the head when we add the latest element to the tail, to make it self-pruning. We provide a sychronized <tt>snapshot()</tt> and <tt>tail()</tt> for a couple of use-cases as follows... 

Most importantly, we will use <tt>snapshot()</tt> to analyse the latest records for the desired interval e.g. the last minute, for an automated status check every minute, possibly invoked externally via JMX or HTTP, for the purpose of triggering alerts, e.g. via Gtalk, SMS and email. <i>Shew!</tt>

Furthermore, we will use <tt>tail()</tt> to examine the latest records, e.g. to display in an HTTP response, and to attach to a notification email.

Now let's do us some "heavy-dropping" with threads - ouch!
<pre>
public class TimestampedDequerTest  {
    long capacityMillis = 90;
    long scheduledInterval = 10;
    long scheduledDelay = 0;
    final TimestampedDequer<TimestampedElement> dequer = new TimestampedDequer(capacityMillis);
    boolean verbose = false;
    
    Runnable scheduledRunnable = new Runnable() {

        @Override
        public void run() {
            addLast();
        }
    };

    private void addLast() {
        long timestamp = System.currentTimeMillis();
        String value = "record at " + timestamp;
        dequer.addLast(new TimestampedElement(value, timestamp));
        if (verbose) {
            System.out.println(value);
        }
    }
    @Test
    public void testConcurrently() throws Exception {
        ScheduledFuture future = Executors.newScheduledThreadPool(1).scheduleAtFixedRate(
                    scheduledRunnable, scheduledDelay, scheduledInterval, TimeUnit.MILLISECONDS);
        check();
        check();
        future.cancel(true);
    }
</pre>
where we use a <tt>ScheduledExecutorService</tt> to schedule a thread to regularly add records into the deque. 

We check twice, just to make sure... ;) Actually we do want to make sure of the <tt>prune()</tt>'ing, following the sleep for <tt>capacityMillis</tt>.
<pre>    
    private void check() throws Exception {
        long startMillis = System.currentTimeMillis();
        System.out.println("startMillis " + startMillis);
        verbose = true;
        Thread.sleep(capacityMillis);
        int expectedCapacity = (int) (capacityMillis / scheduledInterval);
        verbose = false;
        long stopMillis = System.currentTimeMillis();
        System.out.println("stopMillis " + stopMillis);
        Deque<TimestampedElement> deque = dequer.snapshot(stopMillis);
        long firstTimestamp = deque.getFirst().getTimestamp();   
        long lastTimestamp = deque.getLast().getTimestamp();   
        System.out.println("size " + deque.size());
        System.out.println("first " + firstTimestamp);
        System.out.println("last " + lastTimestamp);
        Assert.assertTrue("first time", firstTimestamp >= startMillis);        
        Assert.assertTrue("last time", lastTimestamp >= firstTimestamp);
        Assert.assertTrue("capacityMillis min", lastTimestamp - firstTimestamp >= 0);        
        Assert.assertTrue("capacityMillis max", lastTimestamp - firstTimestamp <= capacityMillis);        
        Assert.assertTrue("size min", deque.size() > 0);
        Assert.assertTrue("size max", deque.size() <= expectedCapacity);
        checkSet(deque);
    }    
</pre>
<i>What we gots?</i>
<pre>
scheduledInterval 10
record at 1340231378158
record at 1340231378168
record at 1340231378178
...
record at 1340231378228
record at 1340231378238
startMillis 1340231378157
stopMillis 1340231378247
size 9
first 1340231378158
last 1340231378238
...
startMillis 1340231378249
stopMillis 1340231378339
size 9
first 1340231378258
last 1340231378338
</pre>
We survey the output and nod, ponderously.

As an aside just for good measure, we use our <tt>TimestampedComparator</tt> to get a sorted set.
<pre>
    private void checkSet(Deque<TimestampedElement> deque) throws Exception {
        SortedSet<Timestamped> set = new TreeSet(new TimestampedComparator());
        set.addAll(deque);        
        Assert.assertEquals("first", deque.getFirst().getTimestamp(), set.first().getTimestamp());
        Assert.assertEquals("last", deque.getLast().getTimestamp(), set.last().getTimestamp());
    }
</pre>
where the check that the first and last timestamps match. 

Finally, let's vary the <tt>scheduledInterval</tt>. 
<pre>
    @Test
    public void testScheduledIntervals() throws Exception {
        while (--scheduledInterval > 0) {
            ScheduledFuture future = Executors.newScheduledThreadPool(10).scheduleAtFixedRate(
                    scheduledRunnable, scheduledDelay, scheduledInterval, TimeUnit.MILLISECONDS);
            Thread.sleep(capacityMillis);
            int expectedCapacity = (int) (capacityMillis / scheduledInterval);
            long stopMillis = System.currentTimeMillis();
            Deque<TimestampedElement> deque = dequer.snapshot(stopMillis);
            System.out.printf("interval, capacity, size: %d, %d, %d\n", 
                    scheduledInterval, expectedCapacity, deque.size());
            Assert.assertTrue("size min", deque.size() > 0);
            Woohoo.assertTrue("size max", deque.size() <= expectedCapacity);
            future.cancel(true);
            Thread.sleep(scheduledInterval);
        }
    }
</pre>
where we loop the <tt>scheduledInterval</tt> down to 1ms. <i>Oh my gods... surely this will not end well?!</i>
<pre>
interval, capacity, size: 9, 10, 10
interval, capacity, size: 8, 11, 11
interval, capacity, size: 7, 12, 12
interval, capacity, size: 6, 15, 15
interval, capacity, size: 5, 18, 17
interval, capacity, size: 4, 22, 22
interval, capacity, size: 3, 30, 29
interval, capacity, size: 2, 45, 44
interval, capacity, size: 1, 90, 91
D'oh! size max
</pre>
Given how unpredictable time is, ironically, with those threads and what-not, we can't exactly predict the size of the list. D'oh! So for that we have used the following util class to see if the size is more or less what we expect.
<pre>
public class Woohoo {

    public static void assertTrue(String message, boolean condition) {
        if (!condition) {
            System.err.printf("D'oh! %s\n", message);
        }
    }
</pre>
Selectively using the above drop-in replacement for <tt>Assert</tt>, we get our tests to pass 100%, woohoo! Heh heh.
<i>"Put that in your internet, put that in your twitter right there."</i> ;)

<h3>Resources</h3>

https://code.google.com/p/vellum/ - where i will collate these articles and their code.

<h2>Coming later</h2>

We'll capture log records using our <tt>TimestampedDequer</tt>, and periodically analyse the latest <tt>deque</tt> of logs e.g. for the last minute, to detect when our app's wheels are wobbling or even coming off altogether. 
