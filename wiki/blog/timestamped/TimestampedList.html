

In this here second part of the "Timestamped" series, we introduce the namesake Timestamped interface, and use a LinkedList to collect such things, with a time-based capacity. 

<!--break-->

Ultimately we gonna hook up a remote Log4j appender, to gather stats to display via a handy HTTP server, and to compute when things are perhaps going horribly wrong, in order to notify ourselves via Gtalk - but lemme not get ahead of myself.

Incidently we kicked off this no-hit wonder series with <a href="http://weblogs.java.net/blog/evanx/archive/2012/06/07/counter-map">Counter Map</a>, which does not feature further yet, so ignore that for now.

<p>   
<a style='text-decoration: none;' href="https://code.google.com/p/vellum/wiki/home">
<div style="border-bottom: solid 1px; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/1/12/Gnome-appointment-new.svg" border="0" align="left" hspace="0"/><span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Timestamped List:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A part of "Timestamped: a trilogy in a few parts."</span>
</div>
</a>

Without further ado, I give you the namesake interface of this series.
<pre>
public interface Timestamped {
    public long getTimestampMillis();    
}
</pre>
Also take an adapter for a Log4j logging event. 
<pre>
public class TimestampedLoggingEventAdapter implements Timestamped {
    LoggingEvent loggingEvent;

    public TimestampedLoggingEventAdapter(LoggingEvent loggingEvent) {
        this.loggingEvent = loggingEvent;
    }

    @Override
    public long getTimestampMillis() {
        return loggingEvent.getTimeStamp();
    }
}
</pre>
And a generic wrapped element.
<pre>
public class TimestampedElement<T> implements Timestamped {
    T element;
    long timestampMillis;

    public TimestampedElement(T element, long timestampMillis) {
        this.element = element;
        this.timestampMillis = timestampMillis;
    }

    public T getElement() {
        return element;
    }
    
    @Override
    public long getTimestampMillis() {
        return timestampMillis;
    }
}
</pre>
We might want equality by the timestamp for this element.
<pre>
    @Override
    public int hashCode() {
        return (int) (timestampMillis % Integer.MAX_VALUE);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Timestamped) {
            return timestampMillis == ((Timestamped) obj).getTimestampMillis();
        }
        return false;
    }
</pre>
Also, a comparator will undoubtedly be required at some stage. 
<pre>
public class TimestampedComparator implements Comparator<Timestamped> {

    @Override
    public int compare(Timestamped o1, Timestamped o2) {
        if (o1.getTimestampMillis() < o2.getTimestampMillis()) return -1;
        if (o1.getTimestampMillis() > o2.getTimestampMillis()) return 1;
        else return 0;
    }    
}
</pre>

<h2>Timestamped List</h2>

Now let's introduce the namesake of this article, a list of timestamped thingies, with a time-based capacity - a "circular buffer" or FILO queue, some might call it.
<pre>
public class TimestampedList<T extends Timestamped>  {
    long capacityMillis;
    LinkedList<T> linkedList = new LinkedList();

    public TimestampedList(long capacityMillis) {
        this.capacityMillis = capacityMillis;
    }
    
    public synchronized void add(T element) {
        prune(element.getTimestampMillis());
        linkedList.add(0, element);
    }

    private void prune(long timestamp) {
        while (linkedList.size() > 0) {
            T last = linkedList.getLast();
            if (last != null && last.getTimestampMillis() < timestamp - capacityMillis) {
                return;
            }
            linkedList.remove(last);
        }
    }
</pre>
where, considering a scenario where this is continuously digesting log records at a helluva rate, we compose a <tt>LinkedList</tt> rather than extend one, in order to prevent someone even considering a <tt>remove()</tt> or <tt>add()</tt>, whose mere presence would be a guaranteed ticking timebomb, one might say, aptly.

We add elements at the head of the list, so it's in reverse chronological order. 

Crucially, when we <tt>add()</tt> an element at the head, we <tt>prune()</tt> older elements from the tail, so that our list is not growing out of control. 

Observe that the <tt>prune()</tt> implementation assumes that elements are added in chronological order. Otherwise your mileage will be taking an off-road detour.

In order to inspect the contents, we use <tt>getList()</tt>, which returns a defensive copy, and so is a helluva costly operation. Perhaps you could recommend an alternative strategy? And do we really need everything <tt>synchronized</tt>?
<pre>
    public synchronized List<T> getList() {
        return getList(System.currentTimeMillis());
    }
    
    public synchronized List<T> getList(long millis) {
        prune(millis);
        return new ArrayList(linkedList);
    }

    public synchronized List<T> getSubList(int size) {
        if (linkedList.size() <= size) {
            return new ArrayList(linkedList);
        } else {
            return new ArrayList(linkedList.subList(0, size));
        }
    }
</pre>
where the <tt>getSubList()</tt> requests the latest so-many elements (or less), in reverse chronological order, for us to display e.g. in a servlet, later in this series.

Let's test this thing. 
<pre>
public class TimestampedListTest implements Runnable {
    long capacityMillis = 30;
    long scheduledInterval = 10;
    long scheduledDelay = 0;
    boolean verbose = false;
    final TimestampedList timestampedList = new TimestampedList(capacityMillis);
    ScheduledFuture future = Executors.newScheduledThreadPool(1).scheduleAtFixedRate(
            this, scheduledDelay, scheduledInterval, TimeUnit.MILLISECONDS);
            
    @Override
    public void run() {
        long timestamp = System.currentTimeMillis();
        String value = "record at " + timestamp;
        timestampedList.add(new TimestampedElement(value, timestamp));
        if (verbose) {
            System.out.println(value);
        }
    }
    
    @Test
    public void test() throws Exception {
        check();
        check();
        future.cancel(true);
    }    
</pre>
where we schedule a thread to insert records all the while.

We perform the <tt>check()</tt> twice... just to make sure! ;)
<pre>    
    private void check() throws Exception {
        verbose = true;
        long startMillis = System.currentTimeMillis();
        Thread.sleep(capacityMillis);
        verbose = false;
        List<Timestamped> list = timestampedList.getList(startMillis + capacityMillis);
        SortedSet<Timestamped> set = new TreeSet(new TimestampedComparator());
        set.addAll(list);
        Assert.assertEquals("first", list.get(0).getTimestampMillis(), set.last().getTimestampMillis());
        Collections.reverse(list);
        Assert.assertEquals("last", list.get(0).getTimestampMillis(), set.first().getTimestampMillis());
        Assert.assertTrue("first", set.first().getTimestampMillis() >= startMillis);
        Assert.assertTrue("last time" , 
                set.last().getTimestampMillis() >= startMillis + capacityMillis - scheduledInterval);
        Assert.assertTrue("capacityMillis", 
                set.last().getTimestampMillis() - set.first().getTimestampMillis() <= capacityMillis);
        System.out.println("startMillis " + startMillis);
        System.out.println("first " + set.first().getTimestampMillis());
        System.out.println("last " + set.last().getTimestampMillis());
        System.out.println("size " + list.size());
        System.out.println("capacity " + (capacityMillis/scheduledInterval));
    }    
</pre>
Given how unpredictable time is, ironically, we can't be sure of the size of the list. However, we find that changing a few <tt>assertTrue()</tt>'s to some <tt>System.out.println()</tt>'s here and there, makes the test pass 100%, woohoo! <i>"Put that in your internet, put that in your twitter right there."</i>
<pre>
record at 1340050675290
record at 1340050675300
record at 1340050675310
startMillis 1340050675281
first 1340050675290
last 1340050675310
size 3
capacity 3
</pre>
We observe the output and nod, ponderously.

<h3>Resources</h3>

https://code.google.com/p/vellum/ - where i will collate these articles and their code.

<h2>Coming soon</h2>

We'll capture log records into our <tt>TimestampedList</tt>, and analyse a sample of logs e.g. for the last minute, to realise  when the wheels are starting to come off our app. 
