
<style>
    body {
        font-family: "Trebuchet MS",Geneva,Verdana,sans-serif;
        font-size: 11pt;
        color: #333;    
    }
    tt {
        font-size: 12pt;        
    }
    pre {
        font: "Lucida Console";
        font-size: 10pt;
        padding: 4px;
        background: #F3F3F3;        
        border: 1px solid #888;        
    }
    div#left-column {
        float: left;
        width: 0px;        
        margin-left: 0px;        
    }
    tt {
        
    }
    div#content{
        float: left;
        margin-left: 200px;
        width: 800px;
        font-family: "Trebuchet MS",Geneva,Verdana,sans-serif;
        font-size: 11pt;
        color: #333;    
        padding: 0;
    }
</style>

<!--
The first part in a series entitled "Timestamped: a trilogy in a few parts." For starters, we introduce a "counter map" and ensure we can sort it by its integer values.
-->
<body>
<div id="left-column">    
</div>

<div id="content">    

We herewith begin a saga about monitoring with this series entitled "Timestamped: a trilogy in a few parts," this being the first part, where we introduce a map to count key things, and ensure we can sort it by its integer values.

<p>   
<a style='text-decoration: none;' href="https://code.google.com/p/vellum/wiki/home">
<div style="border-bottom: solid 1px; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/1/12/Gnome-appointment-new.svg" border="0" align="left" hspace="0"/><span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Counter map:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A part of "Timestamped: a trilogy in a few parts."</span>
</div>
</a>

<p>We will be analysing logs in this unwinding series. Ultimately we gonna hook up a remote Log4j appender to digest our logs to gather stats, and make some judgement calls as to the rapidly changing status of our app.  

<p>As you can imagine we will need to count so many <i>key</i> things like the number of successes and failures of one thing or another. For this purpose, we introduce the following so-called "counter map."

<pre>
public class IntegerCounterMap<K> extends TreeMap<K, Integer> {
    private int totalCount = 0;

    public int getInt(K key, int defaultValue) {
        if (!containsKey(key)) {
            return defaultValue;
        } else {
            return get(key);
        }
    }

    public int getInt(K key) {
        return getInt(key, 0);
    }
    
    public void increment(K key) {
        totalCount++;
        put(key, new Integer(getInt(key) + 1));
    }

    public int getTotalCount() {
        return totalCount;
    }

    public int calculateTotalCount() {
        int total = 0;
        for (K key : keySet()) {
            total += getInt(key);
        }
        return total;
    }
    
    public Iterable<K> descendingValueKeySet() {
        return Maps.descendingValueKeySet(this);
    }    
}
</pre>

<p>For sure we are going to count some of these key things, so we add <tt>increment()</tt> method to use when digesting log messages.

<pre>
    @Test
    public void testCounterMap() {
        IntegerCounterMap<String> counterMap = new IntegerCounterMap();
        counterMap.increment("INFO");
        counterMap.increment("ERROR");
        counterMap.increment("ERROR");
        Assert.assertEquals(counterMap.getInt("WARN"), 0);
        Assert.assertEquals(counterMap.getInt("INFO"), 1);
        Assert.assertEquals(counterMap.getInt("ERROR"), 2);
        Assert.assertEquals(counterMap.size(), 2);
        Assert.assertEquals(counterMap.getTotalCount(), 3);
        Assert.assertEquals(counterMap.getTotalCount(), counterMap.calculateTotalCount());
   }
</pre>

<p>where since WARN is not incremented like the others, it's not put into the map, and so the <tt>size</tt> of map is only the two keys, namely INFO and ERROR.

<p>We provided a <tt>descendingValueKeySet()</tt> method for when we wanna display counters is descending order, to see the biggest numbers. This is delegates to the following util class. 

<pre>
public class Maps {  

    public static <K, V> Iterable<K> descendingValueKeySet(Map<K, V> map) {
        return keySet(descendingValueEntrySet(map));
    }
    
    private static <K, V> NavigableSet<Entry<K, V>> descendingValueEntrySet(Map<K, V> map) {
        TreeSet set = new TreeSet(new Comparator<Entry>() {

            @Override
            public int compare(Entry o1, Entry o2) {
                return ((Comparable) o2.getValue()).compareTo(o1.getValue());
            }
        });
        set.addAll(map.entrySet());
        return set;
    }

    private static <K, V> Iterable<K> keySet(NavigableSet<Entry<K, V>> entrySet) {
        List<K> keyList = new ArrayList();
        for (Map.Entry entry : entrySet) {
            keyList.add((K) entry.getKey());
        }
        return keyList;
    }
}
</pre>

<p>where courtesy of a <tt>TreeMap</tt>, we sort the map's entries by value, and put the thus ordered keys into a <tt>List</tt> to iterate over e.g. in a <tt>for</tt> each loop.

<p>See also [http://stackoverflow.com/questions/109383/how-to-sort-a-mapkey-value-on-the-values-in-java stackoverflow.com]. 

<p>Let's test this ordering. 

<pre>
    @Test
    public void testDescendingCounterMap() {
        IntegerCounterMap<String> counterMap = new IntegerCounterMap();
        counterMap.put("BWARN", 0);
        counterMap.put("DEBUG", 1000000);
        counterMap.put("ERROR", 1000);
        counterMap.increment("ERROR");
        counterMap.increment("INFO");
        for (String key : counterMap.descendingValueKeySet()) {
            System.out.printf("%d %s\n", counterMap.get(key), key);
        }
        Assert.assertEquals(counterMap.descendingValueKeySet().iterator().next(), "DEBUG");
        String lastKey = null;
        int keyCount = 0;
        for (String key : counterMap.descendingValueKeySet()) {
            lastKey = key;
            keyCount++;
        }
        Assert.assertEquals(lastKey, "BWARN");
        Assert.assertEquals(keyCount, 4);
    }
</pre>

<p>where we use "BWARN" instead of "WARN" to be sure we aren't picking up the natural ordering. (Yes that was happening and hiding a bug quite effectively.)

<p>After some DEBUG'ing (with the help of a lot logging), we eventually get what we were expecting. <i>"Put that in your internet, put that in your twitter right there."</i>

<pre>
1000000 DEBUG
1001 ERROR
1 INFO
0 BWARN
</pre>

<p>As so often seems to be case, we have a million DEBUG messages, a thousand and one ERRORs with very little INFO to go on, and no bloody warnings.

<h2>Coming soon</h2>

<p>In part two, we'll properly  introduce the namesake of this series, a so-called <tt>Timestamped</tt> interface, for our "time series" or what-have-you.

<pre>
public interface Timestamped {
    public long getTimestampMillis();    
}
</pre>

