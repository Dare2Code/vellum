
<!--
The first part in a series entitled "Timestamped: a trilogy in a few parts." For starters, we introduce a "counter map" and ensure we can sort it by its integer values.
-->


I plan to blog about monitoring and what-not, and to begin this saga, I'll start with this series 
"Timestamped: a trilogy in a few parts,"  this being the first part,  where we introduce a "counter map" 
and ensure we can sort it by its integer values.

We will be analysing logs in this unwinding series. Ultimately we gonna hook up a remote Log4j appender to digest 
our logs to gather stats, and make some judgement calls as to the rapidly changing status of our app.  

<a style='text-decoration: none;' href="https://code.google.com/p/vellum/wiki/home">
<div style="border-bottom: solid 1px; background-color: #ccff00;">
<img src="http://upload.wikimedia.org/wikipedia/commons/1/12/Gnome-appointment-new.svg" border="0" align="left" hspace="0"/>
<span style="font-style: normal; font-weight: bold; font-size: 12pt;">&nbsp;Descending map:</span><span style="font-style: italic; font-weight: normal; font-size: 11pt;">&nbsp;A part of "Timestamped: a trilogy in a few parts."</span>
</div>
</a>

As you can imagine we will need to count so many <i>key</i> things like the number of successes and failures 
of one thing or another. For this purpose, we introduce the following so-called "counter map."

<code>
public class IntegerCounterMap<K> extends TreeMap<K, Integer> {
    protected int totalCount = 0;
    
    public int getInt(K key) {
        Integer value = get(key);
        if (value == null) {
            return 0;
        }
        return value;
    }
    
    public void increment(K key) {
        totalCount++;
        Integer value = getInt(key);
        put(key, new Integer(value.intValue() + 1));
    }

    public int getTotalCount() {
        return totalCount;
    }

    public int calculateTotalCount() {
        int total = 0;
        for (K key : keySet()) {
            total += getInt(key);
        }
        return total;
    }

    public Iterable<K> descendingValueKeySet() {
        return Maps.descendingValueKeySet(this);
    }    
}
</code> 

For sure we are going to count some of these key things, so we add <tt>increment()</tt> method to use when digesting log messages.

<code>
    @Test
    public void testCounterMap() {
        IntegerCounterMap<String> counterMap = new IntegerCounterMap();
        counterMap.increment("ERROR");
        Assert.assertEquals(counterMap.getTotalCount(), counterMap.calculateTotalCount());
        ...
    }
</code>

Also we provide a <tt>descendingValueKeySet()</tt> method for when we wanna display counters is descending order, to see the biggest numbers. This is delegates to the following util class. 

<code>
public class Maps {  

    public static <K, V> Iterable<K> descendingValueKeySet(Map<K, V> map) {
        return keySet(descendingValueEntrySet(map));
    }

    private static <K, V> NavigableSet<Entry<K, V>> descendingValueEntrySet(Map<K, V> map) {
        TreeSet set = new TreeSet(new Comparator<Entry>() {

            @Override
            public int compare(Entry o1, Entry o2) {
                return ((Comparable) o2.getValue()).compareTo(o1.getValue());
            }
        });
        set.addAll(map.entrySet());
        return set;
    }

    private static <K, V> Iterable<K> keySet(NavigableSet<Entry<K, V>> entrySet) {
        List<K> keyList = new ArrayList();
        for (Map.Entry entry : entrySet) {
            keyList.add((K) entry.getKey());
        }
        return keyList;
    }
}
</code>

where we sort the map's entries by value, and put the keys into a <tt>List</tt> to iterate over in <tt>for</tt> loops.

See also http://stackoverflow.com/questions/109383/how-to-sort-a-mapkey-value-on-the-values-in-java.
<i>"Put that in your internet, put that in your twitter right there."</i>

Finally let's test it. 

<code>
    @Test
    public void testDescendingMap() {
        Map<String, Integer> counterMap = new HashMap();
        counterMap.put("WARNING", 0);
        counterMap.put("DEBUG", 1000000);
        counterMap.put("ERROR", 5000);
        counterMap.put("INFO", 1);
        for (String key : Maps.descendingValueKeySet(counterMap)) {
            System.out.printf("%d %s\n", counterMap.get(key), key);            
        }
        Assert.assertEquals(Maps.descendingValueKeySet(counterMap).iterator().next(), "DEBUG");
        String lastKey = null;
        int keyCount = 0;
        for (String key : Maps.descendingValueKeySet(counterMap)) {
            lastKey = key;
            keyCount++;
        }
        Assert.assertEquals(lastKey, "WARNING");
        Assert.assertEquals(keyCount, 4);
    }
</code>

And we after some debugging with the help of logging, we get what we would have wanted. 

<code>
1000000 DEBUG
5000 ERROR
1 INFO
0 WARNING
</code>

As so often seems to be case, we have a million DEBUG messages and so many ERRORs with absolutely no bloody warning and very little INFO to go on.

<h2>Coming soon</h2>

In part two, we'll properly  introduce the namesake of this series, the <tt>Timestamped</tt> interface, 
not to mention <tt>TimestampedList</tt>, <tt>TimestampedSample</tt> and what-not.

<pre>
public interface Timestamped {
    public void setTimestampMillis(long millis);
    public long getTimestampMillis();    
}
</pre>
 